[{"title":"docker常用命令","url":"/2022/05/18/backend/common-docker-commands/","content":"<p><code>docker pull</code>: </p>\n<a id=\"more\"></a>\n<p><code>docker save</code>:</p>\n<p><code>docker rmi</code>:</p>\n<p><code>docker ps</code>:</p>\n<p><code>docker images</code>:</p>\n<p><code>docker load</code>:</p>\n","tags":["note"]},{"title":"数字电路-加法器的实现","url":"/2020/10/20/computer/digital-circuit-the-realization-of-adder/","content":"<p>本文打通了机械世界与电子世界的通路，希望读者在头脑中建立机械与电子的对应关系，同时可以理解为什么二进制更适合计算机领域。从加法器举一反三，设想其他运算器的实现。<br><a id=\"more\"></a></p>\n<h2 id=\"门电路\"><a href=\"#门电路\" class=\"headerlink\" title=\"门电路\"></a>门电路</h2><p>常见的门电路有：<code>与门</code>，<code>或门</code>，<code>非门</code>，<code>异或门</code>，<code>与非门</code>，<code>或非门</code>。</p>\n<p>今天，我们就来说说这些门电路是如何实现的，并用它来实现一个加法器。</p>\n<h3 id=\"非门（NOT）\"><a href=\"#非门（NOT）\" class=\"headerlink\" title=\"非门（NOT）\"></a>非门（NOT）</h3><h4 id=\"逻辑符号-amp-布尔表达式-amp-真值表\"><a href=\"#逻辑符号-amp-布尔表达式-amp-真值表\" class=\"headerlink\" title=\"逻辑符号 &amp; 布尔表达式 &amp; 真值表\"></a>逻辑符号 &amp; 布尔表达式 &amp; 真值表</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/1.png\" alt=\"\"></p>\n<p>请务必记住其逻辑框图符合，再后面做加法器时我们要用其来表示！</p>\n<h4 id=\"继电器实现\"><a href=\"#继电器实现\" class=\"headerlink\" title=\"继电器实现\"></a>继电器实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/2.png\" alt=\"\"></p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/3.png\" alt=\"\"></p>\n<ul>\n<li>输入端输入1时，电磁铁会把金属弹簧片吸下来，从而灯泡电路断开，灯泡不发光，即输出0</li>\n<li>输入端输入0时，电磁铁会把金属弹簧片维持原来的位置，从而灯泡电路连接，灯泡发光即输出1</li>\n</ul>\n<p>这就实现了一个非门：<code>输入1，输出0；输入0，输出1</code>。</p>\n<h4 id=\"晶体管实现\"><a href=\"#晶体管实现\" class=\"headerlink\" title=\"晶体管实现\"></a>晶体管实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/4.png\" alt=\"\"></p>\n<p>在分析这个电路之前，我们先看看这个晶体管的线路：</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/5.png\" alt=\"\"></p>\n<p>在计算机电路中，源极是一个高电压，发射极接地，基极通常做输入端，它决定了是否将源极接地：</p>\n<ul>\n<li>当基极为高电压(1)时：晶体管闭合-&gt;源极接地-&gt;输出端为低电压(0)</li>\n<li>当基极为低电压(0)时：晶体管打开-&gt;源极不接地-&gt;输出端为高电压(1)</li>\n</ul>\n<p>经过上面的分析，你应该已经知道晶体管非门电路实现的原理了吧，那么对上面那幅图就不做再多的阐述了。</p>\n<h3 id=\"与门（NOT）\"><a href=\"#与门（NOT）\" class=\"headerlink\" title=\"与门（NOT）\"></a>与门（NOT）</h3><h4 id=\"逻辑符号-amp-布尔表达式-amp-真值表-1\"><a href=\"#逻辑符号-amp-布尔表达式-amp-真值表-1\" class=\"headerlink\" title=\"逻辑符号 &amp; 布尔表达式 &amp; 真值表\"></a>逻辑符号 &amp; 布尔表达式 &amp; 真值表</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/6.png\" alt=\"\"></p>\n<h4 id=\"继电器实现-1\"><a href=\"#继电器实现-1\" class=\"headerlink\" title=\"继电器实现\"></a>继电器实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/7.png\" alt=\"\"></p>\n<p>可以看出，只有当两个开关都闭合时，灯泡才亮，很明显，这是一个与门电路。<br>两个继电器串联可以组成一个与门</p>\n<h4 id=\"晶体管实现-1\"><a href=\"#晶体管实现-1\" class=\"headerlink\" title=\"晶体管实现\"></a>晶体管实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/8.png\" alt=\"\"></p>\n<p>相信这个电路大家都看得懂，不再做过多的阐述</p>\n<h3 id=\"或门（OR）\"><a href=\"#或门（OR）\" class=\"headerlink\" title=\"或门（OR）\"></a>或门（OR）</h3><h4 id=\"逻辑符号-amp-布尔表达式-amp-真值表-2\"><a href=\"#逻辑符号-amp-布尔表达式-amp-真值表-2\" class=\"headerlink\" title=\"逻辑符号 &amp; 布尔表达式 &amp; 真值表\"></a>逻辑符号 &amp; 布尔表达式 &amp; 真值表</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/9.png\" alt=\"\"></p>\n<h4 id=\"继电器实现-2\"><a href=\"#继电器实现-2\" class=\"headerlink\" title=\"继电器实现\"></a>继电器实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/10.png\" alt=\"\"></p>\n<p>可以看出，只有任意一个开关闭合，灯泡就亮，很明显，这是一个或门电路。<br>两个继电器并联可以组成一个或门</p>\n<h4 id=\"晶体管实现-2\"><a href=\"#晶体管实现-2\" class=\"headerlink\" title=\"晶体管实现\"></a>晶体管实现</h4><p>这里就不画了，等到后面介绍或非门时，你可以在或非门输出端加上一个非门，从而组成或门。</p>\n<h3 id=\"与非门（NAND）\"><a href=\"#与非门（NAND）\" class=\"headerlink\" title=\"与非门（NAND）\"></a>与非门（NAND）</h3><h4 id=\"逻辑符号-amp-布尔表达式-amp-真值表-3\"><a href=\"#逻辑符号-amp-布尔表达式-amp-真值表-3\" class=\"headerlink\" title=\"逻辑符号 &amp; 布尔表达式 &amp; 真值表\"></a>逻辑符号 &amp; 布尔表达式 &amp; 真值表</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/11.png\" alt=\"\"></p>\n<h4 id=\"继电器实现-3\"><a href=\"#继电器实现-3\" class=\"headerlink\" title=\"继电器实现\"></a>继电器实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/12.png\" alt=\"\"></p>\n<p>我们可以看到：只要有一个开端断开，则灯泡就亮，这符合与非门：有0则1</p>\n<h4 id=\"晶体管实现-3\"><a href=\"#晶体管实现-3\" class=\"headerlink\" title=\"晶体管实现\"></a>晶体管实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/13.png\" alt=\"\"></p>\n<p>V1，V2只要有一个为低电平，那么源极将不会接地，则输出端为高电平</p>\n<h3 id=\"或非门（XOR）\"><a href=\"#或非门（XOR）\" class=\"headerlink\" title=\"或非门（XOR）\"></a>或非门（XOR）</h3><h4 id=\"逻辑符号-amp-布尔表达式-amp-真值表-4\"><a href=\"#逻辑符号-amp-布尔表达式-amp-真值表-4\" class=\"headerlink\" title=\"逻辑符号 &amp; 布尔表达式 &amp; 真值表\"></a>逻辑符号 &amp; 布尔表达式 &amp; 真值表</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/14.png\" alt=\"\"></p>\n<h4 id=\"继电器实现-4\"><a href=\"#继电器实现-4\" class=\"headerlink\" title=\"继电器实现\"></a>继电器实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/15.png\" alt=\"\"></p>\n<p>我们可以看到：只要有一个开端闭合，则灯泡将不亮，这符合与或门：有1则0</p>\n<h4 id=\"晶体管实现-4\"><a href=\"#晶体管实现-4\" class=\"headerlink\" title=\"晶体管实现\"></a>晶体管实现</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/16.png\" alt=\"\"></p>\n<p>V1，V2有一个微高电平时，源极将接地，输出端为低电平。</p>\n<h3 id=\"异或门（XOR）\"><a href=\"#异或门（XOR）\" class=\"headerlink\" title=\"异或门（XOR）\"></a>异或门（XOR）</h3><h4 id=\"逻辑符号-amp-布尔表达式-amp-真值表-5\"><a href=\"#逻辑符号-amp-布尔表达式-amp-真值表-5\" class=\"headerlink\" title=\"逻辑符号 &amp; 布尔表达式 &amp; 真值表\"></a>逻辑符号 &amp; 布尔表达式 &amp; 真值表</h4><p><img data-src=\"/images/digital-circuit-the-realization-of-adder/17.png\" alt=\"\"></p>\n<p>注意到：异或门的真值表，刚好符合我们二进制的加法运算，1+1 = 01，0是本位输出位，1则是进位，后面我们将用异或门来做加法器</p>\n<h4 id=\"继电器实现-5\"><a href=\"#继电器实现-5\" class=\"headerlink\" title=\"继电器实现\"></a>继电器实现</h4><p>由于异或门的实现需要用到或门和与非门和与门，要想用继电器来描述则有点难画，所以我们用逻辑框图符合来描述异或门：</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/18.png\" alt=\"\"></p>\n<p>我们来看看每一步的真值表：</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/19.png\" alt=\"\"></p>\n<p>显然，输入和输出完全符合我们之前的定义的异或门。下面，我们要用其来做加法器。</p>\n<p>经过上面的分析，我们已经掌握了6种逻辑门：</p>\n<ul>\n<li>非门：将唯一的输入值求逆</li>\n<li>与门：属于都为1时，输出才为1</li>\n<li>或门：属于有一个为1时，就为1</li>\n<li>与非门：结果与非门的相反</li>\n<li>或非门：结果与或门的相反</li>\n<li>异或门：两个输入皆相同时，就输出0</li>\n</ul>\n<p>以上几种门电路的特征务必记住，下面我们就要开始真正地做加法器了，让我们看看计算机内部是如何进行加法运算的</p>\n<h2 id=\"加法器\"><a href=\"#加法器\" class=\"headerlink\" title=\"加法器\"></a>加法器</h2><h3 id=\"半加器\"><a href=\"#半加器\" class=\"headerlink\" title=\"半加器\"></a>半加器</h3><p>所谓半加器，就是计算两个位数的和并产生进位的电路，不考虑进位。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>第一个数</th>\n<th>第二个数</th>\n<th>本位输出</th>\n<th>进位输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>在本位加输出中，若两个输入数相同则是0，不同则是1，所以我们可以用<code>异或门</code><br>来实现</p>\n<p>在进位输出中，若输入的两个数都是1，才输出1，所以我们可以用与门来实现。<br>那么我们的半加器就做出来了：</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/20.png\" alt=\"\"></p>\n<p>为了简单，我们也可以采用以下表示：</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/21.png\" alt=\"\"></p>\n<h3 id=\"全加器\"><a href=\"#全加器\" class=\"headerlink\" title=\"全加器\"></a>全加器</h3><p>在实际中，因为涉及到多位数的运算，所以不得不考虑进位，那么半加器就不能满足我们的需求了，所以我们要做一个全加器</p>\n<p>所谓全加器，就是对二进制执行加法运算的电路，考虑进位</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>第一个数</th>\n<th>第二个数</th>\n<th>进位到本位的数</th>\n<th>本位输出</th>\n<th>进位输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>我们直接给出全加器的电路，请读者根据真值表来分析</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/22.png\" alt=\"\"></p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/23.png\" alt=\"\"></p>\n<p>我们再组合一下，把表达变得更简单：</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/24.png\" alt=\"\"></p>\n<h3 id=\"八位加法器\"><a href=\"#八位加法器\" class=\"headerlink\" title=\"八位加法器\"></a>八位加法器</h3><p>要实现八位加法器，当然就要八个全加器，只不过第一个全加器的进位输入值我们设为0</p>\n<p><img data-src=\"/images/digital-circuit-the-realization-of-adder/25.png\" alt=\"\"></p>\n<p>这就是八位加法器，进位输入我们设置为0，然后A，B就是我要进行加法运算的8bits的二进制数。</p>\n<p>按照这种思路，我们也可以设计出16位，32位的加法器。</p>\n","categories":["Computer"],"tags":["DigitalCircuit","CPU"]},{"title":"历年图灵奖获得者","url":"/2021/05/28/computer/turing/","content":"<p>本文记录了历年图灵奖获得者。<br><a id=\"more\"></a></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>年份</th>\n<th>姓名</th>\n<th>贡献领域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1966年</td>\n<td>艾伦·佩利</td>\n<td>高级程序设计技巧，编译器构造</td>\n</tr>\n<tr>\n<td>1967年</td>\n<td>莫里斯·威尔克斯</td>\n<td>存储程序式计算机EDSAC，EDSAC 2，程序库</td>\n</tr>\n<tr>\n<td>1968年</td>\n<td>理查德·卫斯里·汉明</td>\n<td>数值方法，自动编码系统，错误检测和纠错码</td>\n</tr>\n<tr>\n<td>1969年</td>\n<td>马文·闵斯基</td>\n<td>人工智能</td>\n</tr>\n<tr>\n<td>1970年</td>\n<td>詹姆斯·维尔金森</td>\n<td>数值分析，线性代数，倒退错误分析</td>\n</tr>\n<tr>\n<td>1971年</td>\n<td>约翰·麦卡锡</td>\n<td>人工智能</td>\n</tr>\n<tr>\n<td>1972年</td>\n<td>艾兹格·迪科斯彻</td>\n<td>程序设计语言的科学与艺术</td>\n</tr>\n<tr>\n<td>1973年</td>\n<td>查理士·巴赫曼</td>\n<td>数据库技术</td>\n</tr>\n<tr>\n<td>1974年</td>\n<td>高德纳</td>\n<td>算法分析、程序设计语言的设计、程序设计</td>\n</tr>\n<tr>\n<td>1975年</td>\n<td>艾伦·纽厄尔、赫伯特·西蒙</td>\n<td>人工智能，人类认知心理学和列表处理（list processing）</td>\n</tr>\n<tr>\n<td>1976年</td>\n<td>迈克尔·拉宾、达纳·斯科特</td>\n<td>非确定性自动机</td>\n</tr>\n<tr>\n<td>1977年</td>\n<td>约翰·巴克斯</td>\n<td>高级编程系统，程序设计语言规范的形式化定义</td>\n</tr>\n<tr>\n<td>1978年</td>\n<td>罗伯特·弗洛伊德</td>\n<td>设计高效可靠软件的方法学</td>\n</tr>\n<tr>\n<td>1979年</td>\n<td>肯尼斯·艾佛森</td>\n<td>程序设计语言和数学符号，互动系统的设计，运用APL进行教学，程序设计语言的理论与实践</td>\n</tr>\n<tr>\n<td>1980年</td>\n<td>东尼·霍尔</td>\n<td>程序设计语言的定义与设计</td>\n</tr>\n<tr>\n<td>1981年</td>\n<td>埃德加·科德</td>\n<td>数据库系统，尤其是关系型数据库</td>\n</tr>\n<tr>\n<td>1982年</td>\n<td>史提芬·古克</td>\n<td>计算复杂度</td>\n</tr>\n<tr>\n<td>1983年</td>\n<td>肯·汤普逊、丹尼斯·里奇</td>\n<td>UNIX操作系统和C语言</td>\n</tr>\n<tr>\n<td>1984年</td>\n<td>尼克劳斯·维尔特</td>\n<td>程序设计语言设计、程序设计</td>\n</tr>\n<tr>\n<td>1985年</td>\n<td>理查德·卡普</td>\n<td>算法理论，尤其是NP-完全性理论</td>\n</tr>\n<tr>\n<td>1986年</td>\n<td>约翰·霍普克洛夫特、罗伯特·塔扬</td>\n<td>算法和数据结构的设计与分析</td>\n</tr>\n<tr>\n<td>1987年</td>\n<td>约翰·科克</td>\n<td>编译理论，大型系统的体系结构，及精简指令集（RISC）计算机的开发</td>\n</tr>\n<tr>\n<td>1988年</td>\n<td>伊凡·苏泽兰</td>\n<td>计算机图形学</td>\n</tr>\n<tr>\n<td>1989年</td>\n<td>威廉·卡韩</td>\n<td>数值分析</td>\n</tr>\n<tr>\n<td>1990年</td>\n<td>费尔南多·考巴托</td>\n<td>CTSS和Multics</td>\n</tr>\n<tr>\n<td>1991年</td>\n<td>罗宾·米尔纳</td>\n<td>LCF，ML语言，CCS</td>\n</tr>\n<tr>\n<td>1992年</td>\n<td>巴特勒·兰普森</td>\n<td>分布式，个人计算环境</td>\n</tr>\n<tr>\n<td>1993年</td>\n<td>尤里斯·哈特马尼斯、理查德·斯特恩斯</td>\n<td>计算复杂度理论</td>\n</tr>\n<tr>\n<td>1994年</td>\n<td>爱德华·费根鲍姆、拉吉·瑞迪</td>\n<td>大规模人工智能系统</td>\n</tr>\n<tr>\n<td>1995年</td>\n<td>曼纽尔·布卢姆</td>\n<td>计算复杂度理论，及其在密码学和程序校验上的应用</td>\n</tr>\n<tr>\n<td>1996年</td>\n<td>阿米尔·伯努利</td>\n<td>时序逻辑，程序与系统验证</td>\n</tr>\n<tr>\n<td>1997年</td>\n<td>道格拉斯·恩格尔巴特</td>\n<td>互动计算</td>\n</tr>\n<tr>\n<td>1998年</td>\n<td>詹姆斯·尼古拉·格雷</td>\n<td>数据库与事务处理</td>\n</tr>\n<tr>\n<td>1999年</td>\n<td>弗雷德里克·布鲁克斯</td>\n<td>计算机体系结构，操作系统，软件工程</td>\n</tr>\n<tr>\n<td>2000年</td>\n<td>姚期智</td>\n<td>计算理论，包括伪随机数生成，密码学与通信复杂度</td>\n</tr>\n<tr>\n<td>2001年</td>\n<td>奥利-约翰·达尔、克利斯登·奈加特</td>\n<td>面向对象编程</td>\n</tr>\n<tr>\n<td>2002年</td>\n<td>罗纳德·李维斯特、阿迪·萨莫尔、伦纳德·阿德曼</td>\n<td>公钥密码学（RSA加密算法）</td>\n</tr>\n<tr>\n<td>2003年</td>\n<td>艾伦·凯</td>\n<td>面向对象编程</td>\n</tr>\n<tr>\n<td>2004年</td>\n<td>文特·瑟夫、罗伯特·卡恩</td>\n<td>TCP/IP协议</td>\n</tr>\n<tr>\n<td>2005年</td>\n<td>彼得·诺尔</td>\n<td>Algol 60语言</td>\n</tr>\n<tr>\n<td>2006年</td>\n<td>法兰西斯·艾伦</td>\n<td>优化编译器</td>\n</tr>\n<tr>\n<td>2007年</td>\n<td>爱德蒙·克拉克、艾伦·爱默生、约瑟夫·斯发基斯</td>\n<td>开发自动化方法检测计算机硬件和软件中的设计错误</td>\n</tr>\n<tr>\n<td>2008年</td>\n<td>芭芭拉·利斯科夫</td>\n<td>编程语言和系统设计的实践与理论</td>\n</tr>\n<tr>\n<td>2009年</td>\n<td>查尔斯·萨克尔</td>\n<td>帮助设计、制造第一款现代PC</td>\n</tr>\n<tr>\n<td>2010年</td>\n<td>莱斯利·瓦伦特</td>\n<td>对众多计算理论所做的变革性的贡献</td>\n</tr>\n<tr>\n<td>2011年</td>\n<td>朱迪亚·珀尔</td>\n<td>通过概率论和因果推理对人工智能领域作出的根本性贡献</td>\n</tr>\n<tr>\n<td>2012年</td>\n<td>莎菲·戈德瓦塞尔、希尔维奥·米卡利</td>\n<td>在密码科学领域里，于复杂理论的基础之上，做出变革性工作；并领先发展出新的具有数学可证明性的有效验证机制</td>\n</tr>\n<tr>\n<td>2013年</td>\n<td>莱斯利·兰波特</td>\n<td>对于分布式及并形系统的理论与实践具有基础性贡献，尤其是诸如因果逻辑时序（causality and logical clocks）、安全性与存活度（safety and liveness）、复制状态机（replicated state machines）及循序一致性（sequential consistency）等理论概念的发明</td>\n</tr>\n<tr>\n<td>2014年</td>\n<td>迈克尔·斯通布雷克</td>\n<td>对现代数据库的概念和实践作出的根本性贡献</td>\n</tr>\n<tr>\n<td>2015年</td>\n<td>惠特菲尔德·迪菲、马丁·赫尔曼</td>\n<td>发明迪菲-赫尔曼密钥交换，对公开密钥加密技术有重大贡献</td>\n</tr>\n<tr>\n<td>2016年</td>\n<td>蒂姆·伯纳斯-李</td>\n<td>发明了万维网、第一个浏览器和使得万维网得以扩展的基础协议及算法</td>\n</tr>\n<tr>\n<td>2017年</td>\n<td>约翰·轩尼诗、大卫·帕特森</td>\n<td>开创了一种系统的、定量的方法来设计和评价计算机体系结构，并对微处理器行业产生了持久的影响。</td>\n</tr>\n<tr>\n<td>2018年</td>\n<td>约书亚·本希奥、杰弗里·辛顿、杨立昆</td>\n<td>深度学习</td>\n</tr>\n<tr>\n<td>2019年</td>\n<td>艾德文·卡特姆、帕特里克·汉拉恩</td>\n<td>对于3D计算机图形学的基本贡献，以及这些技术对电影制作和其他应用中的计算机生成图像（CGI）的革命性影响。</td>\n</tr>\n<tr>\n<td>2020年</td>\n<td>阿尔佛雷德·艾侯、杰弗瑞·乌尔曼</td>\n<td>对程序语言实现的基础性算法和理论的贡献。</td>\n</tr>\n<tr>\n<td>2021年</td>\n<td>杰克·唐加拉</td>\n<td>通过对线性代数运算的高效数值算法、并行计算编程机制和性能评估工具的贡献，引领了高性能计算的世界。</td>\n</tr>\n</tbody>\n</table>\n</div>\n","tags":["note"]},{"title":"html的meta用法总结","url":"/2016/05/12/frontend/html-meta-usage/","content":"<p>META标签是HTML语言HEAD区的一个辅助性标签，它位于HTML文档头部的<code>&lt;HEAD&gt;</code>标记和<code>&lt;TITLE&gt;</code>标记之间，它提供用户不可见的信息。meta标签通常用来为搜索引擎robots定义页面主题，或者是定义用户浏览器上的cookie；它可以用于鉴别作者，设定页面格式，标注内容提要和关键字；还可以设置页面使其可以根据你定义的时间间隔刷新自己,以及设置RASC内容等级，等等。<br><a id=\"more\"></a><br>也许你认为这些代码可有可无。其实如果你能够用好meta标签，会给你带来意想不到的效果，meta标签的作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等！</p>\n<p>meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。</p>\n<h2 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h2><p>name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。</p>\n<p>meta标签的name属性语法格式是：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"参数\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"具体的参数值\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中name属性主要有以下几种参数：</p>\n<h3 id=\"Keywords-关键字\"><a href=\"#Keywords-关键字\" class=\"headerlink\" title=\"Keywords(关键字)\"></a>Keywords(关键字)</h3><p>说明：keywords用来告诉搜索引擎你网页的关键字是什么。</p>\n<p>举例：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"keywords\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"meta总结,html meta,meta属性,meta跳转\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"description-网站内容描述\"><a href=\"#description-网站内容描述\" class=\"headerlink\" title=\"description(网站内容描述)\"></a>description(网站内容描述)</h3><p>说明：description用来告诉搜索引擎你的网站主要内容。</p>\n<p>举例：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"description\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"haorooms博客,html的meta总结，meta是html语言head区的一个辅助性标签。\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"robots-机器人向导\"><a href=\"#robots-机器人向导\" class=\"headerlink\" title=\"robots(机器人向导)\"></a>robots(机器人向导)</h3><p>说明：<code>robots</code>用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。</p>\n<p><code>content</code>的参数有<code>all</code>,<code>none</code>,<code>index</code>,<code>noindex</code>,<code>follow</code>,<code>nofollow</code>。默认是<code>all</code>。</p>\n<p>举例：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"robots\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"none\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>具体参数如下：</p>\n<p>信息参数为all：文件将被检索，且页面上的链接可以被查询；</p>\n<p>信息参数为none：文件将不被检索，且页面上的链接不可以被查询；</p>\n<p>信息参数为index：文件将被检索；</p>\n<p>信息参数为follow：页面上的链接可以被查询；</p>\n<p>信息参数为noindex：文件将不被检索，但页面上的链接可以被查询；</p>\n<p>信息参数为nofollow：文件将被检索，但页面上的链接不可以被查询；</p>\n<h3 id=\"author-作者\"><a href=\"#author-作者\" class=\"headerlink\" title=\"author(作者)\"></a>author(作者)</h3><p>说明：标注网页的作者</p>\n<p>举例：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"author\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"root,root@xxxx.com\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"generator\"><a href=\"#generator\" class=\"headerlink\" title=\"generator\"></a>generator</h3><p>meta标签的generator的信息参数，代表说明网站的采用的什么软件制作。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"generator\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"信息参数\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"COPYRIGHT\"><a href=\"#COPYRIGHT\" class=\"headerlink\" title=\"COPYRIGHT\"></a>COPYRIGHT</h3><p>meta标签的COPYRIGHT的信息参数，代表说明网站版权信息。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"COPYRIGHT\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"信息参数\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"revisit-after\"><a href=\"#revisit-after\" class=\"headerlink\" title=\"revisit-after\"></a>revisit-after</h3><p>revisit-after代表网站重访,7days代表7天，依此类推。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"revisit-after\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"7days\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"http-equiv属性\"><a href=\"#http-equiv属性\" class=\"headerlink\" title=\"http-equiv属性\"></a>http-equiv属性</h2><p><code>http-equiv</code>顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为<code>content</code>，<code>content</code>中的内容其实就是各个参数的变量值。</p>\n<p>meta标签的<code>http-equiv</code>属性语法格式是：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"参数\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"参数变量值\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中http-equiv属性主要有以下几种参数：</p>\n<h3 id=\"Expires-期限\"><a href=\"#Expires-期限\" class=\"headerlink\" title=\"Expires(期限)\"></a>Expires(期限)</h3><p>说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。</p>\n<p>用法：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"expires\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"Fri,12Jan200118:18:18GMT\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>注意：必须使用GMT的时间格式。</p>\n<h3 id=\"Pragma-cache模式\"><a href=\"#Pragma-cache模式\" class=\"headerlink\" title=\"Pragma(cache模式)\"></a>Pragma(cache模式)</h3><p>说明：禁止浏览器从本地计算机的缓存中访问页面内容。</p>\n<p>用法：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Pragma\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"no-cache\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>注意：这样设定，访问者将无法脱机浏览。</p>\n<h3 id=\"Refresh-刷新\"><a href=\"#Refresh-刷新\" class=\"headerlink\" title=\"Refresh(刷新)\"></a>Refresh(刷新)</h3><p>说明：自动刷新并指向新页面。</p>\n<p>用法：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Refresh\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"2;URL=http://www.haorooms.com\"</span>&gt;</span> //(注意后面的引号，分别在秒数的前面和网址的后面)</span><br></pre></td></tr></table></figure><br>注意：其中的2是指停留2秒钟后自动刷新到URL网址。</p>\n<h3 id=\"Set-Cookie-cookie设定\"><a href=\"#Set-Cookie-cookie设定\" class=\"headerlink\" title=\"Set-Cookie(cookie设定)\"></a>Set-Cookie(cookie设定)</h3><p>说明：如果网页过期，那么存盘的cookie将被删除。</p>\n<p>用法：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Set-Cookie\"</span><span class=\"attr\">content</span>=<span class=\"string\">\" cookie value=xxx; expires=Friday,12-Jan-200118:18:18GMT；path=/\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>注意：必须使用GMT的时间格式。</p>\n<h3 id=\"Window-target-显示窗口的设定\"><a href=\"#Window-target-显示窗口的设定\" class=\"headerlink\" title=\"Window-target(显示窗口的设定)\"></a>Window-target(显示窗口的设定)</h3><p>说明：强制页面在当前窗口以独立页面显示。</p>\n<p>用法：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Window-target\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"_top\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>注意：用来防止别人在框架里调用自己的页面。</p>\n<h3 id=\"content-Type-显示字符集的设定\"><a href=\"#content-Type-显示字符集的设定\" class=\"headerlink\" title=\"content-Type(显示字符集的设定)\"></a>content-Type(显示字符集的设定)</h3><p>说明：设定页面使用的字符集。</p>\n<p>用法：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html; charset=gb2312\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>具体如下：</p>\n<p>meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文；</p>\n<p>meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文；</p>\n<p>meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文；</p>\n<p>meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文；</p>\n<p>meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文；</p>\n<p>meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码；</p>\n<h3 id=\"content-Language（显示语言的设定）\"><a href=\"#content-Language（显示语言的设定）\" class=\"headerlink\" title=\"content-Language（显示语言的设定）\"></a>content-Language（显示语言的设定）</h3><p>用法：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Language\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"zh-cn\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Cache-Control指定请求和响应遵循的缓存机制。\"><a href=\"#Cache-Control指定请求和响应遵循的缓存机制。\" class=\"headerlink\" title=\"Cache-Control指定请求和响应遵循的缓存机制。\"></a>Cache-Control指定请求和响应遵循的缓存机制。</h3><p><code>Cache-Control</code>指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置<code>Cache-Control</code>并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括<code>no-cache</code>、<code>no-store</code>、<code>max-age</code>、<code>max-stale</code>、<code>min-fresh</code>、<code>only-if-cached</code>，响应消息中的指令包括<code>public</code>、<code>private</code>、<code>no-cache</code>、<code>no-store</code>、<code>no-transform</code>、<code>must-revalidate</code>、<code>proxy-revalidate</code>、<code>max-age</code>。各个消息中的指令含义如下</p>\n<p><code>Public</code>指示响应可被任何缓存区缓存</p>\n<p><code>Private</code>指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效</p>\n<p><code>no-cache</code>指示请求或响应消息不能缓存</p>\n<p><code>no-store</code>用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</p>\n<p><code>max-age</code>指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应</p>\n<p><code>min-fresh</code>指示客户机可以接收响应时间小于当前时间加上指定时间的响应</p>\n<p><code>max-stale</code>指示客户机可以接收超出超时期间的响应消息。如果指定<code>max-stale</code>消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>\n<h3 id=\"http-equiv-quot-imagetoolbar-quot\"><a href=\"#http-equiv-quot-imagetoolbar-quot\" class=\"headerlink\" title=\"http-equiv=&quot;imagetoolbar&quot;\"></a>http-equiv=&quot;imagetoolbar&quot;</h3><p>指定是否显示图片工具栏，当为false代表不显示，当为true代表显示。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"imagetoolbar\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Content-Script-Type\"><a href=\"#Content-Script-Type\" class=\"headerlink\" title=\"Content-Script-Type\"></a>Content-Script-Type</h3><p>W3C网页规范，指明页面中脚本的类型。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Script-Type\"</span> <span class=\"attr\">Content</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"HTML-lt-base-gt-标签\"><a href=\"#HTML-lt-base-gt-标签\" class=\"headerlink\" title=\"HTML &lt; base &gt; 标签\"></a>HTML &lt; base &gt; 标签</h2><p>为页面上所有链接指定默认打开方式：</p>\n<p>例如：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">base</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_self\"</span>&gt;</span> //指定页面中所有标签都是本页打开！</span><br></pre></td></tr></table></figure></p>\n","categories":["FrontEnd","http"],"tags":["html","http"]},{"title":"浏览器缓存","url":"/2016/10/22/frontend/http-cache/","content":"<p>浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。本文对浏览器缓存过程及策略作一分析。<br><a id=\"more\"></a><br>根据上面的特点，浏览器缓存有下面的优点：</p>\n<ul>\n<li>减少冗余的数据传输</li>\n<li>减少服务器负担</li>\n<li>加快客户端加载网页的速度</li>\n</ul>\n<p>浏览器缓存是Web性能优化的重要方式。那么浏览器缓存的过程究竟是怎么样的呢？</p>\n<p>在浏览器第一次发起请求时，本地无缓存，向web服务器发送请求，服务器起端响应请求，浏览器端缓存。过程如下：</p>\n<p><img data-src=\"/images/http-cache/1.png\" alt=\"\"></p>\n<p>在第一次请求时，服务器会将页面最后修改时间通过<code>Last-Modified</code>标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个<code>Etag</code>，并发送给客户端。</p>\n<p>浏览器后续再次进行请求时：</p>\n<p><img data-src=\"/images/http-cache/2.png\" alt=\"\"></p>\n<p>浏览器缓存主要分为<strong>强缓存</strong>（也称<strong>本地缓存</strong>）和<strong>弱缓存</strong>（也称<strong>协商缓存</strong>）。根据上图，浏览器在第一次请求发生后，再次发送请求时：</p>\n<ul>\n<li>浏览器请求某一资源时，会先获取该资源缓存的<code>header</code>信息，然后根据<code>header</code>中的<code>Cache-Control</code>和<code>Expires</code>来判断是否过期。若没过期则直接从缓存中获取资源信息，包括缓存的<code>header</code>的信息，所以此次请求不会与服务器进行通信。这里判断是否过期，则是强缓存相关。后面会讲<code>Cache-Control</code>和<code>Expires</code>相关。</li>\n<li>如果显示已过期，浏览器会向服务器端发送请求，这个请求会携带第一次请求返回的有关缓存的<code>header</code>字段信息，比如客户端会通过<code>If-None-Match</code>头将先前服务器端发送过来的<code>Etag</code>发送给服务器，服务会对比这个客户端发过来的<code>Etag</code>是否与服务器的相同，若相同，就将<code>If-None-Match</code>的值设为<code>false</code>，返回状态<code>304</code>，客户端继续使用本地缓存，不解析服务器端发回来的数据，若不相同就将<code>If-None-Match</code>的值设为<code>true</code>，返回状态为<code>200</code>，客户端重新机械服务器端返回的数据；客户端还会通过<code>If-Modified-Since</code>头将先前服务器端发过来的最后修改时间戳发送给服务器，服务器端通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回最新的内容，如果是最新的，则返回304，客户端继续使用本地缓存。</li>\n</ul>\n<h2 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h2><p>强缓存是利用http头中的<code>Expires</code>和<code>Cache-Control</code>两个字段来控制的，用来表示资源的缓存时间。强缓存中，普通刷新会忽略它，但不会清除它，需要强制刷新。浏览器强制刷新，请求会带上<code>Cache-Control:no-cache</code>和<code>Pragma:no-cache</code></p>\n<h3 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h3><p><code>Expires</code>是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。如我现在这个网页的<code>Expires</code>值是：<code>expires:Fri, 14 Apr 2017 10:47:02 GMT</code>。这个时间代表这这个资源的失效时间，只要发送请求时间是在<code>Expires</code>之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现<code>Cache-Control:max-age</code>和<code>Expires</code>，那么<code>max-age</code>优先级更高。如我主页的response headers部分如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cache-control:max-age&#x3D;691200</span><br><span class=\"line\">expires:Fri, 14 Apr 2017 10:47:02 GMT</span><br></pre></td></tr></table></figure><br>那么表示资源可以被缓存的最长时间为691200秒，会优先考虑<code>max-age</code>。</p>\n<h3 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h3><p><code>Cache-Control</code>是在http1.1中出现的，主要是利用该字段的<code>max-age</code>值来进行判断，它是一个相对时间，例如<code>Cache-Control:max-age=3600</code>，代表着资源的有效期是3600秒。<code>cache-control</code>除了该字段外，还有下面几个比较常用的设置值：</p>\n<p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在<code>ETag</code>，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p>\n<p>no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p>\n<p>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</p>\n<p>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p>\n<p><code>Cache-Control</code>与<code>Expires</code>可以在服务端配置同时启用，同时启用的时候<code>Cache-Control</code>优先级高。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。</p>\n<p>普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存，这也是为什么有时候我们更新一张图片、一个js文件，页面内容依然是旧的，但是直接浏览器访问那个图片或文件，看到的内容却是新的。</p>\n<p>这个主要涉及到两组header字段：<code>Etag</code>和<code>If-None-Match</code>、<code>Last-Modified</code>和<code>If-Modified-Since</code>。</p>\n<h3 id=\"Etag和If-None-Match\"><a href=\"#Etag和If-None-Match\" class=\"headerlink\" title=\"Etag和If-None-Match\"></a>Etag和If-None-Match</h3><p><code>Etag</code>/<code>If-None-Match</code>返回的是一个校验码。ETag可以保证每一个资源是唯一的，资源变化都会导致<code>ETag</code>变化。服务器根据浏览器上送的<code>If-None-Match</code>值来判断是否命中缓存。</p>\n<p>与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于<code>ETag</code>重新生成过，response header中还会把这个<code>ETag</code>返回，即使这个ETag跟之前的没有变化。</p>\n<h3 id=\"Last-Modify-If-Modify-Since\"><a href=\"#Last-Modify-If-Modify-Since\" class=\"headerlink\" title=\"Last-Modify/If-Modify-Since\"></a>Last-Modify/If-Modify-Since</h3><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上<code>Last-Modify</code>，<code>Last-modify</code>是一个时间标识该资源的最后修改时间，例如<code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code>。</p>\n<p>当浏览器再次请求该资源时，request的请求头中会包含<code>If-Modify-Since</code>，该值为缓存之前返回的<code>Last-Modify</code>。服务器收到<code>If-Modify-Since</code>后，根据资源的最后修改时间判断是否命中缓存。</p>\n<p>如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回<code>Last-Modify</code>。</p>\n<h3 id=\"为什么要有Etag\"><a href=\"#为什么要有Etag\" class=\"headerlink\" title=\"为什么要有Etag\"></a>为什么要有Etag</h3><p>你可能会觉得使用<code>Last-Modified</code>已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要<code>Etag</code>呢？HTTP1.1中<code>Etag</code>的出现主要是为了解决几个<code>Last-Modified</code>比较难解决的问题：</p>\n<ul>\n<li><p>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</p>\n</li>\n<li><p>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</p>\n</li>\n<li><p>某些服务器不能精确的得到文件的最后修改时间。</p>\n</li>\n</ul>\n<p><code>Last-Modified</code>与<code>ETag</code>是可以一起使用的，服务器会优先验证<code>ETag</code>，一致的情况下，才会继续比对<code>Last-Modified</code>，最后才决定是否返回<code>304</code>。</p>\n","categories":["FrontEnd","http"],"tags":["http"]},{"title":"前端常见算法的JS实现","url":"/2015/06/22/frontend/note-front-end-common-algorithm/","content":"<p>前端常见算法的JS实现<br><a id=\"more\"></a></p>\n<h2 id=\"排序算法\"><a href=\"#排序算法\" class=\"headerlink\" title=\"排序算法\"></a>排序算法</h2><h4 id=\"1、冒泡排序\"><a href=\"#1、冒泡排序\" class=\"headerlink\" title=\"1、冒泡排序\"></a>1、冒泡排序</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function bubbleSort(arr)&#123;</span><br><span class=\"line\">  var i &#x3D; 0,</span><br><span class=\"line\">      j &#x3D; 0;</span><br><span class=\"line\">  for(i&#x3D;1; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">    for(j&#x3D;0; j&lt;&#x3D;arr.length-i; j++)&#123;</span><br><span class=\"line\">      var temp &#x3D; 0;</span><br><span class=\"line\">      &#x2F;&#x2F; &quot;&gt;&quot; 从小到大排序</span><br><span class=\"line\">      &#x2F;&#x2F; &quot;&lt;&quot; 从大到小排序</span><br><span class=\"line\">      if(arr[j] &gt; arr[j+1])&#123;</span><br><span class=\"line\">        temp &#x3D; arr[j];</span><br><span class=\"line\">        arr[j] &#x3D; arr[j+1];</span><br><span class=\"line\">        arr[j+1] &#x3D; temp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、快速排序\"><a href=\"#2、快速排序\" class=\"headerlink\" title=\"2、快速排序\"></a>2、快速排序</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function quickSort(arr,l,r)&#123;</span><br><span class=\"line\">  if(l &lt; r)&#123;</span><br><span class=\"line\">    var i &#x3D; l, j &#x3D; r, x &#x3D; arr[i];</span><br><span class=\"line\">    while(i&lt;j)&#123;</span><br><span class=\"line\">      while(i&lt;j &amp;&amp; arr[j]&gt;x)</span><br><span class=\"line\">        j--;</span><br><span class=\"line\"></span><br><span class=\"line\">      if(i&lt;j)</span><br><span class=\"line\">        &#x2F;&#x2F;这里用i++，被换过来的必然比x小，赋值后直接让i自加，不用再比较，可以提高效率</span><br><span class=\"line\">        arr[i++] &#x3D; arr[j];</span><br><span class=\"line\"></span><br><span class=\"line\">      while(i&lt;j &amp;&amp; arr[i]&lt;x)</span><br><span class=\"line\">        i++;</span><br><span class=\"line\"></span><br><span class=\"line\">      if(i&lt;j)</span><br><span class=\"line\">        &#x2F;&#x2F;这里用j--，被换过来的必然比x大，赋值后直接让j自减，不用再比较，可以提高效率</span><br><span class=\"line\">        arr[j--] &#x3D; arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[i] &#x3D; x;</span><br><span class=\"line\"></span><br><span class=\"line\">    quickSort(arr, l, i-1);</span><br><span class=\"line\">    quickSort(arr, i+1, r);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、二路归并\"><a href=\"#3、二路归并\" class=\"headerlink\" title=\"3、二路归并\"></a>3、二路归并</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function merge(left, right) &#123;</span><br><span class=\"line\">    var result &#x3D; [],</span><br><span class=\"line\">        il &#x3D; 0,</span><br><span class=\"line\">        ir &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    while (il &lt; left.length &amp;&amp; ir &lt; right.length) &#123;</span><br><span class=\"line\">        if (left[il] &lt; right[ir]) &#123;</span><br><span class=\"line\">            result.push(left[il++]);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            result.push(right[ir++]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(left[il])&#123;</span><br><span class=\"line\">        result.push(left[il++]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(right[ir])&#123;</span><br><span class=\"line\">        result.push(right[ir++]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h2><h4 id=\"1、判断回文字符串\"><a href=\"#1、判断回文字符串\" class=\"headerlink\" title=\"1、判断回文字符串\"></a>1、判断回文字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function palindrome(str)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; \\W匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</span><br><span class=\"line\">  var re &#x3D; &#x2F;[\\W_]&#x2F;g;</span><br><span class=\"line\">  &#x2F;&#x2F; 将字符串变成小写字符,并干掉除字母数字外的字符</span><br><span class=\"line\">  var lowRegStr &#x3D; str.toLowerCase().replace(re,&#39;&#39;);</span><br><span class=\"line\">  &#x2F;&#x2F; 如果字符串lowRegStr的length长度为0时，字符串即是palindrome</span><br><span class=\"line\">  if(lowRegStr.length&#x3D;&#x3D;&#x3D;0) return true;</span><br><span class=\"line\">  &#x2F;&#x2F; 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome</span><br><span class=\"line\">  if(lowRegStr[0]!&#x3D;lowRegStr[lowRegStr.length-1]) return false;</span><br><span class=\"line\">  &#x2F;&#x2F;递归</span><br><span class=\"line\">  return palindrome(lowRegStr.slice(1,lowRegStr.length-1));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、翻转字符串\"><a href=\"#2、翻转字符串\" class=\"headerlink\" title=\"2、翻转字符串\"></a>2、翻转字符串</h4><h5 id=\"思路一：反向遍历字符串\"><a href=\"#思路一：反向遍历字符串\" class=\"headerlink\" title=\"思路一：反向遍历字符串\"></a>思路一：反向遍历字符串</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function reverseString(str)&#123;</span><br><span class=\"line\">  var tmp &#x3D; &#39;&#39;;</span><br><span class=\"line\">  for(var i&#x3D;str.length-1; i&gt;&#x3D;0; i--)</span><br><span class=\"line\">    tmp +&#x3D; str[i];</span><br><span class=\"line\">  return tmp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"思路二：转化成array操作\"><a href=\"#思路二：转化成array操作\" class=\"headerlink\" title=\"思路二：转化成array操作\"></a>思路二：转化成array操作</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function reverseString(str)&#123;</span><br><span class=\"line\">  var arr &#x3D; str.split(&quot;&quot;);</span><br><span class=\"line\">  var i &#x3D; 0,j &#x3D; arr.length-1;</span><br><span class=\"line\">  while(i&lt;j)&#123;</span><br><span class=\"line\">    tmp &#x3D; arr[i];</span><br><span class=\"line\">    arr[i] &#x3D; arr[j];</span><br><span class=\"line\">    arr[j] &#x3D; tmp;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">    j--;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return arr.join(&quot;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、生成指定长度随机字符串\"><a href=\"#3、生成指定长度随机字符串\" class=\"headerlink\" title=\"3、生成指定长度随机字符串\"></a>3、生成指定长度随机字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function randomString(n)&#123;</span><br><span class=\"line\">  var str &#x3D; &#39;abcdefghijklmnopqrstuvwxyz0123456789&#39;;</span><br><span class=\"line\">  var tmp &#x3D; &#39;&#39;;</span><br><span class=\"line\">  for(var i&#x3D;0; i&lt;n; i++) &#123;</span><br><span class=\"line\">    tmp +&#x3D; str.charAt(Math.round(Math.random()*str.length));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、统计字符串中次数最多字母\"><a href=\"#4、统计字符串中次数最多字母\" class=\"headerlink\" title=\"4、统计字符串中次数最多字母\"></a>4、统计字符串中次数最多字母</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function findMaxDuplicateChar(str) &#123;</span><br><span class=\"line\">  if(str.length &#x3D;&#x3D; 1) &#123;</span><br><span class=\"line\">    return str;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var charObj &#x3D; &#123;&#125;;</span><br><span class=\"line\">  for(var i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class=\"line\">    if(!charObj[str.charAt(i)]) &#123;</span><br><span class=\"line\">      charObj[str.charAt(i)] &#x3D; 1;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      charObj[str.charAt(i)] +&#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var maxChar &#x3D; &#39;&#39;,</span><br><span class=\"line\">      maxValue &#x3D; 1;</span><br><span class=\"line\">  for(var k in charObj) &#123;</span><br><span class=\"line\">    if(charObj[k] &gt;&#x3D; maxValue) &#123;</span><br><span class=\"line\">      maxChar &#x3D; k;</span><br><span class=\"line\">      maxValue &#x3D; charObj[k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return maxChar + &#39;：&#39; + maxValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h2><h4 id=\"1、数组去重\"><a href=\"#1、数组去重\" class=\"headerlink\" title=\"1、数组去重\"></a>1、数组去重</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function unique(arr)&#123;</span><br><span class=\"line\">  var obj &#x3D; &#123;&#125;</span><br><span class=\"line\">  var result &#x3D; []</span><br><span class=\"line\">  for(var i in arr)&#123;</span><br><span class=\"line\">    if(!obj[arr[i]])&#123;</span><br><span class=\"line\">      obj[arr[i]] &#x3D; true;</span><br><span class=\"line\">      result.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、数组中最大差值\"><a href=\"#2、数组中最大差值\" class=\"headerlink\" title=\"2、数组中最大差值\"></a>2、数组中最大差值</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getMaxProfit(arr)&#123;</span><br><span class=\"line\">  var min &#x3D; arr[0],</span><br><span class=\"line\">      max &#x3D; arr[0];</span><br><span class=\"line\">  for(var i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class=\"line\">    if(arr[i] &lt; min) min &#x3D; arr[i];</span><br><span class=\"line\">    if(arr[i] &gt; max) max &#x3D; arr[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return max - min;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他常见算法\"><a href=\"#其他常见算法\" class=\"headerlink\" title=\"其他常见算法\"></a>其他常见算法</h2><h4 id=\"1、阶乘\"><a href=\"#1、阶乘\" class=\"headerlink\" title=\"1、阶乘\"></a>1、阶乘</h4><h5 id=\"非递归实现\"><a href=\"#非递归实现\" class=\"headerlink\" title=\"非递归实现\"></a>非递归实现</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function factorialize(num) &#123;</span><br><span class=\"line\">  var result &#x3D; 1;</span><br><span class=\"line\">    if(num &lt; 0) return -1;</span><br><span class=\"line\">    if(num &#x3D;&#x3D; 0 || num &#x3D;&#x3D; 1) return 1;</span><br><span class=\"line\">    while(num&gt;1) &#123;</span><br><span class=\"line\">      result *&#x3D; num--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a>递归实现</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function factorialize(num) &#123;</span><br><span class=\"line\">  var result &#x3D; 1;</span><br><span class=\"line\">  if(num &lt; 0) return -1;</span><br><span class=\"line\">  if(num &#x3D;&#x3D; 0 || num &#x3D;&#x3D; 1) return 1;</span><br><span class=\"line\">  if(num &gt; 1) return num*factorialize(num-1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、生成菲波那切数列\"><a href=\"#2、生成菲波那切数列\" class=\"headerlink\" title=\"2、生成菲波那切数列\"></a>2、生成菲波那切数列</h4><h5 id=\"强行递归实现\"><a href=\"#强行递归实现\" class=\"headerlink\" title=\"强行递归实现\"></a>强行递归实现</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getfib(n)&#123;</span><br><span class=\"line\">  if(n &#x3D;&#x3D; 0) return 0;</span><br><span class=\"line\">  if(n &#x3D;&#x3D; 1) return 1;</span><br><span class=\"line\">  if(n &gt; 1) return getfib(n-1) + getfib(n-2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function fibo(len)&#123;</span><br><span class=\"line\">    var fibo &#x3D; [];</span><br><span class=\"line\">    for(var i &#x3D; 0; i &lt; len; i++)&#123;</span><br><span class=\"line\">      fibo.push(getfib(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return fibo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"简约非递归实现\"><a href=\"#简约非递归实现\" class=\"headerlink\" title=\"简约非递归实现\"></a>简约非递归实现</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function getFibonacci(n) &#123;</span><br><span class=\"line\">  var fibarr &#x3D; [];</span><br><span class=\"line\">  var i &#x3D; 0;</span><br><span class=\"line\">  while(i &lt; n) &#123;</span><br><span class=\"line\">    if(i &lt;&#x3D; 1) &#123;</span><br><span class=\"line\">      fibarr.push(i);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      fibarr.push(fibarr[i - 1] + fibarr[i - 2])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return fibarr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、二分查找\"><a href=\"#3、二分查找\" class=\"headerlink\" title=\"3、二分查找\"></a>3、二分查找</h4><h5 id=\"非递归实现-1\"><a href=\"#非递归实现-1\" class=\"headerlink\" title=\"非递归实现\"></a>非递归实现</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function binary_search(arr, key) &#123;</span><br><span class=\"line\">  var low &#x3D; 0,</span><br><span class=\"line\">      high &#x3D; arr.length - 1;</span><br><span class=\"line\">  while(low &lt;&#x3D; high)&#123;</span><br><span class=\"line\">    var mid &#x3D; parseInt((high + low) &#x2F; 2);</span><br><span class=\"line\">    if(key &#x3D;&#x3D; arr[mid])&#123;</span><br><span class=\"line\">      return mid;</span><br><span class=\"line\">    &#125;else if(key &gt; arr[mid])&#123;</span><br><span class=\"line\">      low &#x3D; mid + 1;</span><br><span class=\"line\">    &#125;else if(key &lt; arr[mid])&#123;</span><br><span class=\"line\">      high &#x3D; mid -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"递归实现-1\"><a href=\"#递归实现-1\" class=\"headerlink\" title=\"递归实现\"></a>递归实现</h5><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function binary_search2(arr, low, high, key) &#123;</span><br><span class=\"line\">  if(low &gt; high) return -1;</span><br><span class=\"line\">  var mid &#x3D; parseInt((low + high)&#x2F;2);</span><br><span class=\"line\">  if(key &#x3D;&#x3D; arr[mid]) &#123;</span><br><span class=\"line\">    return mid;</span><br><span class=\"line\">  &#125; else if(key &gt; arr[mid]) &#123;</span><br><span class=\"line\">    return binary_search2(arr, mid+1, high, key);</span><br><span class=\"line\">  &#125; else if(key &lt; arr[mid]) &#123;</span><br><span class=\"line\">    return binary_search2(arr, low, mid-1, key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["FrontEnd"],"tags":["note","FrontEnd","algorithm"]},{"title":"Git handbook","url":"/2015/08/30/git/note-git-handbook/","content":"<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区</li>\n<li>Repository：仓库区（或本地仓库）</li>\n<li>Remote：远程仓库<a id=\"more\"></a>\n<h3 id=\"一、新建代码库\"><a href=\"#一、新建代码库\" class=\"headerlink\" title=\"一、新建代码库\"></a>一、新建代码库</h3></li>\n</ul>\n<h6 id=\"在当前目录新建一个Git代码库\"><a href=\"#在当前目录新建一个Git代码库\" class=\"headerlink\" title=\"在当前目录新建一个Git代码库\"></a>在当前目录新建一个Git代码库</h6><p><code>git init</code></p>\n<h6 id=\"新建一个目录，将其初始化为Git代码库\"><a href=\"#新建一个目录，将其初始化为Git代码库\" class=\"headerlink\" title=\"新建一个目录，将其初始化为Git代码库\"></a>新建一个目录，将其初始化为Git代码库</h6><p><code>git init [project-name]</code></p>\n<h6 id=\"下载一个项目和它的整个代码历史\"><a href=\"#下载一个项目和它的整个代码历史\" class=\"headerlink\" title=\"下载一个项目和它的整个代码历史\"></a>下载一个项目和它的整个代码历史</h6><p><code>git clone [url]</code></p>\n<h3 id=\"二、配置\"><a href=\"#二、配置\" class=\"headerlink\" title=\"二、配置\"></a>二、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<h6 id=\"显示当前的Git配置\"><a href=\"#显示当前的Git配置\" class=\"headerlink\" title=\"显示当前的Git配置\"></a>显示当前的Git配置</h6><p><code>git config --list</code></p>\n<h6 id=\"编辑Git配置文件\"><a href=\"#编辑Git配置文件\" class=\"headerlink\" title=\"编辑Git配置文件\"></a>编辑Git配置文件</h6><p><code>git config -e [--global]</code></p>\n<h6 id=\"设置提交代码时的用户信息\"><a href=\"#设置提交代码时的用户信息\" class=\"headerlink\" title=\"设置提交代码时的用户信息\"></a>设置提交代码时的用户信息</h6><p><code>git config [--global] user.name &quot;[name]&quot;</code><br><code>git config [--global] user.email &quot;[email address]&quot;</code></p>\n<h3 id=\"三、增加-删除文件\"><a href=\"#三、增加-删除文件\" class=\"headerlink\" title=\"三、增加/删除文件\"></a>三、增加/删除文件</h3><h6 id=\"添加指定文件到暂存区\"><a href=\"#添加指定文件到暂存区\" class=\"headerlink\" title=\"添加指定文件到暂存区\"></a>添加指定文件到暂存区</h6><p><code>git add [file1] [file2] ...</code></p>\n<h6 id=\"添加指定目录到暂存区，包括子目录\"><a href=\"#添加指定目录到暂存区，包括子目录\" class=\"headerlink\" title=\"添加指定目录到暂存区，包括子目录\"></a>添加指定目录到暂存区，包括子目录</h6><p><code>git add [dir]</code></p>\n<h6 id=\"添加当前目录的所有文件到暂存区\"><a href=\"#添加当前目录的所有文件到暂存区\" class=\"headerlink\" title=\"添加当前目录的所有文件到暂存区\"></a>添加当前目录的所有文件到暂存区</h6><p><code>git add .</code></p>\n<h6 id=\"添加每个变化前，都会要求确认\"><a href=\"#添加每个变化前，都会要求确认\" class=\"headerlink\" title=\"添加每个变化前，都会要求确认\"></a>添加每个变化前，都会要求确认</h6><h6 id=\"对于同一个文件的多处变化，可以实现分次提交\"><a href=\"#对于同一个文件的多处变化，可以实现分次提交\" class=\"headerlink\" title=\"对于同一个文件的多处变化，可以实现分次提交\"></a>对于同一个文件的多处变化，可以实现分次提交</h6><p><code>git add -p</code></p>\n<h6 id=\"删除工作区文件，并且将这次删除放入暂存区\"><a href=\"#删除工作区文件，并且将这次删除放入暂存区\" class=\"headerlink\" title=\"删除工作区文件，并且将这次删除放入暂存区\"></a>删除工作区文件，并且将这次删除放入暂存区</h6><p><code>git rm [file1] [file2] ...</code></p>\n<h6 id=\"停止追踪指定文件，但该文件会保留在工作区\"><a href=\"#停止追踪指定文件，但该文件会保留在工作区\" class=\"headerlink\" title=\"停止追踪指定文件，但该文件会保留在工作区\"></a>停止追踪指定文件，但该文件会保留在工作区</h6><p><code>git rm --cached [file]</code></p>\n<h6 id=\"改名文件，并且将这个改名放入暂存区\"><a href=\"#改名文件，并且将这个改名放入暂存区\" class=\"headerlink\" title=\"改名文件，并且将这个改名放入暂存区\"></a>改名文件，并且将这个改名放入暂存区</h6><p><code>git mv [file-original] [file-renamed]</code></p>\n<h3 id=\"四、代码提交\"><a href=\"#四、代码提交\" class=\"headerlink\" title=\"四、代码提交\"></a>四、代码提交</h3><h6 id=\"提交暂存区到仓库区\"><a href=\"#提交暂存区到仓库区\" class=\"headerlink\" title=\"提交暂存区到仓库区\"></a>提交暂存区到仓库区</h6><p><code>git commit -m [message]</code></p>\n<h6 id=\"提交暂存区的指定文件到仓库区\"><a href=\"#提交暂存区的指定文件到仓库区\" class=\"headerlink\" title=\"提交暂存区的指定文件到仓库区\"></a>提交暂存区的指定文件到仓库区</h6><p><code>git commit [file1] [file2] ... -m [message]</code></p>\n<h6 id=\"提交工作区自上次commit之后的变化，直接到仓库区\"><a href=\"#提交工作区自上次commit之后的变化，直接到仓库区\" class=\"headerlink\" title=\"提交工作区自上次commit之后的变化，直接到仓库区\"></a>提交工作区自上次commit之后的变化，直接到仓库区</h6><p><code>git commit -a</code></p>\n<h6 id=\"提交时显示所有diff信息\"><a href=\"#提交时显示所有diff信息\" class=\"headerlink\" title=\"提交时显示所有diff信息\"></a>提交时显示所有diff信息</h6><p><code>git commit -v</code></p>\n<h6 id=\"使用一次新的commit，替代上一次提交\"><a href=\"#使用一次新的commit，替代上一次提交\" class=\"headerlink\" title=\"使用一次新的commit，替代上一次提交\"></a>使用一次新的commit，替代上一次提交</h6><h6 id=\"如果代码没有任何新变化，则用来改写上一次commit的提交信息\"><a href=\"#如果代码没有任何新变化，则用来改写上一次commit的提交信息\" class=\"headerlink\" title=\"如果代码没有任何新变化，则用来改写上一次commit的提交信息\"></a>如果代码没有任何新变化，则用来改写上一次commit的提交信息</h6><p><code>git commit --amend -m [message]</code></p>\n<h6 id=\"重做上一次commit，并包括指定文件的新变化\"><a href=\"#重做上一次commit，并包括指定文件的新变化\" class=\"headerlink\" title=\"重做上一次commit，并包括指定文件的新变化\"></a>重做上一次commit，并包括指定文件的新变化</h6><p><code>git commit --amend [file1] [file2] ...</code></p>\n<h3 id=\"五、分支\"><a href=\"#五、分支\" class=\"headerlink\" title=\"五、分支\"></a>五、分支</h3><h6 id=\"列出所有本地分支\"><a href=\"#列出所有本地分支\" class=\"headerlink\" title=\"列出所有本地分支\"></a>列出所有本地分支</h6><p><code>git branch</code></p>\n<h6 id=\"列出所有远程分支\"><a href=\"#列出所有远程分支\" class=\"headerlink\" title=\"列出所有远程分支\"></a>列出所有远程分支</h6><p><code>git branch -r</code></p>\n<h6 id=\"列出所有本地分支和远程分支\"><a href=\"#列出所有本地分支和远程分支\" class=\"headerlink\" title=\"列出所有本地分支和远程分支\"></a>列出所有本地分支和远程分支</h6><p><code>git branch -a</code></p>\n<h6 id=\"新建一个分支，但依然停留在当前分支\"><a href=\"#新建一个分支，但依然停留在当前分支\" class=\"headerlink\" title=\"新建一个分支，但依然停留在当前分支\"></a>新建一个分支，但依然停留在当前分支</h6><p><code>git branch [branch-name]</code></p>\n<h6 id=\"新建一个分支，并切换到该分支\"><a href=\"#新建一个分支，并切换到该分支\" class=\"headerlink\" title=\"新建一个分支，并切换到该分支\"></a>新建一个分支，并切换到该分支</h6><p><code>git checkout -b [branch]</code></p>\n<h6 id=\"新建一个分支，指向指定commit\"><a href=\"#新建一个分支，指向指定commit\" class=\"headerlink\" title=\"新建一个分支，指向指定commit\"></a>新建一个分支，指向指定commit</h6><p><code>git branch [branch] [commit]</code></p>\n<h6 id=\"新建一个分支，与指定的远程分支建立追踪关系\"><a href=\"#新建一个分支，与指定的远程分支建立追踪关系\" class=\"headerlink\" title=\"新建一个分支，与指定的远程分支建立追踪关系\"></a>新建一个分支，与指定的远程分支建立追踪关系</h6><p><code>git branch --track [branch] [remote-branch]</code></p>\n<h6 id=\"新建一个分支，并拉取远程分支合并进来\"><a href=\"#新建一个分支，并拉取远程分支合并进来\" class=\"headerlink\" title=\"新建一个分支，并拉取远程分支合并进来\"></a>新建一个分支，并拉取远程分支合并进来</h6><p><code>git checkout -b 本地分支名 origin/远程分支名</code></p>\n<h6 id=\"切换到指定分支，并更新工作区\"><a href=\"#切换到指定分支，并更新工作区\" class=\"headerlink\" title=\"切换到指定分支，并更新工作区\"></a>切换到指定分支，并更新工作区</h6><p><code>git checkout [branch-name]</code></p>\n<h6 id=\"切换到上一个分支\"><a href=\"#切换到上一个分支\" class=\"headerlink\" title=\"切换到上一个分支\"></a>切换到上一个分支</h6><p><code>git checkout -</code></p>\n<h6 id=\"建立追踪关系，在现有分支与指定的远程分支之间\"><a href=\"#建立追踪关系，在现有分支与指定的远程分支之间\" class=\"headerlink\" title=\"建立追踪关系，在现有分支与指定的远程分支之间\"></a>建立追踪关系，在现有分支与指定的远程分支之间</h6><p><code>git branch --set-upstream [branch] [remote-branch]</code></p>\n<h6 id=\"合并指定分支到当前分支\"><a href=\"#合并指定分支到当前分支\" class=\"headerlink\" title=\"合并指定分支到当前分支\"></a>合并指定分支到当前分支</h6><p><code>git merge [branch]</code></p>\n<h6 id=\"选择一个commit，合并进当前分支\"><a href=\"#选择一个commit，合并进当前分支\" class=\"headerlink\" title=\"选择一个commit，合并进当前分支\"></a>选择一个commit，合并进当前分支</h6><p><code>git cherry-pick [commit]</code></p>\n<h6 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h6><p><code>git branch -d [branch-name]</code></p>\n<h6 id=\"删除远程分支\"><a href=\"#删除远程分支\" class=\"headerlink\" title=\"删除远程分支\"></a>删除远程分支</h6><p><code>git push origin --delete [branch-name]</code><br><code>git branch -dr [remote/branch]</code></p>\n<h3 id=\"六、标签\"><a href=\"#六、标签\" class=\"headerlink\" title=\"六、标签\"></a>六、标签</h3><h6 id=\"列出所有tag\"><a href=\"#列出所有tag\" class=\"headerlink\" title=\"列出所有tag\"></a>列出所有tag</h6><p><code>git tag</code></p>\n<h6 id=\"新建一个tag在当前commit\"><a href=\"#新建一个tag在当前commit\" class=\"headerlink\" title=\"新建一个tag在当前commit\"></a>新建一个tag在当前commit</h6><p><code>git tag [tag]</code></p>\n<h6 id=\"新建一个tag在指定commit\"><a href=\"#新建一个tag在指定commit\" class=\"headerlink\" title=\"新建一个tag在指定commit\"></a>新建一个tag在指定commit</h6><p><code>git tag [tag] [commit]</code></p>\n<h6 id=\"删除本地tag\"><a href=\"#删除本地tag\" class=\"headerlink\" title=\"删除本地tag\"></a>删除本地tag</h6><p><code>git tag -d [tag]</code></p>\n<h6 id=\"删除远程tag\"><a href=\"#删除远程tag\" class=\"headerlink\" title=\"删除远程tag\"></a>删除远程tag</h6><p><code>git push origin :refs/tags/[tagName]</code></p>\n<h6 id=\"查看tag信息\"><a href=\"#查看tag信息\" class=\"headerlink\" title=\"查看tag信息\"></a>查看tag信息</h6><p><code>git show [tag]</code></p>\n<h6 id=\"提交指定tag\"><a href=\"#提交指定tag\" class=\"headerlink\" title=\"提交指定tag\"></a>提交指定tag</h6><p><code>git push [remote] [tag]</code></p>\n<h6 id=\"提交所有tag\"><a href=\"#提交所有tag\" class=\"headerlink\" title=\"提交所有tag\"></a>提交所有tag</h6><p><code>git push [remote] --tags</code></p>\n<h6 id=\"新建一个分支，指向某个tag\"><a href=\"#新建一个分支，指向某个tag\" class=\"headerlink\" title=\"新建一个分支，指向某个tag\"></a>新建一个分支，指向某个tag</h6><p><code>git checkout -b [branch] [tag]</code></p>\n<h3 id=\"七、查看信息\"><a href=\"#七、查看信息\" class=\"headerlink\" title=\"七、查看信息\"></a>七、查看信息</h3><h6 id=\"显示有变更的文件\"><a href=\"#显示有变更的文件\" class=\"headerlink\" title=\"显示有变更的文件\"></a>显示有变更的文件</h6><p><code>git status</code></p>\n<h6 id=\"显示当前分支的版本历史\"><a href=\"#显示当前分支的版本历史\" class=\"headerlink\" title=\"显示当前分支的版本历史\"></a>显示当前分支的版本历史</h6><p><code>git log</code></p>\n<h6 id=\"显示commit历史，以及每次commit发生变更的文件\"><a href=\"#显示commit历史，以及每次commit发生变更的文件\" class=\"headerlink\" title=\"显示commit历史，以及每次commit发生变更的文件\"></a>显示commit历史，以及每次commit发生变更的文件</h6><p><code>git log --stat</code></p>\n<h6 id=\"以分支图的形式显示commit历史\"><a href=\"#以分支图的形式显示commit历史\" class=\"headerlink\" title=\"以分支图的形式显示commit历史\"></a>以分支图的形式显示commit历史</h6><p><code>git log --graph</code></p>\n<h6 id=\"搜索提交历史，根据关键词\"><a href=\"#搜索提交历史，根据关键词\" class=\"headerlink\" title=\"搜索提交历史，根据关键词\"></a>搜索提交历史，根据关键词</h6><p><code>git log -S [keyword]</code></p>\n<h6 id=\"显示某个commit之后的所有变动，每个commit占据一行\"><a href=\"#显示某个commit之后的所有变动，每个commit占据一行\" class=\"headerlink\" title=\"显示某个commit之后的所有变动，每个commit占据一行\"></a>显示某个commit之后的所有变动，每个commit占据一行</h6><p><code>git log [tag] HEAD --pretty=format:%s</code></p>\n<h6 id=\"显示某个commit之后的所有变动，其-quot-提交说明-quot-必须符合搜索条件\"><a href=\"#显示某个commit之后的所有变动，其-quot-提交说明-quot-必须符合搜索条件\" class=\"headerlink\" title=\"显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\"></a>显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</h6><p><code>git log [tag] HEAD --grep feature</code></p>\n<h6 id=\"显示某个文件的版本历史，包括文件改名\"><a href=\"#显示某个文件的版本历史，包括文件改名\" class=\"headerlink\" title=\"显示某个文件的版本历史，包括文件改名\"></a>显示某个文件的版本历史，包括文件改名</h6><p><code>git log --follow [file]</code><br><code>git whatchanged [file]</code></p>\n<h6 id=\"显示指定文件相关的每一次diff\"><a href=\"#显示指定文件相关的每一次diff\" class=\"headerlink\" title=\"显示指定文件相关的每一次diff\"></a>显示指定文件相关的每一次diff</h6><p><code>git log -p [file]</code></p>\n<h6 id=\"显示过去5次提交\"><a href=\"#显示过去5次提交\" class=\"headerlink\" title=\"显示过去5次提交\"></a>显示过去5次提交</h6><p><code>git log -5 --pretty --oneline</code></p>\n<h6 id=\"显示所有提交过的用户，按提交次数排序\"><a href=\"#显示所有提交过的用户，按提交次数排序\" class=\"headerlink\" title=\"显示所有提交过的用户，按提交次数排序\"></a>显示所有提交过的用户，按提交次数排序</h6><p><code>git shortlog -sn</code></p>\n<h6 id=\"显示指定文件是什么人在什么时间修改过\"><a href=\"#显示指定文件是什么人在什么时间修改过\" class=\"headerlink\" title=\"显示指定文件是什么人在什么时间修改过\"></a>显示指定文件是什么人在什么时间修改过</h6><p><code>git blame [file]</code></p>\n<h6 id=\"显示暂存区和工作区的差异\"><a href=\"#显示暂存区和工作区的差异\" class=\"headerlink\" title=\"显示暂存区和工作区的差异\"></a>显示暂存区和工作区的差异</h6><p><code>git diff</code></p>\n<h6 id=\"显示暂存区和上一个commit的差异\"><a href=\"#显示暂存区和上一个commit的差异\" class=\"headerlink\" title=\"显示暂存区和上一个commit的差异\"></a>显示暂存区和上一个commit的差异</h6><p><code>git diff --cached [file]</code></p>\n<h6 id=\"显示工作区与当前分支最新commit之间的差异\"><a href=\"#显示工作区与当前分支最新commit之间的差异\" class=\"headerlink\" title=\"显示工作区与当前分支最新commit之间的差异\"></a>显示工作区与当前分支最新commit之间的差异</h6><p><code>git diff HEAD</code></p>\n<h6 id=\"显示两次提交之间的差异\"><a href=\"#显示两次提交之间的差异\" class=\"headerlink\" title=\"显示两次提交之间的差异\"></a>显示两次提交之间的差异</h6><p><code>git diff [first-branch]...[second-branch]</code></p>\n<h6 id=\"显示今天你写了多少行代码\"><a href=\"#显示今天你写了多少行代码\" class=\"headerlink\" title=\"显示今天你写了多少行代码\"></a>显示今天你写了多少行代码</h6><p><code>git diff --shortstat &quot;@{0 day ago}&quot;</code></p>\n<h6 id=\"显示某次提交的元数据和内容变化\"><a href=\"#显示某次提交的元数据和内容变化\" class=\"headerlink\" title=\"显示某次提交的元数据和内容变化\"></a>显示某次提交的元数据和内容变化</h6><p><code>git show [commit]</code></p>\n<h6 id=\"显示某次提交发生变化的文件\"><a href=\"#显示某次提交发生变化的文件\" class=\"headerlink\" title=\"显示某次提交发生变化的文件\"></a>显示某次提交发生变化的文件</h6><p><code>git show --name-only [commit]</code></p>\n<h6 id=\"显示某次提交时，某个文件的内容\"><a href=\"#显示某次提交时，某个文件的内容\" class=\"headerlink\" title=\"显示某次提交时，某个文件的内容\"></a>显示某次提交时，某个文件的内容</h6><p><code>git show [commit]:[filename]</code></p>\n<h6 id=\"显示当前分支的最近几次提交\"><a href=\"#显示当前分支的最近几次提交\" class=\"headerlink\" title=\"显示当前分支的最近几次提交\"></a>显示当前分支的最近几次提交</h6><p><code>git reflog</code></p>\n<h3 id=\"八、远程同步\"><a href=\"#八、远程同步\" class=\"headerlink\" title=\"八、远程同步\"></a>八、远程同步</h3><h6 id=\"下载远程仓库的所有变动\"><a href=\"#下载远程仓库的所有变动\" class=\"headerlink\" title=\"下载远程仓库的所有变动\"></a>下载远程仓库的所有变动</h6><p><code>git fetch [remote]</code></p>\n<h6 id=\"显示所有远程仓库\"><a href=\"#显示所有远程仓库\" class=\"headerlink\" title=\"显示所有远程仓库\"></a>显示所有远程仓库</h6><p><code>git remote -v</code></p>\n<h6 id=\"显示某个远程仓库的信息\"><a href=\"#显示某个远程仓库的信息\" class=\"headerlink\" title=\"显示某个远程仓库的信息\"></a>显示某个远程仓库的信息</h6><p><code>git remote show [remote]</code></p>\n<h6 id=\"增加一个新的远程仓库，并命名\"><a href=\"#增加一个新的远程仓库，并命名\" class=\"headerlink\" title=\"增加一个新的远程仓库，并命名\"></a>增加一个新的远程仓库，并命名</h6><p><code>git remote add [shortname] [url]</code></p>\n<h6 id=\"取回远程仓库的变化，并与本地分支合并\"><a href=\"#取回远程仓库的变化，并与本地分支合并\" class=\"headerlink\" title=\"取回远程仓库的变化，并与本地分支合并\"></a>取回远程仓库的变化，并与本地分支合并</h6><p><code>git pull [remote] [branch]</code></p>\n<h6 id=\"上传本地指定分支到远程仓库\"><a href=\"#上传本地指定分支到远程仓库\" class=\"headerlink\" title=\"上传本地指定分支到远程仓库\"></a>上传本地指定分支到远程仓库</h6><p><code>git push [remote] [branch]</code></p>\n<h6 id=\"强行推送当前分支到远程仓库，即使有冲突\"><a href=\"#强行推送当前分支到远程仓库，即使有冲突\" class=\"headerlink\" title=\"强行推送当前分支到远程仓库，即使有冲突\"></a>强行推送当前分支到远程仓库，即使有冲突</h6><p><code>git push [remote] --force</code></p>\n<h6 id=\"推送所有分支到远程仓库\"><a href=\"#推送所有分支到远程仓库\" class=\"headerlink\" title=\"推送所有分支到远程仓库\"></a>推送所有分支到远程仓库</h6><p><code>git push [remote] --all</code></p>\n<h3 id=\"九、撤销\"><a href=\"#九、撤销\" class=\"headerlink\" title=\"九、撤销\"></a>九、撤销</h3><h6 id=\"恢复暂存区的指定文件到工作区\"><a href=\"#恢复暂存区的指定文件到工作区\" class=\"headerlink\" title=\"恢复暂存区的指定文件到工作区\"></a>恢复暂存区的指定文件到工作区</h6><p><code>git checkout [file]</code></p>\n<h6 id=\"恢复某个commit的指定文件到暂存区和工作区\"><a href=\"#恢复某个commit的指定文件到暂存区和工作区\" class=\"headerlink\" title=\"恢复某个commit的指定文件到暂存区和工作区\"></a>恢复某个commit的指定文件到暂存区和工作区</h6><p><code>git checkout [commit] [file]</code></p>\n<h6 id=\"恢复暂存区的所有文件到工作区\"><a href=\"#恢复暂存区的所有文件到工作区\" class=\"headerlink\" title=\"恢复暂存区的所有文件到工作区\"></a>恢复暂存区的所有文件到工作区</h6><p><code>git checkout .</code></p>\n<h6 id=\"重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\"><a href=\"#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\" class=\"headerlink\" title=\"重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\"></a>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</h6><p><code>git reset [file]</code></p>\n<h6 id=\"重置暂存区与工作区，与上一次commit保持一致\"><a href=\"#重置暂存区与工作区，与上一次commit保持一致\" class=\"headerlink\" title=\"重置暂存区与工作区，与上一次commit保持一致\"></a>重置暂存区与工作区，与上一次commit保持一致</h6><p><code>git reset --hard</code></p>\n<h6 id=\"重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\"><a href=\"#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\" class=\"headerlink\" title=\"重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\"></a>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</h6><p><code>git reset [commit]</code></p>\n<h6 id=\"重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\"><a href=\"#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\" class=\"headerlink\" title=\"重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\"></a>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</h6><p><code>git reset --hard [commit]</code></p>\n<h6 id=\"重置当前HEAD为指定commit，但保持暂存区和工作区不变\"><a href=\"#重置当前HEAD为指定commit，但保持暂存区和工作区不变\" class=\"headerlink\" title=\"重置当前HEAD为指定commit，但保持暂存区和工作区不变\"></a>重置当前HEAD为指定commit，但保持暂存区和工作区不变</h6><p><code>git reset --keep [commit]</code></p>\n<h6 id=\"新建一个commit，用来撤销指定commit\"><a href=\"#新建一个commit，用来撤销指定commit\" class=\"headerlink\" title=\"新建一个commit，用来撤销指定commit\"></a>新建一个commit，用来撤销指定commit</h6><h6 id=\"后者的所有变化都将被前者抵消，并且应用到当前分支\"><a href=\"#后者的所有变化都将被前者抵消，并且应用到当前分支\" class=\"headerlink\" title=\"后者的所有变化都将被前者抵消，并且应用到当前分支\"></a>后者的所有变化都将被前者抵消，并且应用到当前分支</h6><p><code>git revert [commit]</code></p>\n<h6 id=\"暂时将未提交的变化移除，稍后再移入\"><a href=\"#暂时将未提交的变化移除，稍后再移入\" class=\"headerlink\" title=\"暂时将未提交的变化移除，稍后再移入\"></a>暂时将未提交的变化移除，稍后再移入</h6><p><code>git stash</code><br><code>git stash pop</code></p>\n<h3 id=\"十、其他\"><a href=\"#十、其他\" class=\"headerlink\" title=\"十、其他\"></a>十、其他</h3><h6 id=\"生成一个可供发布的压缩包\"><a href=\"#生成一个可供发布的压缩包\" class=\"headerlink\" title=\"生成一个可供发布的压缩包\"></a>生成一个可供发布的压缩包</h6><p><code>git archive</code></p>\n","tags":["note","git","handbook"]},{"title":"git用途讲解","url":"/2019/04/04/git/note-git-operate/","content":"<p>Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。本文介绍git在版本管理，标签管理，分支管理等方面的使用方法和最佳实践。<br><a id=\"more\"></a></p>\n<h2 id=\"git的优势\"><a href=\"#git的优势\" class=\"headerlink\" title=\"git的优势\"></a>git的优势</h2><p>Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称&quot;快照&quot;）的指针，因此非常快捷易用。<br>快捷带来的问题就是如果稍不注意分支就会太多，造成不方便管理。因此分支管理变的尤为重要。Vincent Driessen提出了一个分支管理的策略，用来给大家学习。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。</p>\n<h2 id=\"git分支管理\"><a href=\"#git分支管理\" class=\"headerlink\" title=\"git分支管理\"></a>git分支管理</h2><p><img data-src=\"/images/note-git-operate/1.jpg\" alt=\"\"></p>\n<h3 id=\"主分支Master\"><a href=\"#主分支Master\" class=\"headerlink\" title=\"主分支Master\"></a>主分支Master</h3><p>首先，中央仓库应该有一个、且仅有一个主分支。所有提供到生产环境的正式版本。</p>\n<p>Master 是Git默认的主分支。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。(master分支代码最完整，最干净，用于生产环境)</p>\n<h3 id=\"开发分支Develop\"><a href=\"#开发分支Develop\" class=\"headerlink\" title=\"开发分支Develop\"></a>开发分支Develop</h3><p>主分支只用来发布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支叫做Develop。</p>\n<p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行&quot;合并&quot;（merge）。<br>Git创建Develop分支并切换为当前分支的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout -b develop</span><br></pre></td></tr></table></figure>\n<p>将Develop分支发布到Master分支的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout master       # 切换到Master分支</span><br><span class=\"line\">git merge --no-ff develop # 对Develop分支进行合并</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Git执行&quot;快进式合并&quot;（fast-farward merge），会直接将Master分支指向Develop分支。</p>\n<p>使用--no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。</p>\n<h3 id=\"临时分支-辅助分支\"><a href=\"#临时分支-辅助分支\" class=\"headerlink\" title=\"临时分支(辅助分支)\"></a>临时分支(辅助分支)</h3><p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。</p>\n<p>但是，除了常设分支以外，还有一些辅助开发分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>\n<ul>\n<li>功能（feature）分支</li>\n<li>预发布（release）分支</li>\n<li>修补bug（hotfix）分支</li>\n</ul>\n<p>这三种分支都属于临时性需要，使用完以后，应该删除(用完即焚)，使得代码库的常设分支始终只有Master和Develop。</p>\n<h4 id=\"功能分支\"><a href=\"#功能分支\" class=\"headerlink\" title=\"功能分支\"></a>功能分支</h4><p>feature是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop,并且每个功能都有一个对应的功能分支</p>\n<p>功能分支的名字，可以采用feature_xx的形式命名。如：我们要开发一个oss文件上传功能或者地图的功能，就可以使用到功能分支！如:feature_ossfileupload</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout develop          # 切换到develp分支</span><br><span class=\"line\">git checkout -b feature_x     # 从develp分支切出分支feature_x</span><br><span class=\"line\">git checkout develop          # 从当前分支切换到develop分支</span><br><span class=\"line\">git merge --no-ff feature_xx  # 合并feature_xx</span><br><span class=\"line\">git branch -d feature_xx      # 删除feature_x分支</span><br></pre></td></tr></table></figure>\n<h4 id=\"发布分支\"><a href=\"#发布分支\" class=\"headerlink\" title=\"发布分支\"></a>发布分支</h4><p>release是发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们要对当前完成的功能进行测试。</p>\n<p>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，采用release_xx的命名形式</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout develop          # 切换到develp分支</span><br><span class=\"line\">git checkout -b release_1.2.1 # 从develp分支切出分支release_xx</span><br><span class=\"line\">git checkout master           # 确认没有问题后，合并到master分支</span><br><span class=\"line\">git merge --no-ff release_1.2.1</span><br><span class=\"line\">git tag v1.2.1                # 对合并生成的新节点，做一个标签</span><br><span class=\"line\">git checkout develop          # 再合并到develop分支并删除预发布分支</span><br><span class=\"line\">git merge --no-ff release_1.2.1</span><br><span class=\"line\">git branch -d release_1.2.1</span><br></pre></td></tr></table></figure>\n<h4 id=\"hotfix分支\"><a href=\"#hotfix分支\" class=\"headerlink\" title=\"hotfix分支\"></a>hotfix分支</h4><p>修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。</p>\n<p>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug_xx的形式。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout master           # 切换到 master 分支</span><br><span class=\"line\">git checkout -b hotfix_0.1    # 创建bug分支</span><br><span class=\"line\">git checkout master           # 修补结束后，合并到master分支</span><br><span class=\"line\">git merge --no-ff hotfix_0.1</span><br><span class=\"line\">git tag v0.1.1</span><br><span class=\"line\">git checkout develop          # 合并到develop分支然后删除bug分支</span><br><span class=\"line\">git merge --no-ff hotfix_0.1</span><br><span class=\"line\">git branch -d hotfix_0.1</span><br></pre></td></tr></table></figure>\n<h2 id=\"git版本管理\"><a href=\"#git版本管理\" class=\"headerlink\" title=\"git版本管理\"></a>git版本管理</h2><ul>\n<li>每个仓库有独立的版本号，版本号的格式为：{a}.{b}.{c}</li>\n<li>每个仓库首次上线的版本号为：1.0.0</li>\n<li>每个hotfix分支创建时，第三位版本号增加1，合并后的master分支被标记为此版本号</li>\n<li>每个release分支健时，第二位版本号增加1，合并后的master分支被标记为此版本号</li>\n<li>当某个release的功能比较大的情况下，第一位版本号增加1，后面两位重置为0</li>\n</ul>\n<h2 id=\"git提交规范\"><a href=\"#git提交规范\" class=\"headerlink\" title=\"git提交规范\"></a>git提交规范</h2><p>如果 commit 信息都按照一定的模式进行提交，那么我们就会很容易找到自己想要的信息，模板参考如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;-[&lt;scope&gt;]-[&lt;subject&gt;]</span><br></pre></td></tr></table></figure>\n<p>commit 信息包括三个字段: type (必需)， scope(可选) 和 subject(必需)。</p>\n<ol>\n<li>type。type 是用于说明该 commit 的类型的，一般我们 type 的类型如下：<ul>\n<li>feature: 新功能(feature)</li>\n<li>fix: 修复 bug</li>\n<li>docs: 文档(documents)</li>\n<li>style: 代码格式(不影响代码运行的格式变动，注意不是指 CSS 的修改)</li>\n<li>refactor: 重构(既不是新增功能，也不是修改 bug 的代码变动)</li>\n<li>test: 提交测试代码(单元测试，集成测试等)</li>\n<li>chore: 构建或辅助工具的变动</li>\n<li>misc: 一些未归类或不知道将它归类到什么方面的提交</li>\n</ul>\n</li>\n<li>scope。scope 说明 commit 影响的范围，比如数据层，控制层，视图层等等，这个需要视具体场景与项目的不同而灵活变动</li>\n<li>subject。subject 是对于该 commit 目的的简短描述<ul>\n<li>使用第一人称现在时的动词开头，比如 modify 而不是 modified 或 modifies</li>\n<li>首字母小写，并且结尾不加句号</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>参考:<br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YxLyVFOCVCNSVCNyVFNiVBRCVBNQ==\">官方手册<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzcxNGQxOGYyNjVkYTJkOTgwOTA1MDM=\">图解git原理与日常实用指南<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNTczMDY1OA==\">git 分支管理<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hYjQ5MzQ5NGVmMGI=\">git分支管理方法<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTNiMTRmYzZmYjlhMDQ1MTQ2NDMzNzU=\">熟练使用 git 分支管理<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n","tags":["git"]},{"title":"JSON Web Token 入门教程","url":"/2018/08/16/js/note-json-web-token-introduce/","content":"<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。<br><a id=\"more\"></a></p>\n<h3 id=\"一、跨域认证的问题\"><a href=\"#一、跨域认证的问题\" class=\"headerlink\" title=\"一、跨域认证的问题\"></a>一、跨域认证的问题</h3><p>互联网服务离不开用户认证。一般流程是下面这样。</p>\n<p>1、用户向服务器发送用户名和密码。</p>\n<p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p>\n<p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p>\n<p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p>\n<p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p>\n<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>\n<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>\n<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>\n<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>\n<h3 id=\"二、JWT-的原理\"><a href=\"#二、JWT-的原理\" class=\"headerlink\" title=\"二、JWT 的原理\"></a>二、JWT 的原理</h3><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class=\"line\">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class=\"line\">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p>\n<p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>\n<h3 id=\"三、JWT-的数据结构\"><a href=\"#三、JWT-的数据结构\" class=\"headerlink\" title=\"三、JWT 的数据结构\"></a>三、JWT 的数据结构</h3><p>实际的 JWT 大概就像下面这样。</p>\n<p><img data-src=\"https://www.wangbase.com/blogimg/asset/201807/bg2018072304.jpg\" alt=\"\"></p>\n<p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p>\n<p>JWT 的三个部分依次如下。</p>\n<ul>\n<li><p>Header（头部）</p>\n</li>\n<li><p>Payload（负载）</p>\n</li>\n<li><p>Signature（签名）</p>\n</li>\n</ul>\n<p>写成一行，就是下面的样子。</p>\n<p>Header.Payload.Signature<br><img data-src=\"https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg\" alt=\"\"><br>下面依次介绍这三个部分。</p>\n<h4 id=\"3-1-Header\"><a href=\"#3-1-Header\" class=\"headerlink\" title=\"3.1 Header\"></a>3.1 Header</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class=\"line\">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p>\n<p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>\n<h4 id=\"3-2-Payload\"><a href=\"#3-2-Payload\" class=\"headerlink\" title=\"3.2 Payload\"></a>3.2 Payload</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iss (issuer)：签发人</span><br><span class=\"line\">exp (expiration time)：过期时间</span><br><span class=\"line\">sub (subject)：主题</span><br><span class=\"line\">aud (audience)：受众</span><br><span class=\"line\">nbf (Not Before)：生效时间</span><br><span class=\"line\">iat (Issued At)：签发时间</span><br><span class=\"line\">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure><br>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class=\"line\">  &quot;admin&quot;: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>\n<p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>\n<h4 id=\"3-3-Signature\"><a href=\"#3-3-Signature\" class=\"headerlink\" title=\"3.3 Signature\"></a>3.3 Signature</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>\n<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HMACSHA256(</span><br><span class=\"line\">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class=\"line\">  base64UrlEncode(payload),</span><br><span class=\"line\">  secret)</span><br></pre></td></tr></table></figure><br>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（.）分隔，就可以返回给用户。</p>\n<h4 id=\"3-4-Base64URL\"><a href=\"#3-4-Base64URL\" class=\"headerlink\" title=\"3.4 Base64URL\"></a>3.4 Base64URL</h4><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>\n<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p>\n<h3 id=\"四、JWT-的使用方式\"><a href=\"#四、JWT-的使用方式\" class=\"headerlink\" title=\"四、JWT 的使用方式\"></a>四、JWT 的使用方式</h3><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p>\n<p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><br>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>\n<h3 id=\"五、JWT-的几个特点\"><a href=\"#五、JWT-的几个特点\" class=\"headerlink\" title=\"五、JWT 的几个特点\"></a>五、JWT 的几个特点</h3><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>\n<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>\n<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>\n<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>\n<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>\n<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>\n<h3 id=\"六、参考链接\"><a href=\"#六、参考链接\" class=\"headerlink\" title=\"六、参考链接\"></a>六、参考链接</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMDcvanNvbl93ZWJfdG9rZW4tdHV0b3JpYWwuaHRtbA==\">阮一峰的网络日志-JSON Web Token 入门教程<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["javascript"],"tags":["note","javascript","solutions"]},{"title":"高考了，给你份过去500年重要的数学公式压压惊","url":"/2020/07/07/knowledge/important-mathematical-formulas-for-the-past-500-years/","content":"<p>公元前300年，欧几里得在《几何原本》中证明了素数的无穷，这被认为是数学中最具美感的证明之一。到了公元前250年，阿基米德利用圆内的内接96边形来估算圆周率π的值。在书写于中国汉代的《九章算术》中，包含了线性方程、勾股定理等重要内容……</p>\n<p>数学在人类文明进程中所起到的作用似乎已不必多说，从远古时期的农耕、建筑与工程，到现代的计算机、互联网，以及人工智能，无一不得益于数学这一学科的进步。回望两千多年的数学发展史，一场自16世纪就已开始的盛大的数学革命延续至今。在过去的500多年的时间里，数学呈现了爆炸式的增长，留下了许多伟大的数学思想。</p>\n<p>今天，我们将列举一部分自1500年以来，具有重要推动意义的数学公式。<br><a id=\"more\"></a><br><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/1.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/2.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/2-2.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/3.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/3-2.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/3-3.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/3-4.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/3-5.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/3-6.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4-2.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4-3.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4-4.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4-5.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4-6.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/6-7.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4-8.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/4-9.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-2.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-3.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-4.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-5.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-6.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-7.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-8.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-9.jpg\" alt=\"\"></p>\n<p><img data-src=\"/images/important-mathematical-formulas-for-the-past-500-years/5-10.jpg\" alt=\"\"></p>\n<p>到了21世纪，数学的发展速度显著增快。许多现代数学家普遍认为，数学正处于一个黄金时代。在大大小小的众多突破中，其中由俄罗斯数学家格里戈里·佩雷尔曼（Grigori Perelman）于2003年做出的对庞加莱猜想的证明，或许是最值得一提的事件之一。直到现在，庞加莱猜想是唯一一个被解决的千禧年大奖难题。我们不禁期望，在接下来的80年里，还将出现更多属于这一世纪的宝贵的数学思想。</p>\n","categories":["Knowledge"],"tags":["数学"]},{"title":"Linux下常用命令","url":"/2015/05/10/linux/command-in-linux/","content":"<ul>\n<li>查看当前目录及其下各目录占用磁盘空间大小<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">du -h --max-depth&#x3D;1 .&#x2F;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a></li>\n<li>查看当前目录下的文件数量（不包含子目录中的文件）<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls -l|grep &quot;^-&quot;| wc -l</span><br></pre></td></tr></table></figure></li>\n<li>查看当前目录下的文件数量（包含子目录中的文件） 注意：R，代表子目录<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls -lR|grep &quot;^-&quot;| wc -l</span><br></pre></td></tr></table></figure></li>\n<li>查看当前目录下的文件夹目录个数（不包含子目录中的目录），同上述理，如果需要查看子目录的，加上R<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ls -l|grep &quot;^d&quot;| wc -l</span><br></pre></td></tr></table></figure></li>\n<li>查询当前路径下的指定前缀名的目录下的所有文件数量<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;例如：统计所有以“20161124”开头的目录下的全部文件数量</span><br><span class=\"line\">ls -lR 20161124*&#x2F;|grep &quot;^-&quot;| wc -l</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","categories":["Linux"],"tags":["note","linux","command"]},{"title":"Linux下文件压缩命令","url":"/2013/08/09/linux/decompression-mode-in-linux/","content":"<p>This post introduce the decompression mode in Linux.</p>\n<h6 id=\"ENV-Centos-5-Linux\"><a href=\"#ENV-Centos-5-Linux\" class=\"headerlink\" title=\"ENV : Centos 5 Linux\"></a>ENV : Centos 5 Linux</h6><p>The docments like &quot;<em>**</em>.tar.xx&quot; , is packaged by tar commend and compressed by gzip commend.</p>\n<ul>\n<li><p>tar.gz<br>So decompress this docments , the step 1 is decompress by gzip -d commend. And step 2 is unpack by &quot;tar -xvf&quot; commend .</p>\n</li>\n<li><p>tar.xz<br>These docments can also be handled in the above manner.<br>But also, can use the &quot;tar xvJf  <strong><strong>.tar.xz&quot; or &quot;tar -xvf  </strong></strong>.tar.xz&quot; command to decompress files.</p>\n</li>\n</ul>\n","categories":["Linux"],"tags":["note","linux"]},{"title":"linux中的分号&&和&，|和||说明与用法","url":"/2020/08/04/linux/explanation-and-usage-of-semicolons-in-linux/","content":"<p>linux命令中<code>;</code>，<code>&amp;&amp;</code>和<code>&amp;</code>，<code>|</code>和<code>||</code>是很有用的命令符号，用它们可以在一行中执行多条命令或者有条件的执行下一条命令<br><a id=\"more\"></a></p>\n<h2 id=\"“-”分号用法\"><a href=\"#“-”分号用法\" class=\"headerlink\" title=\"“;”分号用法\"></a>“;”分号用法</h2><p>方式：<code>command1 ; command2</code></p>\n<p>用;号隔开每个命令, 每个命令按照从左到右的顺序,顺序执行，彼此之间不关心是否失败，所有命令都会执行。</p>\n<h2 id=\"“-”管道符用法\"><a href=\"#“-”管道符用法\" class=\"headerlink\" title=\"“|”管道符用法\"></a>“|”管道符用法</h2><p>上一条命令的输出，作为下一条命令参数</p>\n<p>方式：<code>command1 | command2</code></p>\n<p>Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推</p>\n<h3 id=\"利用一个管道\"><a href=\"#利用一个管道\" class=\"headerlink\" title=\"利用一个管道\"></a>利用一个管道</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">rpm -qa|grep licq</span><br></pre></td></tr></table></figure>\n<p>这条命令使用一个管道符“|”建立了一个管道。管道将rpm -qa命令的输出（包括系统中所有安装的RPM包）作为grep命令的输入，从而列出带有licq字符的RPM包来。</p>\n<h3 id=\"利用多个管道\"><a href=\"#利用多个管道\" class=\"headerlink\" title=\"利用多个管道\"></a>利用多个管道</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;passwd | grep &#x2F;bin&#x2F;bash | wc -l</span><br></pre></td></tr></table></figure>\n<p>这条命令使用了两个管道，利用第一个管道将cat命令（显示passwd文件的内容）的输出送给grep命令，grep命令找出含有“/bin /bash”的所有行；第二个管道将grep的输出送给wc命令，wc命令统计出输入中的行数。这个命令的功能在于找出系统中有多少个用户使用bash</p>\n<h2 id=\"“-amp-”符号用法\"><a href=\"#“-amp-”符号用法\" class=\"headerlink\" title=\"“&amp;”符号用法\"></a>“&amp;”符号用法</h2><p><code>&amp;</code>放在启动参数后面表示设置此进程为后台进程</p>\n<p>方式：<code>command1 &amp;</code></p>\n<p>默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个<code>&amp;</code>实现这个目的。</p>\n<h2 id=\"“-amp-amp-”符号用法\"><a href=\"#“-amp-amp-”符号用法\" class=\"headerlink\" title=\"“&amp;&amp;”符号用法\"></a>“&amp;&amp;”符号用法</h2><p>shell在执行某个命令的时候，会返回一个返回值，该返回值保存在shell变量 <code>$?</code> 中。当 <code>$? == 0</code> 时，表示执行成功；当 <code>$? == 1</code> 时（我认为是非0的数，返回值在0-255间），表示执行失败。</p>\n<p>有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell提供了 <code>&amp;&amp;</code> 和 <code>||</code> 来实现命令执行控制的功能，shell 将根据 <code>&amp;&amp;</code> 或 <code>||</code> 前面命令的返回值来控制其后面命令的执行。</p>\n<p>语法格式如下：</p>\n<p>command1 &amp;&amp; command2 [&amp;&amp; command3 ...]</p>\n<p>命令之间使用 <code>&amp;&amp;</code> 连接，实现逻辑与的功能。<br>只有在 <code>&amp;&amp;</code> 左边的命令返回真（命令返回值 <code>$? == 0</code>），<code>&amp;&amp;</code> 右边的命令才会被执行。<br>只要有一个命令返回假（命令返回值 <code>$? == 1</code>），后面的命令就不会被执行。</p>\n<h2 id=\"“-”符号用法\"><a href=\"#“-”符号用法\" class=\"headerlink\" title=\"“||”符号用法\"></a>“||”符号用法</h2><p>逻辑或的功能</p>\n<p>语法格式如下：</p>\n<p>command1 || command2 [|| command3 ...]</p>\n<p>命令之间使用 <code>||</code> 连接，实现逻辑或的功能。<br>只有在 || 左边的命令返回假（命令返回值 <code>$? == 1</code>），<code>||</code> 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。<br>只要有一个命令返回真（命令返回值 <code>$? == 0</code>），后面的命令就不会被执行。直到返回真的地方停止执行。</p>\n<p>举例，ping命令判断存活主机<br><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping -c 1 -w 1 192.168.1.1 &amp;&gt; /dev/null &amp;&amp; result=0 ||result=1</span><br><span class=\"line\">if [ \"$result\" == 0 ];then</span><br><span class=\"line\">    echo \"192.168.1.1 is UP!\"    </span><br><span class=\"line\">else</span><br><span class=\"line\">    echo \"192.168.2.1 is DOWN!\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure><br>注意<code>&amp;&gt;</code>要连起来写。</p>\n","categories":["Linux","Shell"],"tags":["Shell"]},{"title":"Linux下有意思的软件","url":"/2015/05/10/linux/some-interesting-software-in-linux/","content":"<ul>\n<li><p>wudao</p>\n<ul>\n<li>Youdao is wudao, A powerful dict software in the commend line.</li>\n<li>linux, python</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0NoZXN0bnV0SGVuZy9XdWRhby1kaWN0\">https://github.com/ChestnutHeng/Wudao-dict<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n</li>\n<li><p>ffcut</p>\n<ul>\n<li>FFCut: Cutting Video with FFMpeg for Human Beings.</li>\n<li>linux, python</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9weXBpLnB5dGhvbi5vcmcvcHlwaS9mZmN1dC8=\">https://pypi.python.org/pypi/ffcut/<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n</li>\n<li><p>wget</p>\n<ul>\n<li>The multifunctional download tools.</li>\n<li>linux</li>\n<li>wget -c -r -np -k -L -p <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5leGFtcGxlLmNvbQ==\">http://www.example.com<i class=\"fa fa-external-link-alt\"></i></span> <code>Download the full website.</code></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3NlcmhpaS1sb25kYXIvb3Blbi1zb3VyY2UtbWFjLW9zLWFwcHMvYmxvYi9tYXN0ZXIvUkVBRE1FLm1k\">Awesome macOS open source applications<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n","categories":["Linux"],"tags":["note","linux","software"]},{"title":"分布式系统架构的冰与火","url":"/2014/09/22/mouse/ice-and-fire-in-distributed-system-architecture/","content":"<p>最近几年，我们一直在谈论各式各样的架构，如高并发架构、异地多活架构、容器化架构、微服务架构、高可用架构、弹性化架构等。还有和这些架构相关的管理型的技术方法，如 DevOps、应用监控、自动化运维、SOA 服务治理、去 IOE 等。面对这么多纷乱的技术，我看到很多团队或是公司都是一个一个地去做这些技术，非常辛苦，也非常累。这样的做法就像我们在撑开一张网里面一个一个的网眼。<br><a id=\"more\"></a><br>其实，只要我们能够找到这张网的“纲”，我们就能比较方便和自如地打开整张网了。那么，这张“分布式大网”的总线——“纲”在哪里呢？我希望通过这一系列文章可以让你找到这个“纲”，从而能让你更好更有效率地做好架构和工程。</p>\n<h3 id=\"分布式系统架构的冰与火\"><a href=\"#分布式系统架构的冰与火\" class=\"headerlink\" title=\"分布式系统架构的冰与火\"></a>分布式系统架构的冰与火</h3><p>首先，我们需要阐述一下为什么需要分布式系统，而不是传统的单体架构。也许这对你来说已经不是什么问题了，但是请允许我在这里重新说明一下。使用分布式系统主要有两方面原因。</p>\n<p>增大系统容量。我们的业务量越来越大，而要能应对越来越大的业务量，一台机器的性能已经无法满足了，我们需要多台机器才能应对大规模的应用场景。所以，我们需要垂直或是水平拆分业务系统，让其变成一个分布式的架构。</p>\n<p>加强系统可用。我们的业务越来越关键，需要提高整个系统架构的可用性，这就意味着架构中不能存在单点故障。这样，整个系统不会因为一台机器出故障而导致整体不可用。所以，需要通过分布式架构来冗余系统以消除单点故障，从而提高系统的可用性。</p>\n<p>当然，分布式系统还有一些优势，比如：</p>\n<ul>\n<li>因为模块化，所以系统模块重用度更高；</li>\n<li>因为软件服务模块被拆分，开发和发布速度可以并行而变得更快；</li>\n<li>系统扩展性更高；</li>\n<li>团队协作流程也会得到改善；</li>\n<li>……</li>\n</ul>\n<p>不过，这个世界上不存在完美的技术方案，采用任何技术方案都是“按下葫芦浮起瓢”，都是有得有失，都是一种 trade-off。也就是说，分布式系统在消除上述问题的同时，也给我们带来了其他的问题。因此，我们需要清楚地知道分布式系统所带来的问题。</p>\n<ul>\n<li>架构设计变得复杂（尤其是其中的分布式事务）。</li>\n<li>部署单个服务会比较快，但是如果一次部署需要多个服务，部署会变得复杂。</li>\n<li>系统的吞吐量会变大，但是响应时间会变长。</li>\n<li>运维复杂度会因为服务变多而变得很复杂。</li>\n<li>架构复杂导致学习曲线变大。</li>\n<li>测试和查错的复杂度增大。</li>\n<li>技术可以很多样，这会带来维护和运维的复杂度。</li>\n<li>管理分布式系统中的服务和调度变得困难和复杂。</li>\n</ul>\n<p>也就是说，分布式系统架构的难点在于系统设计，以及管理和运维。所以，分布式架构解决了“单点”和“性能容量”的问题，但却新增了一堆问题。而对于这些新增的问题，还会衍生出更多的子问题，这就需要我们不断地用各式各样的技术和手段来解决这些问题。</p>\n<p>这就出现了我前面所说的那些架构方式，以及各种相关的管理型的技术方法。这个世界就是这样变得复杂起来的。</p>\n<h3 id=\"分布式系统的发展\"><a href=\"#分布式系统的发展\" class=\"headerlink\" title=\"分布式系统的发展\"></a>分布式系统的发展</h3><p>从 20 世纪 70 年代的模块化编程，80 年代的面向事件设计，90 年代的基于接口 / 构件设计，这个世界很自然地演化出了 SOA——基于服务的架构。SOA 架构是构造分布式计算应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。它采用开放标准与软件资源进行交互，并采用标准的表示方式。</p>\n<p>开发、维护和使用 SOA 要遵循以下几条基本原则。</p>\n<ul>\n<li>可重用，粒度合适，模块化，可组合，构件化以及有互操作性。</li>\n<li>符合开放标准（通用的或行业的）。</li>\n<li>服务的识别和分类，提供和发布，监控和跟踪。</li>\n</ul>\n<p>但 IBM 搞出来的 SOA 非常重，所以对 SOA 的裁剪和优化从来没有停止过。比如，之前的 SOAP、WSDL 和 XML 这样的东西基本上已经被抛弃了，而改成了 RESTful 和 JSON 这样的方式。而 ESB（Enterprise Service Bus，企业服务总线）这样非常重要的东西也被简化成了 Pub/Sub 的消息服务……</p>\n<p>不过，SOA 的思想一直延续着。所以，我们现在也不说 SOA 了，而是说分布式服务架构了。</p>\n<p>我们可以看到，面向服务的架构有以下三个阶段。</p>\n<ul>\n<li><p>20 世纪 90 年代前，是单体架构，软件模块高度耦合。当然，这张图同样也说明了有的 SOA 架构其实和单体架构没什么两样，因为都是高度耦合在一起的。就像图中的齿轮一样，当你调用一个服务时，这个服务会调用另一个服务，然后又调用另外的服务……于是整个系统就转起来了。但是这本质是比较耦合的做法。</p>\n</li>\n<li><p>而 2000 年左右出现了比较松耦合的 SOA 架构，这个架构需要一个标准的协议或是中间件来联动其它相关联的服务（如 ESB）。这样一来，服务间并不直接依赖，而是通过中间件的标准协议或是通讯框架相互依赖。这其实就是 IoC（控制反转）和 DIP（依赖倒置原则）的设计思想在架构中的实践。它们都依赖于一个标准的协议或是一个标准统一的交互方式，而不是直接调用。</p>\n</li>\n<li><p>而 2010 年后，出现了微服务架构，这个架构更为松耦合。每一个微服务都能独立完整地运行（所谓的自包含），后端单体的数据库也被微服务这样的架构分散到不同的服务中。而它和传统 SOA 的差别在于，服务间的整合需要一个服务编排或是服务整合的引擎。就好像交响乐中需要有一个指挥来把所有乐器编排和组织在一起。</p>\n</li>\n</ul>\n<p>一般来说，这个编排和组织引擎可以是工作流引擎，也可以是网关。当然，还需要辅助于像容器化调度这样的技术方式，如 Kubernetes。在 Martin Fowler 的 Microservices 这篇文章中有详细描述。</p>\n<p>微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。所以，需要一套比较好的微服务 PaaS 平台。就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线……还有像 Kubernetes 提供的各式各样的部署和调度方式。</p>\n<p>没有这些 PaaS 层的支撑，微服务也是很难被管理和运维的。好在今天的世界已经有具备了这些方面的基础设施，所以，采用微服务架构，我认为只是一个时间问题了。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>好了，今天的内容就到这里。相信通过今天的学习，你应该已经对为什么需要分布式系统，而不是传统的单体架构，有了清晰的认识。并且对分布式系统的发展历程了然于心。下一篇文章，我将结合亚马逊的分布式架构实践，来谈谈分布式系统架构的技术难点及应对方案。</p>\n","tags":["mouse","architecture"]},{"title":"编程范式游记（10）- 逻辑编程范式","url":"/2016/01/10/mouse/programming-paradigm-travel-10-logical-programming-paradigm/","content":"<p>这篇文章重点介绍 Prolog 语言。Prolog（Programming in Logic 的缩写）是一种逻辑编程语言。它创建在逻辑学的理论基础之上，最初被运用于自然语言等研究领域。现在它已被广泛地应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。<br><a id=\"more\"></a><br>Prolog 语言最早由艾克斯马赛大学（Aix-Marseille University）的 Alain Colmerauer 与 Philippe Roussel 等人于 20 年代 60 年代末研究开发的。1972 年被公认为是 Prolog 语言正式诞生的年份，自 1972 年以后，分支出多种 Prolog 的方言。</p>\n<p>最主要的两种方言为 Edinburgh 和 Aix-Marseille。最早的 Prolog 解释器由 Roussel 建造，而第一个 Prolog 编译器则是 David Warren 编写的。</p>\n<p>Prolog 一直在北美和欧洲被广泛使用。日本政府曾经为了建造智能计算机而用 Prolog 来开发 ICOT 第五代计算机系统。在早期的机器智能研究领域，Prolog 曾经是主要的开发工具。</p>\n<p>20 世纪 80 年代 Borland 开发的 Turbo Prolog，进一步普及了 Prolog 的使用。1995 年确定了 ISO Prolog 标准。</p>\n<p>有别于一般的函数式语言，Prolog 的程序是基于谓词逻辑的理论。最基本的写法是定立对象与对象之间的关系，之后可以用询问目标的方式来查询各种对象之间的关系。系统会自动进行匹配及回溯，找出所询问的答案。</p>\n<p>Prolog 代码中以大写字母开头的元素是变量，字符串、数字或以小写字母开头的元素是常量。下划线（_）被称为匿名变量。</p>\n<h3 id=\"Prolog-的语言特征\"><a href=\"#Prolog-的语言特征\" class=\"headerlink\" title=\"Prolog 的语言特征\"></a>Prolog 的语言特征</h3><p>逻辑编程是靠推理，比如下面的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">program mortal(X) :- philosopher(X).</span><br><span class=\"line\"></span><br><span class=\"line\">philosopher(Socrates).</span><br><span class=\"line\">philosopher(Plato).</span><br><span class=\"line\">philosopher(Aristotle).</span><br><span class=\"line\"></span><br><span class=\"line\">mortal_report:-</span><br><span class=\"line\">write(&#39;Known mortals are:&#39;), nl, mortal(X),</span><br><span class=\"line\">write(X),nl,</span><br><span class=\"line\">fail.</span><br></pre></td></tr></table></figure><br>我们可以看到下面的几个步骤。</p>\n<p>先定义一个规则：哲学家是人类。<br>然后陈述事实：苏格拉底、亚里士多德、柏拉图都是哲学家。<br>然后，我们问，谁是人类？于是就会输出苏格拉底、亚里士多德、柏拉图。<br>下面是逻辑编程范式的几个特征。</p>\n<p>逻辑编程的要点是将正规的逻辑风格带入计算机程序设计之中。<br>逻辑编程建立了描述一个问题里的世界的逻辑模型。<br>逻辑编程的目标是对它的模型建立新的陈述。<br>通过陈述事实——因果关系。<br>程序自动推导出相关的逻辑。<br>经典问题：地图着色问题<br>我们再来看一个经典的四色地图问题。任何一个地图，相同区域不能用相同颜色，只要用四种不同的颜色就够了。</p>\n<p>首先，定义四种颜色。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">color(red).</span><br><span class=\"line\">color(green).</span><br><span class=\"line\">color(blue).</span><br><span class=\"line\">color(yellow).</span><br></pre></td></tr></table></figure><br>然后，定义一个规则：相邻的两个地区不能用相同的颜色。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">neighbor(StateAColor, StateBColor) :- color(StateAColor), color(StateBColor),</span><br><span class=\"line\">    StateAColor \\&#x3D; StateBColor. &#x2F;* \\&#x3D; is the not equal operator *&#x2F;</span><br></pre></td></tr></table></figure><br>最前面的两个条件：color(StateAColor) 和 color(StateBColor) 表明了两个变量 StateAColor 和 StateBColor。然后，第三个条件： StateAColor \\= StateBColor 表示颜色不能相同。</p>\n<p>接下来的事就比较简单了。我们描述事实就好了，描述哪些区域是相邻的事实。</p>\n<p>比如，下面描述了 BW 和 BY 是相邻的。</p>\n<p>germany(BW, BY) :- neighbor(BW, BY).</p>\n<p>下面则描述多个区 BW、 BY、 SL、 RP、 和 ND 的相邻关系：</p>\n<p>germany(BW, BY, SL, RP, HE) :- neighbor(BW, BY), neighbor(BW, RP), neighbor(BW, HE).</p>\n<p>于是，我们就可以描述整个德国地图的相邻关系了。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY) :-</span><br><span class=\"line\">neighbor(SH, NI), neighbor(SH, HH), neighbor(SH, MV),</span><br><span class=\"line\">neighbor(HH, NI),</span><br><span class=\"line\">neighbor(MV, NI), neighbor(MV, BB),</span><br><span class=\"line\">neighbor(NI, HB), neighbor(NI, BB), neighbor(NI, ST), neighbor(NI, TH),</span><br><span class=\"line\">neighbor(NI, HE), neighbor(NI, NW),</span><br><span class=\"line\">neighbor(ST, BB), neighbor(ST, SN), neighbor(ST, TH),</span><br><span class=\"line\">neighbor(BB, BE), neighbor(BB, SN),</span><br><span class=\"line\">neighbor(NW, HE), neighbor(NW, RP),</span><br><span class=\"line\">neighbor(SN, TH), neighbor(SN, BY),</span><br><span class=\"line\">neighbor(RP, SL), neighbor(RP, HE), neighbor(RP, BW),</span><br><span class=\"line\">neighbor(HE, BW), neighbor(HE, TH), neighbor(HE, BY),</span><br><span class=\"line\">neighbor(TH, BY),</span><br><span class=\"line\">neighbor(BW, BY).</span><br></pre></td></tr></table></figure><br>最后，我们使用如下语句，就可以让 Prolog 推导到各个地区的颜色。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">?- germany(SH, MV, HH, HB, NI, ST, BE, BB, SN, NW, HE, TH, RP, SL, BW, BY).</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>Prolog 这种逻辑编程，把业务逻辑或是说算法抽象成只关心规则、事实和问题的推导这样的标准方式，不需要关心程序控制，也不需要关心具体的实现算法。只需要给出可以用于推导的规则和相关的事实，问题就可以被通过逻辑推导来解决掉。是不是很有意思，也很好玩？</p>\n<p>如果有兴趣，你可以学习一下，这里推荐两个学习资源：</p>\n<p>Prolog Tutorial<br>Learn Prolog Now!</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编程范式游记（11）- 程序世界里的编程范式","url":"/2016/01/11/mouse/programming-paradigm-travel-11-programming-paradigm-in-the-program-world/","content":"<p>这个世界到今天有很多很多的编程范式，相当复杂。下面这个图比较好地表现了这些各式各样的编程范式。这个图越往左边就越是“声明式的”，越往右边就越不是“声明式的”（指令式的），我们可以看到，函数式编程、逻辑编程，都在左边，而右边是指令式的，有状态的，有类型的。<br><a id=\"more\"></a><br>上面这个图有点乱，不过总体说来，我们可以简单地把这世界上纷乱的编程范式，分成这几类：声明式、命名式、逻辑的、函数式、面向对象的、面向过程的。</p>\n<p>于是我们归纳一下，就可以得到下面这个简单的图。简单描述一下，</p>\n<p>中间两个声明式编程范式（函数式和逻辑式）偏向于你定义要什么，而不是去怎么做。<br>而两边的命令式编程范式和面向对象编程范式，偏向于怎么做，而不是要做什么。</p>\n<p>我们再归纳一下，基本上来说，就是两大分支，一边是在解决数据和算法，一边是在解决逻辑和控制。</p>\n<p>下面再给一张表格说明一下这世界上四大编程范式的类别，它们的特性和主要的编程语言。</p>\n<p>程序编程范式。一个是左脑，一个右脑。我们程序员基本上是在用左脑，左脑是理性分析，喜欢数据证据，线性思维，陷入细节，具体化的，不抽象。但是实际上玩儿出这些东西的都在右脑，函数式，还有像逻辑式的抽象能力都在右脑。所以我们非线性的想象力都在这边，而标准化教育把我们这边已经全部干掉了，我们只剩左边。我们陷入细节，我一说 Java 是最好的程序设计语言，一堆人就来了，找各种各样的细节问题跟你纠缠。</p>\n<p>离我们最近的是函数式编程，但既然函数式编程这么好，为什么函数式编程火不起来呢？首先，这里有个逻辑上的问题，并不是用的人越多的东西就越好。因为还要看是不是大多数人都能理解的东西。函数式编程或是声明式编程，需要的是用我们的右脑，而指令式的则需要用我们的左脑。</p>\n<p>参看下图：</p>\n<p>我们可以看到，</p>\n<p>人的左脑的特性是：</p>\n<ul>\n<li>理性分析型</li>\n<li>喜欢数据证据</li>\n<li>线性思维</li>\n<li>陷入细节</li>\n<li>具体化的</li>\n</ul>\n<p>人的右脑的特性是：</p>\n<ul>\n<li>直觉型</li>\n<li>想象力</li>\n<li>非线性</li>\n<li>宏观思维</li>\n<li>抽象化的</li>\n</ul>\n<p>人类社会中，绝大多数人都是左脑型的人，而只有少数人是右脑型的人，比如那些哲学家、艺术家，以及能够创造理论知识的人。这些人在这个世界上太少了。</p>\n<p>这是为什么很多人理解和使用声明式的编程范式比较有困难，因为这要用你的右脑，但是我们习惯于用我们的左脑，左脑用多了以后右脑就有点跟不上了。</p>\n<p>说到人类的大脑了，已经到了不是我专长的地方了，这个话题太大了，所以，也是时候结束《编程范式游记》这一系列文章了。希望你能从这一系列文章中有所收获。如果有什么疑问或是我有什么没有讲对的，还希望得到你的批评和指正。先谢谢了。</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"Github Actions 自动部署Hexo","url":"/2019/08/03/note/github-actions-hexo-deploy/","content":"<p>github的actions功能出来了，小试一下自动部署Hexo博客吧<br><a id=\"more\"></a></p>\n<h2 id=\"Hexo的自动部署\"><a href=\"#Hexo的自动部署\" class=\"headerlink\" title=\"Hexo的自动部署\"></a>Hexo的自动部署</h2><p>目前的主流方式：</p>\n<p>Travis CI：travis-ci.org 专门针对开源项目，Github 上所有的公开仓库都能够免费使用；travis-ci.com 针对私有及商业项目，新用户前 100 次构建是免费的，后面就要收费了。现在github私有库已经免费了！！！</p>\n<p>Githooks： 这个如果 vps 本地部署，配合 nginx ，还是很推荐的</p>\n<p>Github Actions： 持续集成，自动执行软件开发工作流程</p>\n<p>因为是deploy方式，所以要安装插件<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br>同时在Hexo项目根目录配置文件_config.yaml中配置<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:Github用户名&#x2F;Github用户名.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><p>私有仓库： blog</p>\n<p>这里是存放 Hexo 博客源码的</p>\n<p>公有仓库： 用户名.github.io</p>\n<p>这里是用来 public 静态页面的</p>\n<p>所以如果你还没有创建 Hexo ，请参考 官方快速开始文档</p>\n<h2 id=\"密钥准备\"><a href=\"#密钥准备\" class=\"headerlink\" title=\"密钥准备\"></a>密钥准备</h2><p>为了方便运行GitHub Actions时登录GitHub账号，我们使用SSH方式登录。就是要把设备的私钥交给GitHub Actions，公钥交给GitHub，需要去Settings里去配置。</p>\n<p>使用ssh-keygen生成一组公私秘钥对</p>\n<p>ssh-keygen -t rsa -C &quot;Github 的邮箱地址&quot;</p>\n<p>如 ssh-keygen -t rsa -C &quot;123123123@gmail.com&quot;</p>\n<p>配置公钥，应该已经配好，不然如何上到的项目资源，配置路径：github网站--&gt;Settings--&gt;SSH and GPG keys</p>\n<p>配置私钥，blog私有仓库的Settings-&gt;Secrets里添加私钥，名称为HEXO_DEPLOY_PRIVATE_KEY</p>\n<p>配置GitHub Actions</p>\n<p>GitHub Actions 有一些自己的术语。</p>\n<ul>\n<li>workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。</li>\n<li>job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。</li>\n<li>step（步骤）：每个 job 由多个 step 构成，一步步完成。</li>\n<li>action （动作）：每个 step 可以依次执行一个或多个命令（action）。</li>\n</ul>\n<p>在blog仓库的Actions选项卡下点击新建workflow，名称默认或者自定义修改，编写如下配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># workflow name</span><br><span class=\"line\">name: Hexo Blog CI</span><br><span class=\"line\"></span><br><span class=\"line\"># master branch on push, auto run</span><br><span class=\"line\">on: </span><br><span class=\"line\">  push:</span><br><span class=\"line\">    branches:</span><br><span class=\"line\">      - master</span><br><span class=\"line\">      </span><br><span class=\"line\">jobs:</span><br><span class=\"line\">  build: </span><br><span class=\"line\">    runs-on: ubuntu-latest </span><br><span class=\"line\">        </span><br><span class=\"line\">    steps:</span><br><span class=\"line\">    # check it to your workflow can access it</span><br><span class=\"line\">    # from: https:&#x2F;&#x2F;github.com&#x2F;actions&#x2F;checkout</span><br><span class=\"line\">    - name: Checkout Repository master branch</span><br><span class=\"line\">      uses: actions&#x2F;checkout@master </span><br><span class=\"line\">      </span><br><span class=\"line\">    # from: https:&#x2F;&#x2F;github.com&#x2F;actions&#x2F;setup-node  </span><br><span class=\"line\">    - name: Setup Node.js 10.x </span><br><span class=\"line\">      uses: actions&#x2F;setup-node@master</span><br><span class=\"line\">      with:</span><br><span class=\"line\">        node-version: &quot;10.x&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    - name: Setup Hexo Dependencies</span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        npm install hexo-cli -g</span><br><span class=\"line\">        npm install</span><br><span class=\"line\">    </span><br><span class=\"line\">    - name: Setup Deploy Private Key</span><br><span class=\"line\">      env:</span><br><span class=\"line\">        HEXO_DEPLOY_PRIVATE_KEY: $&#123;&#123; secrets.HEXO_DEPLOY_PRIVATE_KEY &#125;&#125;</span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        mkdir -p ~&#x2F;.ssh&#x2F;</span><br><span class=\"line\">        echo &quot;$HEXO_DEPLOY_PRIVATE_KEY&quot; &gt; ~&#x2F;.ssh&#x2F;id_rsa </span><br><span class=\"line\">        chmod 600 ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class=\"line\">        ssh-keyscan github.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</span><br><span class=\"line\">        </span><br><span class=\"line\">    - name: Setup Git Infomation</span><br><span class=\"line\">      run: | </span><br><span class=\"line\">        git config --global user.name &#39;Github用户名&#39; </span><br><span class=\"line\">        git config --global user.email &#39;Github注册邮箱&#39;</span><br><span class=\"line\">    - name: Deploy Hexo </span><br><span class=\"line\">      run: |</span><br><span class=\"line\">        hexo clean</span><br><span class=\"line\">        hexo generate </span><br><span class=\"line\">        hexo deploy</span><br></pre></td></tr></table></figure></p>\n","categories":["tools"],"tags":["note","git"]},{"title":"文字编码的那些事","url":"/2016/09/30/note/note-about-character-sets-and-encoding/","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWE5ZDc5MzZmYjlhMDI4ZGM0MGJjMjc=\">漫谈计算机编码<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjA4OWM1YjUxODgyNTM4YzAyZjAzZWI=\">从ASCII到UTF-8——字符集到底是什么？<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YWNlMjdjOTZmYjlhMDI4ZGM0MTYxOTU=\">Unicode中UTF-8与UTF-16编码详解<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTIxMGFhY2YyNjVkYTQzMTUyM2I1OTA=\">人人都是艺术家！谈谈那些奇怪的字符<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YTA2ZDY1NDZmYjlhMDQ1MDc2ZjIzMmE=\">文字编码的那些事<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTljMWM2MWNmMjY1ZGEwNjQzNGI4MDFh\">字符编码的前世今生<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81OWIzYzQ1ZmYyNjVkYTA2NTYwNDM0ODk=\">探索编码的世界<i class=\"fa fa-external-link-alt\"></i></span></p>\n","tags":["note","character","encoding"]},{"title":"用Nodejs开发命令行工具","url":"/2015/09/22/note/note-nodejs-cli/","content":"<p>用Nodejs开发命令行工具<br><a id=\"more\"></a></p>\n<h2 id=\"The-first-step-Hello-World\"><a href=\"#The-first-step-Hello-World\" class=\"headerlink\" title=\"The first step - Hello World\"></a>The first step - Hello World</h2><h3 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"ENV\"></a>ENV</h3><ul>\n<li>nodejs v6.10.1</li>\n<li>npm v3.10.10</li>\n</ul>\n<p>分4步：</p>\n<ol>\n<li>index.js</li>\n<li>package.json</li>\n<li>根目录下执行npm link</li>\n<li>执行命令nhw =&gt; hello world</li>\n</ol>\n<p>touch index.js创建一个index.js文件，内容如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#! &#x2F;usr&#x2F;bin&#x2F;env node</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;hello world&#39;)</span><br></pre></td></tr></table></figure><br>用npm init创建一个package.json文件，之后修改成如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;: &quot;npmhelloworld&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &#123;</span><br><span class=\"line\">        &quot;nhw&quot;: &quot;index.js&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;preferGlobal&quot;: true,</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;description&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;scripts&quot;: &#123;</span><br><span class=\"line\">        &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;author&quot;: &quot;jerryni &lt;jerryni2014@gmail.com&gt;&quot;,</span><br><span class=\"line\">    &quot;license&quot;: &quot;ISC&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内容详解\"><a href=\"#内容详解\" class=\"headerlink\" title=\"内容详解\"></a>内容详解</h3><h4 id=\"index-js\"><a href=\"#index-js\" class=\"headerlink\" title=\"index.js\"></a>index.js</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#! &#x2F;usr&#x2F;bin&#x2F;env node</span><br></pre></td></tr></table></figure>\n<p>这句话是一个shebang line实例, 作用是告诉系统运行这个文件的解释器是node；比如，本来需要这样运行node ./file.js，但是加上了这句后就可以直接./file.js运行了</p>\n<h4 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 模块系统的名字，如require(&#39;npmhelloworld&#39;)</span><br><span class=\"line\">    &quot;name&quot;: &quot;npmhelloworld&quot;,</span><br><span class=\"line\">    &quot;bin&quot;: &#123;</span><br><span class=\"line\">        &quot;nhw&quot;: &quot;index.js&quot; &#x2F;&#x2F; nhw就是命令名 ，index.js就是入口</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 加入 安装的时候, 就会有-g的提示了</span><br><span class=\"line\">    &quot;preferGlobal&quot;: true,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 去掉main: &#39;xxx.js&#39;  是模块系统的程序入口</span><br><span class=\"line\">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;description&quot;: &quot;&quot;,</span><br><span class=\"line\">    &quot;scripts&quot;: &#123;</span><br><span class=\"line\">        &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;author&quot;: &quot;jerryni &lt;jerryni2014@gmail.com&gt;&quot;,</span><br><span class=\"line\">    &quot;license&quot;: &quot;ISC&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"npm-link命令\"><a href=\"#npm-link命令\" class=\"headerlink\" title=\"npm link命令\"></a>npm link命令</h4><p>执行后，控制台里面会有以下输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;nhw -&gt; &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npmhelloworld&#x2F;index.js</span><br><span class=\"line\">&#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;npmhelloworld -&gt; &#x2F;Users&#x2F;nirizhe&#x2F;GitHub&#x2F;npmhelloworld</span><br></pre></td></tr></table></figure><br><strong>解释</strong>：创建了2个软链接分别放到系统环境变量$PATH目录里，nhw命令和npmhellworld模块。npm link在用户使用的场景下是不需要执行的，用户使用npm i -g npmhellworld命令安装即可。</p>\n<h2 id=\"The-second-step\"><a href=\"#The-second-step\" class=\"headerlink\" title=\"The second step\"></a>The second step</h2><p>自制脚手架所需基础node工具包</p>\n<h3 id=\"一、commander\"><a href=\"#一、commander\" class=\"headerlink\" title=\"一、commander\"></a>一、commander</h3><h4 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install commander --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、简单demo\"><a href=\"#2、简单demo\" class=\"headerlink\" title=\"2、简单demo\"></a>2、简单demo</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var program &#x3D; require(&#39;commander&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">program</span><br><span class=\"line\">  .version(&#39;0.1.0&#39;)</span><br><span class=\"line\">  .option(&#39;-p, --peppers&#39;, &#39;Add peppers&#39;)</span><br><span class=\"line\">  .option(&#39;-P, --pineapple&#39;, &#39;Add pineapple&#39;)</span><br><span class=\"line\">  .option(&#39;-b, --bbq-sauce&#39;, &#39;Add bbq sauce&#39;)</span><br><span class=\"line\">  .option(&#39;-c, --cheese [type]&#39;, &#39;Add the specified type of cheese [marble]&#39;, &#39;marble&#39;)</span><br><span class=\"line\">  .parse(process.argv);</span><br><span class=\"line\">&#x2F;&#x2F; 示例 *** -p -P -b -c type  (***表示启动命令)</span><br><span class=\"line\">&#x2F;&#x2F; 或者 *** --peppers --pineapple --bbq-sauce --cheese type  (***表示启动命令)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;you ordered a pizza with:&#39;);</span><br><span class=\"line\">if (program.peppers) console.log(&#39;  - peppers&#39;);</span><br><span class=\"line\">if (program.pineapple) console.log(&#39;  - pineapple&#39;);</span><br><span class=\"line\">if (program.bbqSauce) console.log(&#39;  - bbq&#39;);</span><br><span class=\"line\">console.log(&#39;  - %s cheese&#39;, program.cheese);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">* you ordered a pizza with:</span><br><span class=\"line\">*   - peppers</span><br><span class=\"line\">*   - pineapple</span><br><span class=\"line\">*   - bbq</span><br><span class=\"line\">*   - type cheese</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、demo解释\"><a href=\"#3、demo解释\" class=\"headerlink\" title=\"3、demo解释\"></a>3、demo解释</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var program &#x3D; require(&#39;commander&#39;); &#x2F;&#x2F; 引入commander</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * option（）</span><br><span class=\"line\"> * @param &#123;String&#125; name 表示参数的名称，</span><br><span class=\"line\"> * @param &#123;String&#125; desc 描述参数</span><br><span class=\"line\"> * @param &#123;String&#125; value 参数默认值</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 第一种option表达方式</span><br><span class=\"line\">program</span><br><span class=\"line\">  .option(&#39;-p, --peppers&#39;, &#39;Add peppers&#39;)</span><br><span class=\"line\">  .parse(process.argv);</span><br><span class=\"line\">  if (program.peppers) console.log(program.peppers);</span><br><span class=\"line\">  &#x2F;&#x2F; program.peppers为Boolean值</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 第二种option表达方式</span><br><span class=\"line\">program</span><br><span class=\"line\">  .option(&#39;-p, --peppers [p]&#39;, &#39;Add peppers&#39;, &#39;peppers &#39;)</span><br><span class=\"line\">  .parse(process.argv);</span><br><span class=\"line\">  if (program.peppers) console.log(program.peppers);</span><br><span class=\"line\">  &#x2F;&#x2F; -p参数后面可以输入值,第三个参数可以设定默认值</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 第三种option表达方式</span><br><span class=\"line\">program</span><br><span class=\"line\">  .option(&#39;-p, --peppers [p]&#39;, &#39;Add peppers&#39;, function(val) &#123;</span><br><span class=\"line\">    console.log(val)</span><br><span class=\"line\">    return val</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .parse(process.argv);</span><br><span class=\"line\">  if (program.peppers) console.log(program.peppers);</span><br><span class=\"line\">  &#x2F;&#x2F; 第三个参数可以传入一个带参的函数，参数为program.peppers的值</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、fs相关\"><a href=\"#二、fs相关\" class=\"headerlink\" title=\"二、fs相关\"></a>二、fs相关</h3><h4 id=\"1、readFileSync\"><a href=\"#1、readFileSync\" class=\"headerlink\" title=\"1、readFileSync\"></a>1、readFileSync</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.readFileSync(path[, options])</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>path: string | buffer | url | integer</li>\n<li>options : object | string</li>\n<li>encoding string | null</li>\n<li>flag string 默认为 ‘r’</li>\n<li>fs.readFile() 的同步版本。 返回 path 的内容。</li>\n<li>如果指定了 encoding 选项，则该函数返回一个字符串，否则返回一个 buffer。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&#39;fs&#39;)</span><br><span class=\"line\">var path &#x3D; require(&#39;path&#39;)</span><br><span class=\"line\">console.log(path.join(__dirname, &#39;doc&#x2F;package.json&#39;))</span><br><span class=\"line\"></span><br><span class=\"line\">var file &#x3D; fs.readFileSync(path.join(path.join(__dirname, &#39;doc&#x2F;package.json&#39;)), &#39;utf-8&#39;);</span><br><span class=\"line\">fs.writeFileSync(path.join(__dirname, &#39;package.json&#39;), file, &#123; mode: 0666 &#125;);</span><br><span class=\"line\">console.log(file)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2、writeFileSync\"><a href=\"#2、writeFileSync\" class=\"headerlink\" title=\"2、writeFileSync\"></a>2、writeFileSync</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.writeFileSync(file, data[, options])</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>file： string | Buffer | integer 文件名或文件描述符</li>\n<li>data： string | Buffer | Uint8Array</li>\n<li>options：Object | string</li>\n<li>encoding：string | null 默认 = ‘utf8’</li>\n<li>mode： integer 默认 = 0o666</li>\n<li>flag：string 默认 = ‘w’</li>\n<li>fs.writeFile() 的同步版本。 返回 undefined。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&#39;fs&#39;)</span><br><span class=\"line\">var path &#x3D; require(&#39;path&#39;)</span><br><span class=\"line\">console.log(path.join(__dirname, &#39;doc&#x2F;package.json&#39;))</span><br><span class=\"line\"></span><br><span class=\"line\">var file &#x3D; fs.readFileSync(path.join(path.join(__dirname, &#39;doc&#x2F;package.json&#39;)), &#39;utf-8&#39;);</span><br><span class=\"line\">fs.writeFileSync(path.join(__dirname, &#39;package.json&#39;), file, &#123; mode: 0666 &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"3、mkdirSync\"><a href=\"#3、mkdirSync\" class=\"headerlink\" title=\"3、mkdirSync\"></a>3、mkdirSync</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.mkdirSync(path[, mode])</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>path：string | Buffer | URL</li>\n<li>mode：integer Default: 0o777</li>\n<li>同步的 mkdir(2)。返回 undefined。</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class=\"line\">var path &#x3D; require(&#39;path&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">fs.mkdirSync(path.resolve(__dirname + &#39;&#x2F;name&#39;), 0777, function (err) &#123;</span><br><span class=\"line\">    if (err) &#123;</span><br><span class=\"line\">        console.log(err);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&quot;creat done!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"REFERRENCE\"><a href=\"#REFERRENCE\" class=\"headerlink\" title=\"REFERRENCE\"></a>REFERRENCE</h4><blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3RqL2NvbW1hbmRlci5qcy9ibG9iL21hc3Rlci9SZWFkbWVfemgtQ04ubWQ=\">Commander.js<i class=\"fa fa-external-link-alt\"></i></span> :node.js 命令行接口的完整解决方案  </p>\n</blockquote>\n","categories":["javascript"],"tags":["note","nodejs"]},{"title":"谈谈promise.resove,setTimeout,setImmediate,process.nextTick在EvenLoop队列中的执行顺序","url":"/2016/04/22/note/note-promise-nexttick-timeout/","content":"<h2 id=\"1-问题的引出\"><a href=\"#1-问题的引出\" class=\"headerlink\" title=\"1. 问题的引出\"></a>1. 问题的引出</h2><p>event loop都不陌生，是指主线程从“任务队列”中循环读取任务，比如<br><a id=\"more\"></a></p>\n<p>例1：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(function()&#123;console.log(1)&#125;,0);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(2)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;输出2,1</span><br></pre></td></tr></table></figure><br>在上述的例子中，我们明白首先执行主线程中的同步任务，当主线程任务执行完毕后，再从event loop中读取任务，因此先输出2，再输出1。</p>\n<p>event loop读取任务的先后顺序，取决于任务队列（Job queue）中对于不同任务读取规则的限定。比如下面一个例子：</p>\n<p>例2：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">  console.log(3);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(1);</span><br><span class=\"line\">&#x2F;&#x2F;输出为  1  2 3</span><br></pre></td></tr></table></figure><br>先输出1，没有问题，因为是同步任务在主线程中优先执行，这里的问题是setTimeout和Promise.then任务的执行优先级是如何定义的。</p>\n<h2 id=\"2-Job-queue中的执行顺序\"><a href=\"#2-Job-queue中的执行顺序\" class=\"headerlink\" title=\"2 . Job queue中的执行顺序\"></a>2 . Job queue中的执行顺序</h2><p>在Job queue中的队列分为两种类型：macro-task和microTask。我们举例来看执行顺序的规定，我们设</p>\n<p>macro-task队列包含任务: a1, a2 , a3<br>micro-task队列包含任务: b1, b2 , b3</p>\n<p>执行顺序为，首先执行marco-task队列开头的任务，也就是 a1 任务，执行完毕后，在执行micro-task队列里的所有任务，也就是依次执行<strong><em>b1, b2 , b3</em></strong>，执行完后清空micro-task中的任务，接着执行marco-task中的第二个任务，依次循环。</p>\n<p>了解完了macro-task和micro-task两种队列的执行顺序之后，我们接着来看，真实场景下这两种类型的队列里真正包含的任务（我们以node V8引擎为例），在node V8中，这两种类型的真实任务顺序如下所示：</p>\n<p>macro-task队列真实包含任务：</p>\n<p>script(主程序代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</p>\n<p>micro-task队列真实包含任务：</p>\n<p>process.nextTick, Promises, Object.observe, MutationObserver</p>\n<p>由此我们得到的执行顺序应该为：</p>\n<p>script(主程序代码)—&gt;process.nextTick—&gt;Promises...——&gt;setTimeout——&gt;setInterval——&gt;setImmediate——&gt; I/O——&gt;UI rendering</p>\n<p>在ES6中macro-task队列又称为ScriptJobs，而micro-task又称PromiseJobs</p>\n<h2 id=\"3-真实环境中执行顺序的举例\"><a href=\"#3-真实环境中执行顺序的举例\" class=\"headerlink\" title=\"3 . 真实环境中执行顺序的举例\"></a>3 . 真实环境中执行顺序的举例</h2><h4 id=\"1-setTimeout和promise\"><a href=\"#1-setTimeout和promise\" class=\"headerlink\" title=\"(1) setTimeout和promise\"></a>(1) setTimeout和promise</h4><p>例3:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">  console.log(3);</span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.resolve().then(function () &#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(1);</span><br></pre></td></tr></table></figure><br>我们先以第1小节的例子为例，这里遵循的顺序为：</p>\n<p>script(主程序代码)——&gt;promise——&gt;setTimeout</p>\n<p>对应的输出依次为：1 ——&gt;2————&gt;3</p>\n<h4 id=\"2-process-nextTick和promise、setTimeout\"><a href=\"#2-process-nextTick和promise、setTimeout\" class=\"headerlink\" title=\"(2) process.nextTick和promise、setTimeout\"></a>(2) process.nextTick和promise、setTimeout</h4><p>例子4：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(function()&#123;console.log(1)&#125;,0);</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">   console.log(2);</span><br><span class=\"line\">   resolve();</span><br><span class=\"line\">&#125;).then(function()&#123;console.log(3)</span><br><span class=\"line\">&#125;).then(function()&#123;console.log(4)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick(function()&#123;console.log(5)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(6);</span><br><span class=\"line\">&#x2F;&#x2F;输出2,6,5,3,4,1</span><br></pre></td></tr></table></figure><br>这个例子就比较复杂了，这里要注意的一点在定义promise的时候，promise构造部分是同步执行的，这样问题就迎刃而解了。</p>\n<p>首先分析Job queue的执行顺序：</p>\n<p>script(主程序代码)——&gt;process.nextTick——&gt;promise——&gt;setTimeout</p>\n<ul>\n<li>I)主体部分： 定义promise的构造部分是同步的，<br>因此先输出2 ，主体部分再输出6（同步情况下，就是严格按照定义的先后顺序）</li>\n<li>II)process.nextTick: 输出5</li>\n<li>III）promise： 这里的promise部分，严格的说其实是promise.then部分，输出的是3,4<br>setTimeout ： 最后输出1</li>\n</ul>\n<p>综合的执行顺序就是： 2——&gt;6——&gt;5——&gt;3——&gt;4——&gt;1</p>\n<h4 id=\"3-更复杂的例子\"><a href=\"#3-更复杂的例子\" class=\"headerlink\" title=\"(3)更复杂的例子\"></a>(3)更复杂的例子</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout(function()&#123;console.log(1)&#125;,0);</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function(resolve,reject)&#123;</span><br><span class=\"line\">   console.log(2);</span><br><span class=\"line\">   setTimeout(function()&#123;resolve()&#125;,0)</span><br><span class=\"line\">&#125;).then(function()&#123;console.log(3)</span><br><span class=\"line\">&#125;).then(function()&#123;console.log(4)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick(function()&#123;console.log(5)&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(6);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;输出的是  2 6 5 1 3 4</span><br></pre></td></tr></table></figure>\n<p>这种情况跟我们（2）中的例子，区别在于promise的构造中，没有同步的resolve，因此promise.then在当前的执行队列中是不存在的，只有promise从pending转移到resolve，才会有then方法，而这个resolve是在一个setTimout时间中完成的，因此3,4最后输出。</p>\n","categories":["javascript"],"tags":["note","javascript"]},{"title":"substr( )和substring( )的区别","url":"/2014/09/22/note/note-substr-substring/","content":"<p>JavaScript中有两个非常常用但又非常容易混淆的函数：substr()和substring()，两者都是String类型的方法，作用都是返回目标字符串的一个子串。<br><a id=\"more\"></a></p>\n<p>关于两者的详细文档可以参考：String.prototype.substr() 和 String.prototype.substring()</p>\n<p>两者都接收两个参数以控制子串的起止位置。第一个参数作用相同，都表示子串的起点位置，主要区别在于第二个参数：substr()要求获取一个长度len，通过子串的长度来计算截止点，而substring()则是直接定义终点的位置，从终点开始往后的字符串不被截取。换句话说，前者是“起点+长度”，后者是“起点+终点”。</p>\n<h3 id=\"substr-start-length\"><a href=\"#substr-start-length\" class=\"headerlink\" title=\"substr( start [ , length ] )\"></a>substr( start [ , length ] )</h3><h4 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h4><p>介于0（包含）和字符串长度之间的整数，表示从这个字符串开始截取子串；<br>若 ≥ 字符串长度，则返回空字符串；<br>若 &lt; 0，则从右起计数；<br>若 &lt; 0且绝对值超过字符串长度的，视为0；  </p>\n<h4 id=\"length（可选）\"><a href=\"#length（可选）\" class=\"headerlink\" title=\"length（可选）\"></a>length（可选）</h4><p>介于0（包含）和剩余字符串长度之间的整数，表示最大截取该长度的字符串作为子串；<br>若超过剩余字符串长度，则截取到字符串结束，超出部分不计；<br>若 ≤ 0，返回空字符串；<br>若不指定，则默认从start截取到字符串末尾；  </p>\n<p>举几个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str &#x3D; &quot;abcgefghij&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;(1, 2): &#39;   + str.substr(1, 2));   &#x2F;&#x2F; &#39;(1, 2): bc&#39;</span><br><span class=\"line\">console.log(&#39;(-3, 2): &#39;  + str.substr(-3, 2));  &#x2F;&#x2F; &#39;(-3, 2): hi&#39;</span><br><span class=\"line\">console.log(&#39;(-3): &#39;     + str.substr(-3));     &#x2F;&#x2F; &#39;(-3): hij&#39;</span><br><span class=\"line\">console.log(&#39;(1): &#39;      + str.substr(1));      &#x2F;&#x2F; &#39;(1): bcdefghij&#39;</span><br><span class=\"line\">console.log(&#39;(-20, 2): &#39; + str.substr(-20, 2)); &#x2F;&#x2F; &#39;(-20, 2): ab&#39;</span><br><span class=\"line\">console.log(&#39;(20, 2): &#39;  + str.substr(20, 2));  &#x2F;&#x2F; &#39;(20, 2): &#39;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"substring-start-end\"><a href=\"#substring-start-end\" class=\"headerlink\" title=\"substring( start [ , end ] )\"></a>substring( start [ , end ] )</h3><h4 id=\"start-1\"><a href=\"#start-1\" class=\"headerlink\" title=\"start\"></a>start</h4><p>介于0（包含）和字符串长度之间的整数，表示从该字符串开始截取子串；<br>若 ≥ 字符串长度，则返回空字符串；  </p>\n<h4 id=\"end（可选）\"><a href=\"#end（可选）\" class=\"headerlink\" title=\"end（可选）\"></a>end（可选）</h4><p>介于0（包含）和字符串长度之间的整数，表示从该字符开始不再被截取；<br>若 &gt; 字符串长度，则自动指定为字符串末尾；<br>若不指定，则自动指定为字符串末尾；  </p>\n<h4 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h4><p>任一参数 &lt; 0，或为 NaN，则将其视为0；<br>若 start == end，则返回空字符串；<br>若 start &gt; end，则两者交换数值；  </p>\n<p>举几个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var str &#x3D; &#39;abcdefg&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Displays &#39;abc&#39;</span><br><span class=\"line\">console.log(str.substring(0, 3));</span><br><span class=\"line\">console.log(str.substring(3, 0));</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Displays &#39;efg&#39;</span><br><span class=\"line\">console.log(str.substring(4, 7));</span><br><span class=\"line\">console.log(str.substring(7, 4));</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Displays &#39;abcdef&#39;</span><br><span class=\"line\">console.log(str.substring(0, 6));</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Displays &#39;abcdefg&#39;</span><br><span class=\"line\">console.log(str.substring(0, 7));</span><br><span class=\"line\">console.log(str.substring(-2, 7));</span><br><span class=\"line\">console.log(str.substring(0, 10));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"永恒的字符串\"><a href=\"#永恒的字符串\" class=\"headerlink\" title=\"永恒的字符串\"></a>永恒的字符串</h3><p>和许多其他编程语言一样，JavaScript中的字符串也是不可改变的，substr()和substring()都只是返回子串，要想保存结果还需要单独定义变量，否则就能即时输出一下。</p>\n<h3 id=\"跨界好基友slice-start-end\"><a href=\"#跨界好基友slice-start-end\" class=\"headerlink\" title=\"跨界好基友slice( start [ , end ] )\"></a>跨界好基友slice( start [ , end ] )</h3><p>除了本文的两个主角，JavaScript中还有一个函数也可用于获取子串，那就是主角们的好基友slice()，而之所以说它“跨界”，是因为slice()函数在 String 和 Array 类中都有定义。</p>\n<p>slice()函数有点像是substr()和substring()的杂合体：它的标记方式和substring()一样，通过标记起点和终点来进行子串的截取，但当任意参数为负数时，并不视其为0，而是从字符串末尾往前倒推，这一点却和substr()很像。（注意：slice()的两个参数都是这样，而substr()只有第一个参数可以这样，）。同样的，第二个参数是可选的，不指定、或超出字符串长度时，默认截取到字符串末尾。并且，因为两个参数都是介于0（包含）和字符串长度之间的，所以当第一个参数大于第二个参数时，并不会发生交换，而是返回空字符串。</p>\n<p>slice()在数组中的表现也是一样的，只不过操作对象变成了数组元素，不过JavaScript中字符串和数组本来就傻傻分不清楚，因此这里也不难理解其原理。</p>\n<h3 id=\"为什么要有3个\"><a href=\"#为什么要有3个\" class=\"headerlink\" title=\"为什么要有3个\"></a>为什么要有3个</h3><p>substr()、substring()、slice()分别提供了3中不同的截取字符串的思路，分别是：根据长度、从正向确定起止位置、从两端确定起止位置，开发人员可以根据需要灵活地选择最方便的用法。</p>\n","categories":["javascript"],"tags":["note","javascript"]},{"title":"shell实用技巧","url":"/2018/04/23/note/shell-techniques/","content":"<p>本文收集了一些用于写控制脚本时的实用技巧，加快工作效率。<br><a id=\"more\"></a></p>\n<h2 id=\"先上教程\"><a href=\"#先上教程\" class=\"headerlink\" title=\"先上教程\"></a>先上教程</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1zaGVsbC5odG1s\">Shell 教程<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"解析脚本参数-getopts\"><a href=\"#解析脚本参数-getopts\" class=\"headerlink\" title=\"解析脚本参数(getopts)\"></a>解析脚本参数(getopts)</h2><p><code>getopt</code> 与 <code>getopts</code> 都是 Bash 中用来获取与分析命令行参数的工具，常用在 Shell 脚本中被用来分析脚本参数。</p>\n<h3 id=\"两者的比较\"><a href=\"#两者的比较\" class=\"headerlink\" title=\"两者的比较\"></a>两者的比较</h3><ul>\n<li>getopts 是 Shell 内建命令，getopt 是一个独立外部工具</li>\n<li>getopts 使用语法简单，getopt 使用语法较复杂</li>\n<li>getopts 不支持长参数（如：--option ），getopt 支持</li>\n<li>getopts 不会重排所有参数的顺序，getopt 会重排参数顺序</li>\n<li>getopts 出现的目的是为了代替 getopt 较快捷的执行参数分析工作</li>\n</ul>\n<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">while getopts \"a:b:cdef\" opt; do</span><br><span class=\"line\">  case $opt in</span><br><span class=\"line\">    a)</span><br><span class=\"line\">      echo \"this is -a the arg is ! $OPTARG\" </span><br><span class=\"line\">      ;;</span><br><span class=\"line\">    b)</span><br><span class=\"line\">      echo \"this is -b the arg is ! $OPTARG\" </span><br><span class=\"line\">      ;;</span><br><span class=\"line\">    c)</span><br><span class=\"line\">      echo \"this is -c the arg is ! $OPTARG\" </span><br><span class=\"line\">      ;;</span><br><span class=\"line\">    \\?)</span><br><span class=\"line\">      echo \"Invalid option: -$OPTARG\" </span><br><span class=\"line\">      ;;</span><br><span class=\"line\">  esac</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<h3 id=\"详细参考\"><a href=\"#详细参考\" class=\"headerlink\" title=\"详细参考\"></a>详细参考</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hsdXJlbi9hcnRpY2xlL2RldGFpbHMvMTc0ODk2Njc=\">shell getopts 用法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaXRleWUuY29tL2Jsb2cveGluZ3dhbmcteWUtMTYwMTI0Ng==\">linux shell getopts<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"echo显示彩色文字\"><a href=\"#echo显示彩色文字\" class=\"headerlink\" title=\"echo显示彩色文字\"></a>echo显示彩色文字</h2><p>直接上代码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo -e \"\\033[41;36m something here \\033[0m\"</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>有的文章说需要加上<code>-e</code>选项，我自己在mac本上实验，是不用加的。</p>\n</blockquote>\n<p>其他颜色</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">echo -e \"\\033[30m 黑色字 \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[31m 红色字 \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[32m 绿色字 \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[33m 黄色字 \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[34m 蓝色字 \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[35m 紫色字 \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[36m 天蓝字 \\033[0m\"</span><br><span class=\"line\">echo -e \"\\033[37m 白色字 \\033[0m\"</span><br></pre></td></tr></table></figure>\n<h3 id=\"更多效果请参考\"><a href=\"#更多效果请参考\" class=\"headerlink\" title=\"更多效果请参考\"></a>更多效果请参考</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS80Mzk2OC5odG0=\">shell脚本中echo显示内容带颜色的实现方法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS80ODg0NS5odG0=\">shell脚本函数：控制颜色、定位、居中显示的代码<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["tools"],"tags":["note","tools","shell"]},{"title":"如何降低软件的复杂性","url":"/2018/10/08/softwareengineering/how-to-reduce-the-complexity-of-software/","content":"<p>John Ousterhout 是斯坦福大学计算机系教授，也是 Tcl 语言的创造者。<br><a id=\"more\"></a></p>\n<p><img data-src=\"https://www.wangbase.com/blogimg/asset/201809/bg2018091008.jpg\" alt=\"John Ousterhout\"></p>\n<p>今年四月，他出版了一本新书《软件设计的哲学》（A Philosophy of Software Design）。这是课程讲稿，160多页，亚马逊全部是五星好评。我还没读这本书，但是我看了作者在谷歌的一次演讲（Youtube），介绍了这本书的主要内容。我觉得非常值得看，大部分书教你怎么写正确的代码，这本书教你如何正确设计软件。下面我就根据演讲视频和网上的书评，做一下笔记。</p>\n<h3 id=\"一、什么是复杂性\"><a href=\"#一、什么是复杂性\" class=\"headerlink\" title=\"一、什么是复杂性\"></a>一、什么是复杂性</h3><p>Ousterhout 教授认为，软件设计的最大目标，就是降低复杂性（complexity）。 所谓复杂性，就是任何使得软件难于理解和修改的因素。</p>\n<blockquote>\n<p>Complexity is anything that makes software hard to understand or to modify.</p>\n</blockquote>\n<p>复杂性的来源主要有两个：代码的含义模糊和互相依赖。</p>\n<blockquote>\n<p>Complexity is caused by obscurity and dependencies.</p>\n</blockquote>\n<p>模糊指的是，代码里面的重要信息，看不出来。依赖指的是，某个模块的代码，不结合其他模块，就会无法理解。</p>\n<blockquote>\n<p>Obscurity is when important information is not obvious.Dependency is when code can&#39;t be understood in isolation.</p>\n</blockquote>\n<p>复杂性的危害在于，它会递增。你做错了一个决定，导致后面的代码都基于前面的错误实现，整个软件变得越来越复杂。&quot;我们先把产品做出来，后面再改进&quot;，这根本做不到。</p>\n<blockquote>\n<p>Complexity is incremental, the result of thousands of choices. Which makes it hard to prevent and even harder to fix.</p>\n</blockquote>\n<h3 id=\"二、复杂性的隔离\"><a href=\"#二、复杂性的隔离\" class=\"headerlink\" title=\"二、复杂性的隔离\"></a>二、复杂性的隔离</h3><p>降低复杂性的基本方法，就是把复杂性隔离。&quot;如果能把复杂性隔离在一个模块，不与其他模块互动，就达到了消除复杂性的目的。&quot;</p>\n<blockquote>\n<p>Isolating complexity in places that are rarely interacted with is roughly equivalent to eliminating complexity.</p>\n</blockquote>\n<p>改变软件设计的时候，修改的代码越少，软件的复杂性越低。</p>\n<blockquote>\n<p>Reduce the amount of code that is affected by each design decision, so design changes don&#39;t require very many code modifications.</p>\n</blockquote>\n<p>复杂性尽量封装在模块里面，不要暴露出来。如果多个模块耦合，那就把这些模块合并成一个。</p>\n<blockquote>\n<p>When a design decision is used across multiple modules, coupling them together.</p>\n</blockquote>\n<h3 id=\"三、接口和实现\"><a href=\"#三、接口和实现\" class=\"headerlink\" title=\"三、接口和实现\"></a>三、接口和实现</h3><p>模块分成接口和实现。接口要简单，实现可以复杂。</p>\n<blockquote>\n<p>Modules are interface and implementation. The best modules are where interface is much simpler than implementation.</p>\n<p>It&#39;s more important for a module to have a simple interface than a simple implementation.</p>\n</blockquote>\n<p><img data-src=\"https://www.wangbase.com/blogimg/asset/201809/bg2018091002.jpg\" alt=\"\"></p>\n<p>好的 class 应该是&quot;小接口，大功能&quot;，糟糕的 class 是&quot;大接口，小功能&quot;。好的设计是，大量的功能隐藏在简单接口之下，对用户不可见，用户感觉不到这是一个复杂的 class。</p>\n<p>最好的例子就是 Unix 的文件读写接口，只暴露了5个方法，就囊括了所有的读写行为。</p>\n<p><img data-src=\"https://www.wangbase.com/blogimg/asset/201809/bg2018091003.jpg\" alt=\"\"></p>\n<h3 id=\"四、减少抛错\"><a href=\"#四、减少抛错\" class=\"headerlink\" title=\"四、减少抛错\"></a>四、减少抛错</h3><p>有些软件设计者喜欢抛错，一遇到问题，就抛出一个 Exception。这也导致了复杂性，用户必须面对所有的 Exception。&quot;反正我告诉你出错了，怎么解决是你的事。&quot;</p>\n<p>正确的做法是，除了那些必须告诉用户的错误，其他错误尽量在软件内部处理掉，不要抛出。</p>\n<p><img data-src=\"https://www.wangbase.com/blogimg/asset/201809/bg2018091004.jpg\" alt=\"\"></p>\n<p>Tcl 语言的最初设计是，unset() 方法用来删除已经存在的变量，如果变量不存在，该方法抛错。Ousterhout 教授说，这个设计是一个错误，完全不应该抛错，只要把 unset() 定义成让一个变量不存在，就解决问题了。</p>\n<p><img data-src=\"https://www.wangbase.com/blogimg/asset/201809/bg2018091007.jpg\" alt=\"\"></p>\n<p>另一个例子是，Windows 系统不能删除已经打开的文件，会有错误提醒。这也是一个设计错误，有些用户实在删不掉这些文件，不得不重启系统。Unix 的做法是，总是允许用户删除文件，但是不清理内存，已经打开的文件在内存里面继续存在，因此不会干扰其他程序的运行，那些程序退出保存文件的时候，发现文件不存在才会报错。这个设计比较好。</p>\n<blockquote>\n<p>转自阮一峰博客<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMDkvY29tcGxleGl0eS5odG1s\">如何降低软件的复杂性？<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n","categories":["SoftwareEngineering"],"tags":["SoftwareEngineering"]},{"title":"理解RESTful架构","url":"/2011/09/12/softwareengineering/restful/","content":"<p>越来越多的人开始意识到，网站即软件，而且是一种新型的软件。这种&quot;互联网软件&quot;采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。<br><a id=\"more\"></a><br>网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。</p>\n<p><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091202.jpg\" alt=\"\"></p>\n<p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>\n<p>但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。</p>\n<h2 id=\"一、起源\"><a href=\"#一、起源\" class=\"headerlink\" title=\"一、起源\"></a>一、起源</h2><p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。<br><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/201109/bg2011091201.jpg\" alt=\"\"></p>\n<p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p>\n<p>他这样介绍论文的写作目的：</p>\n<blockquote>\n<p>&quot;本文研究计算机科学两大前沿----软件和网络----的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。&quot;</p>\n<p>(This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. )</p>\n</blockquote>\n<h2 id=\"二、名称\"><a href=\"#二、名称\" class=\"headerlink\" title=\"二、名称\"></a>二、名称</h2><p>Fielding将他对互联网软件的架构原则，定名为REST，即 <strong>Representational State Transfer</strong> 的缩写。我对这个词组的翻译是&quot;<strong>表现层状态转化</strong>&quot;。</p>\n<p>如果一个架构符合REST原则，就称它为RESTful架构。</p>\n<p>要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。</p>\n<h2 id=\"三、资源（Resources）\"><a href=\"#三、资源（Resources）\" class=\"headerlink\" title=\"三、资源（Resources）\"></a>三、资源（Resources）</h2><p>REST的名称 <strong>&quot;表现层状态转化&quot;</strong> 中，省略了主语。&quot;表现层&quot;其实指的是&quot;资源&quot;（Resources）的&quot;表现层&quot;。</p>\n<p>所谓 <strong>&quot;资源&quot;</strong> ，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p>\n<p>所谓 <strong>&quot;上网&quot;</strong> ，就是与互联网上一系列的&quot;资源&quot;互动，调用它的URI。</p>\n<h2 id=\"四、表现层（Representation）\"><a href=\"#四、表现层（Representation）\" class=\"headerlink\" title=\"四、表现层（Representation）\"></a>四、表现层（Representation）</h2><p>&quot;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式，叫做它的&quot;表现层&quot;（Representation）。</p>\n<p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>\n<p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的&quot;.html&quot;后缀名是不必要的，因为这个后缀名表示格式，属于&quot;表现层&quot;范畴，而URI应该只代表&quot;资源&quot;的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对&quot;表现层&quot;的描述。</p>\n<h2 id=\"五、状态转化（State-Transfer）\"><a href=\"#五、状态转化（State-Transfer）\" class=\"headerlink\" title=\"五、状态转化（State Transfer）\"></a>五、状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p>\n<p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生&quot;状态转化&quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是&quot;表现层状态转化&quot;。</p>\n<p>客户端用到的手段，只能是HTTP协议。<strong>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p>\n<h2 id=\"六、综述\"><a href=\"#六、综述\" class=\"headerlink\" title=\"六、综述\"></a>六、综述</h2><p>综合上面的解释，我们总结一下什么是RESTful架构：</p>\n<ol>\n<li>每一个URI代表一种资源；</li>\n<li>客户端和服务器之间，传递这种资源的某种表现层；</li>\n<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</li>\n</ol>\n<h2 id=\"七、误区\"><a href=\"#七、误区\" class=\"headerlink\" title=\"七、误区\"></a>七、误区</h2><p>RESTful架构有一些典型的设计误区。</p>\n<p><strong>最常见的一种设计错误，就是URI包含动词。</strong> 因为&quot;资源&quot;表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。</p>\n<p>举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。</p>\n<p>如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST &#x2F;accounts&#x2F;1&#x2F;transfer&#x2F;500&#x2F;to&#x2F;2</span><br></pre></td></tr></table></figure><br>正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST &#x2F;transaction HTTP&#x2F;1.1</span><br><span class=\"line\">Host: 127.0.0.1</span><br><span class=\"line\">　　</span><br><span class=\"line\">from&#x3D;1&amp;to&#x3D;2&amp;amount&#x3D;500.00</span><br></pre></td></tr></table></figure></p>\n<p><strong>另一个设计误区，就是在URI中加入版本号</strong>：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:&#x2F;&#x2F;www.example.com&#x2F;app&#x2F;1.0&#x2F;foo</span><br><span class=\"line\"></span><br><span class=\"line\">http:&#x2F;&#x2F;www.example.com&#x2F;app&#x2F;1.1&#x2F;foo</span><br><span class=\"line\"></span><br><span class=\"line\">http:&#x2F;&#x2F;www.example.com&#x2F;app&#x2F;2.0&#x2F;foo</span><br></pre></td></tr></table></figure><br>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Accept: vnd.example-com.foo+json; version&#x3D;1.0</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: vnd.example-com.foo+json; version&#x3D;1.1</span><br><span class=\"line\"></span><br><span class=\"line\">Accept: vnd.example-com.foo+json; version&#x3D;2.0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"（完）\"><a href=\"#（完）\" class=\"headerlink\" title=\"（完）\"></a>（完）</h2>","categories":["SoftwareEngineering"],"tags":["SoftwareEngineering"]},{"title":"工程思维：直觉和极限","url":"/2017/11/28/thinking/google-methodology-20171128/","content":"<p>身处智能时代，很多人都在想人工智能是否是万能的，特别是在它发展很快的时候。如果你要告诉他说，人工智能是人赋予机器的，他马上会问，这么聪明的计算机难道不会自己进化出主动意识么？<br><a id=\"more\"></a><br>这个问题如果你沿着他的思路去想，给他解释为什么不会，恐怕要花一年时间将整个计算机原理讲清楚。这种考虑问题的方式就是常人的方式，它将我们的理解力限制在了生活空间给我们带来的直觉上。</p>\n<p>事实上，搞清楚人工智能的极限在哪里还有一种简单的方法，这就需要采用工程思维了。今天我先简单地讲一个工程思维方法，明天我们用这个方法分析为什么人工智能有极限。</p>\n<p>工程思维是一个范围比较广，含义也有点模糊的概念，为了方便理解它的含义和重要性，我会在接下来的一年时间里用一些具体的事例来说明。</p>\n<p>今天我们先看一看生活环境给我们的直觉是如何误导我们的，以及工程中“极限”这个概念是如何让我们突破认识的限制，比常人更快地看清楚问题的本质。</p>\n<p>我在很多场合讲，直觉和生活常识非常有用，但是有时缺乏知识的直觉会欺骗我们。</p>\n<p>我一直记得小时候的一件事。那是物质匮乏的时代，家里一个苹果总是我和弟弟分着吃，那个时候弟弟很小，只能由父母刮苹果里的果肉喂着吃，每次父亲大约刮掉里面直径的70%给弟弟，然后外面剩下来的给我。我每次都觉得我的那一份少，而父亲则说我的那份大。</p>\n<p>后来在学校里学了体积的计算，我才意识到我大约吃了苹果的70%，而弟弟吃掉的是30%。只有刮掉苹果里面直径的80%，里外的重量才大致相当。这个认知和我们的直觉是不同的。事实上，如果一个球直径大一倍，体积可是大7倍，而不是想象中的两三倍。</p>\n<p>Google 过去面试产品经理的时候经常用一道和上面问题类似的题目——面试的房间里能装下多少高尔夫球。这道题目怎么入手呢？胡猜是不行的，是一万，十万，还是一百万？</p>\n<p>当然这道题倒也不难解，高尔夫球大约直径4厘米，如果我们把它们整整齐齐地像立方体那样码在一起，用眼睛估摸着房间的面积和高度，用小学数学就能解决。</p>\n<p>比如一个面积15平米，高3米的小会议室，大约可以装70万个。外界一直很好奇为什么 Google 考这道看似小学生也能做的数学题，其实目的是看面试者是根据直觉瞎猜，还是遵循一套解题的思路。<strong>Google 对产品经理的要求是，在没有数据之前不要轻易给出结论</strong>。</p>\n<p>遵循一套工程思路解决问题的人，对这个问题估计出来的大致数量级不大会错。但是，如果靠直觉瞎猜，在数量级上会相差十万八千里。不过有趣的是，大部分答错的人都是猜少了而不是猜多了。原因很简单，和我小时候一样，大部分人想象不出体积这东西随着边长或者直径增加时，会增长得有多么快。</p>\n<p>当然，在上面一类问题中，更正错误的直觉并不难，但是在有些事情上要让我们放弃掉我们从生活中获得的直觉，则是千难万难。</p>\n<p>比如，在高速行进的火车上分别往前面和后面各打一束光，哪束光的速度快？按照我们的直觉，或者说在低速世界里的经验，一定是往前打的光更快，因为速度是叠加的。</p>\n<p>但是，爱因斯坦说，它们是一样快的，因为光速是个常数，产生不了叠加的效果。这件事我估计即便接受了爱因斯坦相对论的人，90%也想象不出是什么情景，他们接受这个理论，仅仅是因为相信爱因斯坦是正确的。</p>\n<p>当然，也有不少人从自己的经验出发要挑战爱因斯坦，我们只要翻翻媒体，每一年都能找出一大堆什么挑战相对论，超越光速的报道。</p>\n<p>类似地，在历史上很多人试图制造出热能转换效率大于一的热机（比如蒸汽机或者内燃机），甚至是永动机，因为在他们看来只要不断提升效率，最终就能不断获得突破。</p>\n<p>在19世纪的时候，很多人就是这么想的。但是当时有一位工程师，叫做卡诺，他设计了一个理想的热机，然后估算出它的效率，并且给大家一个结论，世界上任何热机转化的效率都不会超过它。</p>\n<p><strong>极限对工程师来讲是一个非常重要的概念</strong>。今天，稍微有一点经验的工程师都知道，任何产品的性能都有一个物理上无法突破的极限，这个极限并不需要等到工程上接近它的那一天到来时才知道，而是早就可以通过已有的理论直接给出。</p>\n<p>这看上去是一件悲催的事情，一大群人在努力改进产品性能时，一个有眼光的人突然宣布了它的极限。但是，这其实是工程师们的福气，因为他们不会为不可能的事情浪费时间了。相反，只有缺乏工程思维的人才会想，“随着科技的发展，任何人间奇迹都是可能的”。</p>\n<p><strong>推翻物理学上的极限是近乎不可能的事情，至少到今天为止还没有发生，因为这样要颠覆整个物理学大厦。除了物理学的极限，还有一个数学上的极限，推翻它则是完全不可能的，因为数学是严格建立在逻辑之上的，不是根据实验观察得到的。</strong></p>\n<p>比如说，你不可能在平面上画出一个三角形，让它的三个角之和大于180度。当然，很多数学的极限也不是那么明显的，如果我们把自己的思维限制在生活的周围，是看不出来的。为了说明这一点，我们不妨看两个颇为相像的问题：</p>\n<p>第一个问题，1+1/2+1/4＋1/8＋1/16......，不断加下去会是无穷大吗？有人觉得会，因为加的数字是无穷无尽的。其实，在数学上可以严格地证明即便无限加下去，总和也不会超过2，也就是说它有极限。这和我们的生活经验其实有点相背离了，不过还不算太难理解，因为后面的数字越加越小。</p>\n<p>第二个问题就更加费解一点了，还是类似的加法，1+1/2+1/3＋1/4＋1/5......，不断加下去会有极限么？如果你按照上一个问题的思路来考虑这个问题，得到的结论应该是有一个极限，因为也是越加越小，加的数字趋近于零。如果你是这么想的，我不得不告诉你，非常遗憾，你猜错了，这个序列加下去还真是无穷大。</p>\n<p>这两个看上去差不多的序列，凭什么一个加起来连2都不到，另一个却是无穷大？人有这样的问题很正常，因为我们生活的范围限制了我们的思维。对这两个问题正确的思考方式应该是，抛开我们生活中习惯的约束，或者说认知的约束，用一个正确的数学或者工程工具去寻找答案。</p>\n<p>而这个工具，常常需要跳出问题本身。这就如同你看蚂蚁的爬行轨迹时，不能跟在它的后面，而要从它的上方看。所谓掌握工程思维的技巧，就是要比生活超越一个层级。</p>\n<p>讲回到人工智能是否是万能的这件事情上，如果我们的思路是，“今天它发展这么快，在很多地方瞬间超过人类，随着时间的推移，最终会在所有领域超过人类”，这就是常人的思维，它虽然符合逻辑，却无法洞察未来，对未来的认识完全建立在想象的基础上。如果有人再进一步推理，“将来它将产生自主意识，反过来控制人类”，这就没有逻辑根据了。</p>\n<p>那么，如果以工程的思维考虑这个问题，应该遵循什么思路呢？应该先直接找到机器智能在数学上和物理上的极限。明天，我们就来聊这个问题，看看计算机的老祖宗图灵是如何思考“计算的本质”这个终极问题的。</p>\n<p>祝冬安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"为什么计算机不是万能的","url":"/2017/11/29/thinking/google-methodology-20171129-why-computer-is-not-omnipotent/","content":"<p>今天我们就用工程中极限的思维方式，看看计算机的极限在哪里。我们今天所说的人工智能实际上是计算机的一个应用而已，因此，如果说计算机不是万能的，那么人工智能自然也不是。<br><a id=\"more\"></a><br>当然，谈这个本原性质的问题时，我们需要抛开具体的技术，回到原点，从计算的本质来说说计算机的极限。这些思考方式当然不是我发明的，而是被誉为“计算机之父”的图灵博士采用的。</p>\n<p>图灵博士被认为是神一样的人。在20世纪，全世界智力上可以和爱因斯坦平起平坐的人恐怕只有图灵和冯·诺依曼两人了（而后者被认为智力甚至超过了爱因斯坦）。神人自然有超越常人的地方，这里就让我们看看他们之间的区别。先说说常人的。</p>\n<p>在计算机的发展史上，常人想问题的方式是先做一两个能解决简单问题的计算机，然后越做越复杂。实际上直到图灵之前，计算机的发展就是沿袭这个思路进行的。</p>\n<p>西方科学史家有时也将这种发明的方式称为工匠式的，也就是经过长期经验积累，从量变到质变。关于计算机的历史，我在后面还会讲到，因此这里我把细节跳过去。</p>\n<p>当然，你听到“工匠式的”这四个字时可能感觉不太好，其实科学史家们并没有贬义，只是说出了这种方法的特点。这种方法我们至今依然在采用，而且在大多数时候很有效。</p>\n<p>我们所说的“迭代式进步”，“小步快跑”其实都是这种方法的其它称呼而已。可以讲，这种方法符合人认识数字时，从1，2，3，一直数到一百的做法。</p>\n<p>而图灵想问题的方式恰恰和常人相反。在上个世纪30年代中期，图灵在思考三个问题。</p>\n<hr>\n<ul>\n<li>第一个问题，世界上是否所有数学问题都有明确的答案？</li>\n<li>第二个问题，如果有明确的答案，是否可以通过有限步骤的计算得到答案？</li>\n<li>第三个问题才是，对于那些有可能在有限步骤计算出来的数学问题，能否有一种假想的机械，让它不断运动，最后当机器停下来的时候，那个数学问题就解决了？</li>\n</ul>\n<hr>\n<p>我们不妨仔细体会一下图灵和常人思维方式的差别。像图灵这样超越时代的人，他不是跟在蚂蚁后面来观察一件事情发展的规律，而是在前面等着大家，找到极限所在，然后他告诉大家，就在极限里寻找具体问题的答案吧，不要浪费时间纠结没有意义的事情，也就是那些试图超越极限的事情。</p>\n<p>具体到计算机这件事，图灵首先考虑的是“数学问题是否都有明确的答案”。因为这个问题不解决，就辛辛苦苦去解题，最后可能发现无解，一切努力都是在浪费时间。</p>\n<p>存在答案或者说能找到答案不等于能够在有限步骤之内解决这个问题，因此图灵考虑的第二件事就是划定一个范围，把计算机能解决的问题的范围又缩小了。当然，这个范围划定以后，就要设计一种有效的，通用的办法，保证按照这个办法做事，最终能够找到答案。</p>\n<p>而图灵设计的这种方法，是一个数学模型，后人称呼它为<strong>图灵机</strong>。今天所有的计算机，包括全世界正在设计的新的计算机，从解决问题的能力来讲，都没有超出图灵机的范畴。</p>\n<p>到此为止，图灵其实为今天的计算机和很长时间以后的未来计算机所能解决的问题划了一条不可超越的边界。</p>\n<p>图灵机提出至今已经80年了，全世界的 IT 行业依然没有超出它，由此可见用理论武装起来的工程的头脑，比直觉的头脑的影响力深远得多。</p>\n<p>接下来，我们总结一下人工智能的边界。</p>\n<hr>\n<ol>\n<li>世界上有很多问题，其中只有一小部分是数学问题；</li>\n<li>在数学问题中，只有一小部分是有解的；</li>\n<li>在有解的问题中，只有一部分是理想状态的图灵机可以解决的；</li>\n<li>在后一类的问题中，又只有一部分是今天实际的计算机可以解决的；</li>\n<li>而人工智能可以解决的问题，又只是计算机可以解决问题的一部分。</li>\n</ol>\n<hr>\n<p>我把这个嵌套逻辑画成了下面这张图，从图中可以看到，人工智能所能解决的问题真的只是世界上问题的很小一部分。对于人工智能来讲，我倒是觉得现在世界上没有解决的问题太多，无论是人还是机器（其实是它们背后编写程序的人），都应该想办法解决各种问题，而不是杞人忧天，担心人工智能这个工具太强大了。</p>\n<p><img data-src=\"/images/why-computer-is-not-omnipotent/1.jpg\" alt=\"\"></p>\n<p>最后，讲回到认知。图灵的认知是一种高屋建瓴，自上而下的认知，和我们常人不同。当然，你可能好奇为什么图灵能够有这样超越时代的认知，是他自己聪明还是有高人指导？其实两者兼而有之。</p>\n<p>需要指出的是，图灵的境界能想到这一层，首先是受到另一位数学大师<strong>希尔伯特</strong>的启发。</p>\n<p>希尔伯特在1900年的巴黎国际数学家大会上，提出了23个重要的、根本性的数学问题（也被称为希尔伯特问题）。</p>\n<p>其中第十个问题讲的是这样一件事情，<strong>“随便给一个不确定的方程，能否通过有限步的运算，判定它是否存在整数解？”</strong></p>\n<p>如果答案是否定的，那么就说明很多数学问题其实上帝也不知道答案是否存在。如果我们连答案是否存在都不知道，自然不可能去找到它。正是希尔伯特的这个提问，让图灵明白了计算机的极限所在。</p>\n<p>当然，你可能会问，随着技术的进步，图灵是否错了，是否所有的数学问题最终都有解？很遗憾，图灵没有错。</p>\n<p>1970年，前苏联伟大的数学家<strong>马季亚谢维奇</strong>从数学上解决了希尔伯特的那个问题。也就是说，<strong>的的确确有很多数学问题，上帝也不知道有没有答案，而且这样的问题比有答案的问题还要多得多</strong>。</p>\n<p>这件事情对人类认知上的冲击，远比在数学上的影响大，因为它向世人宣告了很多问题无解。</p>\n<p>第二个给予图灵巨大启示的人是他的精神导师冯∙诺依曼。</p>\n<p>冯∙诺依曼当时是普林斯顿大学的教授，而图灵是那里的博士生。图灵在读了冯∙诺依曼的《量子力学的数学原理》一书后，意识到<strong>计算来自于确定性的机械的运动</strong>。</p>\n<p>至于21世纪的电子计算机，里面<strong>电子的运动其实等价于机械运动</strong>。图灵同时猜测人的意识来自于测不准原理，这是宇宙本身的规律。图灵从此得出结论，<strong>计算是确定的，而意识可以是不定的，两者不可能划等号</strong>。</p>\n<p>很多人胡思乱想计算机是否有意识，其实早在80年前，图灵就感到两者是两回事，这就是任何计算机的边界。</p>\n<p>可以讲，没有来自希尔伯特和冯∙诺依曼的启示，图灵很难在那么年轻的时候对计算机想得那么透彻。我们经常讲，要和比自己强的人在一起，这一点很重要，因为只有这样我们的认知才能提升。反之，如果总是和臭棋篓子下棋，只能越下越臭。</p>\n<p>从图灵理解计算机本质这件事，希望能够给你一些启发，也希望你能有超出常人的认知。</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"在边界里面做事情","url":"/2017/12/04/thinking/google-methodology-20171204/","content":"<p>上周我们谈到了图灵对计算机所能够计算问题的边界的思考，并且提到了他所设计的虚拟的计算机模型——图灵机。</p>\n<p>图灵提出的图灵机可以讲是今天计算机世界的一个理论上的边界。到今天为止的整个 IT 行业，都没有越过这个边界。<br><a id=\"more\"></a><br>当然你可能会问，将来是否会超越这个边界？我也不知道答案。但是可以告诉你的是，目前从学术界到工业界，没有人试图去改变这个现状。要知道，任何今天开始的努力，可能十年后会有突破性的成果出现，再过20年后，才会有产品，这个周期至少是30年。</p>\n<p>因此，在我有生之年我不担心图灵机的边界问题。当然你还可能会问，为什么大家不试图改变它，突破它，原因很简单，突破它几乎不可能，而改变它并不能比原来更好。</p>\n<p>图灵给出的方法是一条捷径，任何严肃的科学家都没有必要舍近求远，当然经常有民间科学家自认为突破了理论上的极限，或者说他们和主流学界有所不同。</p>\n<p>大部分时候，我们单纯谈差异化是一件极其没有意义的事情，因为改变有好的改变和坏的改变，只有傻子才会为了标榜自己与众不同，找一个更差的差异化道路走。</p>\n<p>事实上，对待各种科学上边界的态度，是衡量职业科学家和民间科学家的试金石。</p>\n<p>在边界里做事情，不仅在计算机行业如此，也适用于所有的工程领域，很多时候在经济学上也都是如此。这是一种工程思维，也是让我们做事情事半功倍的方法。</p>\n<p>今天，我就对边界这个话题谈几点感受：</p>\n<p>先谈第一点：<strong>技术可以提高，但理论的极限无法突破，不要做徒劳的事情。</strong></p>\n<p>我们经常听到 IT 产业里的标准一说，比如媒体上经常谈论移动通信 2G、3G、4G 和接下来 5G 的标准，激光盘的 CD 标准、DVD 标准和蓝光 DVD 标准等等。</p>\n<p><strong>标准的本质是什么？就是在边界内尽可能地做好事情。</strong>在任何时候，技术在不成熟之前，是可以提高的，但是到了趋于成熟之后，理论上的极限是无法突破的。</p>\n<p>有水平的工程师都懂得这一点，因此他们不会在错误的方向上努力。</p>\n<p>我们先看看激光盘的例子。早期的激光盘是为音频（音乐）准备的，容量不是很高，只有700兆，如果用来存今天的高清照片，不过能存十张而已。</p>\n<p>在这个时期，技术是不成熟的，因此工程师们才会在激光盘本身的技术上改进，在激光播放机的精度上改进，这样就可能把容量做上去，于是就诞生了容量大了好几倍的 DVD。</p>\n<p>但是，无论如何改进精度，DVD 的容量都有一个理论上的极限，它受限于红色激光的波长。这时再想改进，其实是瞎费工夫，最终往这个方向投钱的东芝和微软完全失败了。</p>\n<p>后来是怎样获得突破的呢？</p>\n<p>这靠日本科学家发明了波长很短的蓝色激光，用蓝光做光盘，理论极限要比红光高很多，于是才有了今天的蓝光 DVD，也就是 BD（Blu-Ray DVD）。</p>\n<p>从这个例子可以看出，试图突破理论上的极限没有意义。</p>\n<p>当然，从红光 DVD 到蓝光 DVD 换了一种东西，极限也就变了。但是有一些事情的极限谁都无法改变，比如无线通信的带宽。</p>\n<p>在一个空间中，采用无线传输，整个空间里的带宽是有限的，从 AM 收音机用的几十千赫，到我们 WiFi 用的5千兆赫，带宽就这么一点宽。</p>\n<p>根据信息论，带宽是通信总量的上限，超过了这个上限，信号就会互相打架，什么信息都传不出去了，彼此说话都听不清。</p>\n<p>你在大型活动中可能有这样的体会，明明看着 WiFi 信号很强就是连不上，明明有 4G 信号，照片就是发不出去。原因很简单，同一个空间内用的人多了，通信总量超过极限了。</p>\n<p>第二点感受是： <strong>我们所能做的事情，不过是在边界内找到相对好的答案。</strong></p>\n<p>理解了边界所在，就知道了方向。还是以制定移动通信标准的科学家和工程师所能做的事情为例，我们不过是在极限内制定一个好一点的标准，那个标准要兼顾一下总传输率、上网人数，以及联网成功率（不掉线）等很多指标。</p>\n<p>此外还要考虑很多成本因素，发射功率、基站成本、手机设计的复杂程度等等。但是，你不能指望制定出一个总的传输率高，同时上网人数多，又不掉线，成本还低的标准。</p>\n<p>由于有边界的限制，好办法的数量常常也有限。</p>\n<p>以 3G 移动通信为例，高通公司不过是找到了一个相对好一点的标准 CDMA，并且尽可能地把相应技术都用专利保护起来。这样一来，其他国家如果不购买高通的专利，就会错过 3G 时代，各国只好向高通交钱，以至于让高通赚了个盆满钵满。</p>\n<p>到了 4G 时代，中国吃一堑长一智，和高通站在了同一个起跑线上，在制定标准上自然也有份了。</p>\n<p>第三点感受：<strong>写清楚的边界不让外行过去。</strong></p>\n<p>很多时候，理论的边界，行业里的人是懂的，但行业外的人未必能明白，因此后者时不时想做点，或者不小心做了一点越界的傻事。任何一个好的工程师（或者产品经理）都懂得在做事情的时候，很多边界是不能让外行过去的。</p>\n<p>比如说微软或者苹果等大公司做的软件，会引起误操作或者导致死机的功能都被屏蔽掉了，这样一般用户根本无法使用，当然一些专业人士为了调制程序还是可以打开的。</p>\n<p>再比如说，小孩子不小心吃错了药会很麻烦。因此，在美国，处方药的药瓶子一定要做成小孩子打不开的。但是，常人做事情时，常常不会在边界附近设防，以至于时不时闯祸。</p>\n<p>第四点感受：<strong>很多厂家常常利用大众对边界的不了解来赚钱。</strong></p>\n<p>今天很多低端的数码相机（包括很多卡片机和手机）动不动就宣称自己有两千多万像素的分辨率，而尼康最专业的相机 D5 也不过2000万像素。前者真能达到那么高的清晰度么？</p>\n<p>显然不能，因为镜头的分辨率有极限，这个极限来自于自然光的波长，简单地讲靠得很近的两束光会相互干涉，因此，如果镜头太小，成像是不可能清楚的，相机的像素再多，也不过是很多像素堆在一起而已。</p>\n<p>当然，相机的另一个极限是感光的半导体元件的尺寸，一个非常小的手机感光元件，是不足以产生上千万像素的清晰图像的。因此，不要指望手机1000万像素的照片真有那么高的分辨率（这么大的图片打印成17寸的照片，每一个像素应该都是清晰的）。</p>\n<p>今天大众对边界不了解的另一个表现是吃一大堆其实并不需要的维生素。人缺乏了维生素当然不行，但是吃多了也没有用，因为人每天需要的维生素有个上限，这就是边界，超过了这个上限的摄入量，全部被排出了体外，不会产生任何效果。今天商店里的维生素片，动不动就是所需剂量的几倍到几十倍，但是依然有很多人买单。</p>\n<p>面对同样的边界，有的人在边界内玩出精彩，但是也有的人总幻想边界很容易突破，最后处处碰壁。<strong>孔子讲随心所欲不逾矩，只有不逾矩，才能随心所欲。</strong></p>\n<p>愿你能随心所欲！</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"苹果成功的奥秘：从科学和技术的区别说起","url":"/2017/12/05/thinking/google-methodology-20171205/","content":"<p>科学和技术是紧密相连的，但并非一回事。研究科学是科学家的事情，把科学变成技术（今天这在美国叫做 translation，即翻译的意思）再变成产品，主要是工程师的事情。<br><a id=\"more\"></a><br><strong>没有前者，我们的技术就没有进步。没有后者使用了科学的成果，科学的发展也会停滞不前。</strong></p>\n<p>但是科学和技术还是有很大的不同，今天我们不从科学体系上分析，而是从工程思维上探讨这个问题。</p>\n<p>比如我前两天讲，对于工程师，10000和10001可能差不多是一回事，不作区分，但是如果你在数学考试中答案差了1，老师一定扣你分。</p>\n<p>再举一个更现实一点的例子。</p>\n<p>今天如果有两个课题组做同一个课题的研究，比如做语音识别。第一个组识别的错误率是7.8%，第二个是8%，不仅第一个组是第一名，而且0.2%的差异会让第二个组的论文没有发表价值。</p>\n<p>但是，从技术上讲，它们两家的技术都处在同一个时代，在其他条件不变的情况下做成产品，第一家公司是每1000个字需要更正78个，第二家需要更正80个，你觉得有区别么？</p>\n<p>很多人向我请教二级市场投资的问题，我和他们讲，如果你真想买单支股票，就要买那个细分市场上未来五年内第一名的企业，不要贪便宜买第二、第三名，因为第二、三名不仅会一直受到第一名的打压，而且永远拿不到第一名的市盈率估值。</p>\n<p>但是，当国内一些企业家到美国来，要通过收购公司获得技术时，我的建议却相反，要他们关注第二、第三名，甚至是第四名的企业，因为这些企业的收购价格比行业的领头羊要便宜得多，在同一个时代，大家在技术上的差异通常只是8%和7.8%的差别。</p>\n<p>了解了技术的这个特点，我们在投资时虽然要看重技术，但绝不要认为全世界技术第一的企业就一定比第二名取胜的可能性大很多。原因很简单，创业成功需要很多因素。</p>\n<p>在某些方面，两个创业团队的差距可能是我在第5封来信中讲的量级的差别，在技术上细小的差别肯定不能弥补其他地方量级上的欠缺。这种量级上的欠缺，时间越长，差距越大。</p>\n<p>从我对不同投资者的建议，以及我们本身在工作中的方法，你又可以看出工程思维和科学上一定要分出个对错的思维是迥然不同的。</p>\n<p>接下来我就以苹果公司为例，来说说在把科学和技术两件事情分清楚之后，在现实生活中应该怎么做事情。</p>\n<p>说到苹果公司，你可以想到它有很多改变世界的发明：</p>\n<ul>\n<li>个人电脑</li>\n<li>图形界面的操作系统（今天 Mac 机的操作系统）</li>\n<li>iPod</li>\n<li>智能手机 iPhone</li>\n<li>平板电脑 iPad</li>\n</ul>\n<p>此外，乔布斯离开苹果一段时间之后，还成立了一个公司，搞出了一个很酷的图形工作站 NeXT。正是因为如此，彼得∙蒂尔在《从0到1》一书中才拿它作为原创型技术公司的代表。<br>不过，蒂尔忽略了一些事实，苹果发明了刚才说的这些产品不假，但是它们里面用的技术其实都不是苹果原创的。</p>\n<p>下面这张表是刚才提到的苹果公司的产品的原创发明者，或者主要的技术来源：</p>\n<p>从这个表中你会发现，这些发明都不是苹果从0到1的原创发明，但是，我认为将它们的发明权和相应的荣誉给苹果并没有问题，因为在苹果以前，那些技术都没有什么大用途，而在苹果之后，它们才被全世界所知晓。</p>\n<p>更要一提的是，很多技术的发明时间和被苹果应用上的时间，中间差了30多年，比如多点触屏技术。也就是说，在这期间，很多公司有机会先采用那些技术做出改变世界的产品，但是它们都没有做，或者说没有做成（比如平板电脑，大家做了却都没有成功）。</p>\n<p>那么苹果有什么独到之处呢？总结起来有这样四个：</p>\n<h3 id=\"1-了解时代的技术边界。\"><a href=\"#1-了解时代的技术边界。\" class=\"headerlink\" title=\"1.了解时代的技术边界。\"></a>1.了解时代的技术边界。</h3><p>所有真正的内行，都知道边界在哪里，只有外行才会无法无边。巴菲特常讲，不做自己不懂的事情，其实就是为自己的投资划定了一个边界。当然苹果了解的不是投资边界，而是技术边界。</p>\n<p>苹果是一家产品驱动的公司，它很多技术是找来的，或者通过收购公司得到的，比如最近 iPhone X 的刷脸技术就是买了一家以色列公司得到的。</p>\n<p>这里顺带说一句，苹果在宣布了 iPhone X 的刷脸技术后，很多网友吐槽说中国的手机（和银行）早就有了。其实它们根本不是同一时代的技术，中国有的是简单的图像识别，你放张照片也能刷脸。</p>\n<p>而苹果的是主动投射（看不见的）光，照到脸上后根据反光，测量人脸的三维模型。后者的识别率要高得多，你不要想用照片来蒙事。</p>\n<p>至于买什么技术，在产品中使用什么技术，就有讲究了。苹果在设计一款新产品时，会先了解当下技术的边界在哪里，哪些技术已经可以完全实用了，哪些还要等几年，对于需要等几年的，它会几年后再考虑。</p>\n<p>10多年前，国内中科院一家做音乐识别的团队通过我找到苹果公司，展示它的哼歌识别技术，苹果看了后觉得技术不成熟，就没有打算用。</p>\n<h3 id=\"2-技术没有公司边界和国界。\"><a href=\"#2-技术没有公司边界和国界。\" class=\"headerlink\" title=\"2.技术没有公司边界和国界。\"></a>2.技术没有公司边界和国界。</h3><p>苹果采用的很多技术都不是它自己公司内部开发的，只要技术或者产品好，谁的都行。苹果最早的 MP3 播放器 iPod，充电器大得不得了。</p>\n<p>后来一家中美合资做变压器芯片的公司找到它讲，你们的充电器比电器本身大这么多，难道不想改进一下么？苹果说当然想，后来测试了他们的产品，并且采用了，然后一同开发了今天很小巧的充电器。</p>\n<p>相比之下我们很多企业都是照顾本位利益和关系户的利益，这种心态使得企业失去了获得最新技术的可能性。</p>\n<h3 id=\"3-由于在技术上不越界，并且采用开放心态，苹果基本上不做基础研究。\"><a href=\"#3-由于在技术上不越界，并且采用开放心态，苹果基本上不做基础研究。\" class=\"headerlink\" title=\"3.由于在技术上不越界，并且采用开放心态，苹果基本上不做基础研究。\"></a>3.由于在技术上不越界，并且采用开放心态，苹果基本上不做基础研究。</h3><p>在历史上，大的 IT 公司发展到一定规模有做理论研究的情怀，远的比如贝尔实验室，IBM 的沃森实验室，GE 的 RCA 实验室等等，近的如微软研究院、Google 的研究院和 X 实验室等部门。贝尔实验室出了十来个诺贝尔奖获得者，而 IBM 和 Google 都在基础研究上可圈可点。</p>\n<p>但是苹果不做这些事情。事实上苹果的研发费用相比它的营业额是很低的，绝对数也比 Google 和微软低很多。苹果的很多关键技术都是买来的。</p>\n<p>另外，苹果不会为了一个世界还没有解决的难题，自己投入巨大的气力从基础研究做起。这种做法如同为了吃回锅肉赶紧养猪。苹果从来不把新产品的命运，寄托在还没有结果的科学研究上。</p>\n<h3 id=\"4-在边界内，整体上做到最好。\"><a href=\"#4-在边界内，整体上做到最好。\" class=\"headerlink\" title=\"4.在边界内，整体上做到最好。\"></a>4.在边界内，整体上做到最好。</h3><p>这一点就是我昨天讲的，好的工程师（以及产品经理）不做越界的事情。苹果的工程师和产品经理也是如此，他们是在边界内尽可能地平衡各种需求，给一个整体上最好的答案。<br>把苹果手机的每个技术指标单拎出来，都算不上是同类产品中的翘楚，但是在兼顾各方面的需求后，苹果会尽可能把产品做到极致。</p>\n<p>从苹果做事的风格来讲，你看不到半点科学的影子，而是单纯围绕技术和利润展开工作。发明了晶体管、光纤和发现宇宙大爆炸 3K 背景辐射证据的 AT&amp;T 贝尔实验室，获得了整个科学界的尊敬，并且一度成为所有科学家都向往的地方，但是他们从来没有表达出对苹果的尊重，对它尊重的是广大果粉。</p>\n<p>这里我不评论哪家公司更好，只是让你感受一下科学和技术的区别，以及理解一下工程思维。如果你希望获得苹果式的成功，不妨借鉴它的四条经验。</p>\n<p>祝近安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"历史总在重演，科技永远向前","url":"/2019/01/13/thinking/google-methodology-20180113/","content":"<p>我的新课程《科技史纲60讲》明天就要上线了，让大家久等了。<br>在完成了四卷《文明之光》的写作之后，我其实酝酿了很久，来筹备这门科技史。<br>科技史浩如烟海，在梳理的过程中我获得了两个视角，非常受益，在这里也分享给你：一个是<strong>回望</strong>；一个是<strong>俯瞰</strong>。<br>回望历史，把握历史演化的来龙去脉，可以清楚我们今天所处的位置；<br>俯瞰历史，把握所有要素之间的联系，可以看清世界变化的规律。<br><a id=\"more\"></a></p>\n<p>拥有了这两个视角，你就可以更清醒地作出决策，这也是我在写作这门课程时，一直想要帮你达成的目标。现在，我终于完成了这门课，可以邀请你和我一起回望和俯瞰这部跨越几万年，涵盖所有人类文明中心的科技史了。<br>我们都知道科技史时空跨度极大，但你不用担心，我会给出两条清晰的线索：<strong>“能量”和“信息”</strong>，帮助你重新理解整部科技史，你会发现，这个世界的终极答案就是能量和信息。<br>我们过去说世界是物质的，其实，更准确地说，世界应该是能量的，因为物质从本质上讲就是由能量构成的。那信息又是什么呢？信息就是组织和调动能量的法则，比如语言、文字、公式、公理等等。科学的本质就是通过一套有效的方法去发现这样一些特殊的信息。</p>\n<h3 id=\"那怎么从能量和信息的视角去解读历史呢？\"><a href=\"#那怎么从能量和信息的视角去解读历史呢？\" class=\"headerlink\" title=\"那怎么从能量和信息的视角去解读历史呢？\"></a>那怎么从能量和信息的视角去解读历史呢？</h3><p>比如说，古代历代王朝的更替，本质上都是土地创造的能量无法满足人口消耗的能量；语言相较于基因，是更高效的信息载体，使人类的进化得到快速发展……你会发现这两条线索，在整个科技史中，都充满了解释力，人类的所有科技进步，一定会毫无意外地落在这两条线索上。<br>有了线索还不够，我还会为你从庞杂的科技史中，遴选出60个最伟大的科技进步，这60个伟大进步，每一个都是科技史上的里程碑，每一个都蕴含着复杂的内在逻辑，值得你拆解研究。透过这60个瞬间，你就可以了解整个科技史全貌，找到人类进步所共通的规律，当然我更希望你记住一句话：<strong>历史总在重演，科技永远向前</strong>。<br>我们总说要铭记历史，但是，在一个较长的历史阶段回望历史事件的影响力，再大的事情都显得微乎其微。<br>甲午战争重要吧？中国完败，日本完胜，获得了很多天赐良机，但是今天，对比中日两国的发展，你就会发现那场海战的影响力几乎衰退殆尽；<br>两次世界大战重要吧？但是德国在两次世界大战中虽然被打败，却丝毫没有影响它如今欧洲第一大经济体的地位；<br>拿破仑战争，普法战争，十月革命，这些国家兴衰、王朝更替的大事，在今天看来，影响力已经非常有限了。<br>但科技史却是永远前进的，科技是唯一能够产生可叠加式收益的进步力量。<br>直到今天，我们依然穿着10多万年前发明的衣服，吃着1万多年前驯化的水稻，用着4000多年前的勾股定理和300多年前的牛顿力学……每一次科技的发展，都在为今天的科技大厦添砖加瓦，都让活在当今的人们享受它的恩泽。<br>因此，我经常说，在历史的轮回中，王侯将相比起那些推动文明前进的人，太微不足道了。历史的界碑应该以每一次科技的进步为节点，也只有科技变革的按钮，才能触发不可逆转的历史进程。你会发现，真正推动历史发展的只有科技，科技史就是一部确定的、不断向前的历史。<br>从科技史给出的视角去串连历史，你才能真正洞察世界变化的趋势。因此，我有必要带你完成这次对人类文明的回望和俯瞰。<br>学完这门课程后，我希望你收获以下三种能力：</p>\n<h4 id=\"1-看清楚自己，看清楚未来的能力：\"><a href=\"#1-看清楚自己，看清楚未来的能力：\" class=\"headerlink\" title=\"1.看清楚自己，看清楚未来的能力：\"></a>1.看清楚自己，看清楚未来的能力：</h4><p>在科技史中，它的现象和规律经常在重复，了解科技发展的来龙去脉，找出共通的规律，就能更好地把握未来。</p>\n<h4 id=\"2-掌握解决问题的能力：\"><a href=\"#2-掌握解决问题的能力：\" class=\"headerlink\" title=\"2.掌握解决问题的能力：\"></a>2.掌握解决问题的能力：</h4><p>学习他人的能力：对于自己没做过的事，如何学习别人的经验；<br>自我创造的能力：对于从来没人做过的事，如何拆解复杂问题，把未知变已知。</p>\n<h4 id=\"3-分清偶然性和必然性的能力：\"><a href=\"#3-分清偶然性和必然性的能力：\" class=\"headerlink\" title=\"3.分清偶然性和必然性的能力：\"></a>3.分清偶然性和必然性的能力：</h4><p>科技的发展有很多历史的必然性。如果没有爱因斯坦，同时代的人也能发现狭义相对论。认识必然性能帮你摆脱错误归因；<br>但是另一方面，很多重大的发明发现都具有一定的偶然性。承认偶然性，对世界多一分敬畏，就可以离成功更近一步。<br>最后，了解历史的目的，还是为了能够把今天的事情做好。因此，这门课的重点不仅在于讲述历史事实，更在于训练思维。我会在每一节课的最后，都强调出这一讲的要点，帮你从特定的侧面理解科技。<br>如果你愿意和我一起重新回望人类历史，俯瞰这部不可逆的科技史是如何一步一步推进到今天的，那么我们现在就启程吧。</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"快速排序：要想提高效率就要少做事情","url":"/2018/03/06/thinking/google-methodology-20180306/","content":"<p>昨天我们介绍了好的算法和坏的算法区别有多大。那么你可能会问，世界上已知的最好的算法是什么呢？在评判“最好”之前，我们还是要加一些限制条件，比如是一般情况下最好，还是恶劣的情况下最好。为了便于你理解这两种情况的差别，我们不妨看这样一个例子。<br><a id=\"more\"></a><br>我每次到北京，大部分时间住在东三环，因为那里到其它地方交通还算便利。从东三环到机场，通常情况下时间最短的线路是从三元桥到机场高速公路，大约40分钟。但是，如果东三环出现一点意外的交通状况，那就会堵得一点都动不了了，这条路恐怕就要花2个小时。如果要避免在这种倒霉情况下误了飞机，一个办法是走东四环然后上第二机场高速，后者比较偏僻，车比较少，即使遇到交通事故，也不会堵死。通常来讲，它比第一条线路慢15分钟，但是，在极端情况下，它比第一条线路快半小时。稍微有点生活经验的朋友都会知道，世界上，没有绝对的最好。</p>\n<p>类似的，计算机算法常常也是如此，最好的总是有附加条件，如果运行一个程序，实时性要求不是那么高，可能应该采用算法A；如果实时性要求非常严，比如下围棋进入了读秒阶段，就需要用算法B了，因为后者在遇到倒霉的情况时不会太糟糕。</p>\n<p>讲回到排序这件事，目前世界上通常情况下最好的算法是一种叫做&quot;<strong>快速排序（Quicksort）</strong>&quot;的算法，他是由英国计算机科学家托尼·霍尔（Tony Hoare）于1959年想到的，1961年发表的，这个算法也成了今天世界计算机产业中使用最多的排序算法，霍尔因此获得了爵士头衔，也成为第一个获得这种头衔的科学家。那么快速排序为什么快呢？原因很简单，它还是强调少做事情，其原理大致是这样的：</p>\n<p><strong>首先，对于一大堆无序的数字，从中随机挑选一个，</strong>比如是53，这个被随机选上的数字被称为枢值（枢纽的枢），接下来，将所有要排序的数字分成两部分，第一部分是大于等于枢值53的，第二部分是小于枢值53的。在第一步完成后，一大堆无序的数字就变得稍微有序一点了。</p>\n<p><strong>第二步，从上面得到的两堆数字，分别采用第一步的方法各自再找一个枢值。</strong>对于第一堆，由于所有的数字都比53大，至少也等于53，因此，第二次随机挑选的枢值肯定是一个大于53的数字，比如79；类似地，对于第二堆，由于所有的数字都小于53，因此第二次随机挑选的枢值肯定小于它，比如4。接下来，再把两堆数字各自分成大于等于相应枢值的数字序列，以及小于枢值的数字序列。这样做下来，原来的一大堆数就变成了四小堆，它们分别是小于4的数字，介于4到53之间的，介于53到79之间的，以及大于或等于79的。</p>\n<p><strong>再接下来，用同样的方法，四堆变八堆，八堆变十六堆，很快所有的数字就排好序了。</strong></p>\n<p>这种算法通常情况下复杂度也是N乘以log（N），和昨天介绍的归并排序相同。根据计算机科学的标准，它们同样好，不过在工程上，快速排序算法一般情况下比归并排序快两倍，因此在工程上还是有意义的。这也是为什么很多人用它的原因。至于为什么快速排序能够更快一些呢？这可以在计算机科学上证明，不过为了方便理解，我打一个比方你就明白了。</p>\n<p>假如有一个学区，里面有20000名高中学生，如果让大家到一个超级大的学校上大课，再从中挑出学生中的尖子，效率一定高不了。这就相当于是昨天一开始讲的冒泡排序，每一个人都要和所有人去比。如果我们把2万人放到10所学校中，每所学校只有两千人，从各个学校先各自挑出学习尖子，再彼此进行比较，这就有效得多了。这就是昨天说的归并排序原理。</p>\n<p>如果我们先划出几个分数线，根据个人成绩的高低把20000个学生分到十所学校去，第一所学校里的学生成绩最好，第十所最差，再找出学习尖子，那就容易了，工作量最小，这就是快速排序的原理，也是快速排序比昨天讲的归并排序快的原因。</p>\n<p>其实，<strong>计算机算法和组织的管理，乃至社会的管理，在道理上有相通性，想要提高效率就是要少做事情。</strong> 一个社会的管理，要想效率高，最简单的办法就是对每一个人作一些区分，而效率最低的办法就是刻意追求所有人一律平等，不作区分。可以想象，当一个学校的学生水平都比较接近，老师教起来就容易，因此按照成绩对学生作一个初步的划分是有道理的，特别是在资源不足的情况下。反之，如果一个学校的学生从100分的到0分的都有，那么老师教起来就困难了，如果想达到前面同样的效果，就必须多投入资源。</p>\n<p>从对比快速排序和归并排序大约三倍的效率之差，我还得到一个启发，那就是为什么美国私营公司的效率会比政府高很多。美国的政府和社会要讲究民主和平等，但是美国的公司里从来不讲这一套，公司里的大事从来不会和每一个员工商量，行政的层级就如同快速排序事先划定的枢值，有了三六九等，公司才有效率可言。</p>\n<p>因此，当一个年轻的员工新入职后，处于最低的层级时，不要指望公司的政策是照顾底层的员工，因为那样的组织没有效率，没有效率的组织在竞争中是要死掉的，当一个公司死掉后，任何理想都成为了泡影。所以，每个底层员工所思考的事情，是如何进入更高的层级，这也是我从来不强调什么底层思维的原因，毕竟大家将来是会不断上升的，必须具有高层思维。底层思维，或者心灵鸡汤，无异于是一种毒药。如果你还在庆幸自己进入了一个最底层员工的工资和总经理差不多的单位时，趁着年轻赶快离开，因为这样的公司是要死掉的。</p>\n<p>我在今天一开始讲，快速排序是通常情况下最好的算法，但是，在极端的情况下，它的复杂度是N平方，和冒泡排序一样糟糕。而归并排序，即使在最坏的情况下，也能保证N乘以log（N）的复杂度，当然工程师们会想一些方法防止这种糟糕情况的发生。从这个例子可以看出，世界上没有绝对的好，常常有一得便有一失。</p>\n<p>最后大家可能还会有一个问题，随着科技的进一步进步，有没有可能发明一种比快速排序更好的算法？从科学上讲，答案是否定的。因为从数学上可以证明N个任意随机数的排序，复杂度不可能比N乘以log（N）更低，这是数学给出的极限，或者边界，因此有点头脑的人都知道别在这方面瞎费工夫。这也是我一直强调要在边界内做事情的原因。</p>\n<p>我在腾讯面试工程师时，曾经遇到过一个学习计算机科学的学生，总是不相信排序算法的速度是有极限的，我给他看数学上的证明，他因为数学基础有限看不明白，于是我在想，这个人和痴迷永动机的人没有什么区别，没有救了。花时间培训这样的人是瞎费工夫，最好的办法就是像芒格说的那样，将那种人排除在组织之外。</p>\n<p>上面就是我从快速排序算法中悟出的生活里的思维方式，希望对你有所启发。</p>\n<p>最后邀请你思考一下，从快速排序对效率的提高，你有什么对生活和工作的感悟？</p>\n<p>祝近安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"最大的自然数","url":"/2018/10/31/thinking/google-methodology-20181031/","content":"<p>看到今天的题目，你可能会想，世界上最大的自然数不就是无穷大么？无穷大当然没有意义，我们今天讨论一个具体的、有意义的、非常大的自然数，它可能是你能理解的最大的数字了。<br><a id=\"more\"></a><br>当然，有人问，这是否是Googol，即10的100次方（1后面跟100个零）。Googol是一个创造出来的大数，虽然Google公司将它变化后作为公司的名字，但是除此之外，它没有什么意义。</p>\n<p>我们今天要说的叫做<strong>葛立恒数</strong>，它可比Googol大得多，而且它的物理含义很好理解，它也是目前吉尼斯世界纪录中最大的有意义的数字。</p>\n<p>为了说明葛立恒数是怎么来的，我们先看一个计算机问题。</p>\n<h3 id=\"超立方体染色问题\"><a href=\"#超立方体染色问题\" class=\"headerlink\" title=\"超立方体染色问题\"></a>超立方体染色问题</h3><p>假如有一个N维超立方体。我们知道，N＝3时就是我们常见的立方体，当然N＝2的时候是一个正方形。不难看出，二维的正方形有4个顶点，三维的立方体有2^3=8个顶点。那么N维的超立方体就有2^N个顶点。我们将这2^N个顶点之间一一连线。</p>\n<p>接下来，我们对这些连线（边）进行染色，要么是红的，要么是蓝的。我们要求任何四个在同一平面上的顶点，彼此之间的连线不能是同一个颜色。比如N＝2的时候，下面这个平面的连线就是有蓝有红的。</p>\n<p><img data-src=\"/images/google-methodology-20181031/1.png\" alt=\"\"></p>\n<p>在立方体中要保证每一个四个顶点的平面上颜色都是不同的就困难一些了，但是还是有办法这么画出来的。下图是我从维基百科上截的屏，图中出现了一个违反规定的平面。</p>\n<p><img data-src=\"/images/google-methodology-20181031/2.png\" alt=\"\"></p>\n<p>当然，在N等于3时还是能有很多种染色方法，保证每个平面不是单色的，但是当N不断增大时，因为点和线太多，保证这一点就越来越难了。最后的问题是，当N达到多大时，至少有一个面无法满足（双色）这个条件？也就是说，不论你如何染色，至少有一个面，它的边都是一种颜色的了。这个N，就叫做葛立恒数。</p>\n<p>葛立恒数非常大，远比Googol大得多。如果我们把宇宙看成是一个球面，我们在这个球面上用最小的字体，小到原子的大小，来书写葛立恒数，那么宇宙这个球体也写不下。你可能会问，这么大的数有意义么？在数学上它很有意义，事实上今天IT技术用的很多数字，要远远大于宇宙的尺寸和时间长度。</p>\n<p>举例来讲，今天发现的最大素数为两千三百万位（23,249,425位），如果我们把宇宙的直径用最小的长度单位（普朗克，相当于10的-35次方米）来衡量，不过是10的51次方，也就是52位十进制，比最大的素数小很多。如果把宇宙的年龄也用最小的时间单位（也是普朗克，10的－43次方秒）来衡量，也不过10的61次方（62位），也比最大的素数要小得多。</p>\n<p>找到最大素数的直接意义是可以设计实现一个更安全的加密系统。如果加密系统出了问题，我们今天谈的比特币或者其他区块链的应用，就失去了基础。因此，世界上很多看似远离我们的科技成就，其实在不经意之间已经用于了我们的生活。</p>\n<h3 id=\"高德纳箭头\"><a href=\"#高德纳箭头\" class=\"headerlink\" title=\"高德纳箭头\"></a>高德纳箭头</h3><p>讲到这里，你可能会好奇葛立恒数到底有多大，首先我们要说它是一个有限的数字，不是无穷大。但是，由于我们无法写下它的大小，而今天的数学家也无法想象它的具体大小，因此人们只能通过间接的方式描述它的尺度。这里就要引入一个概念，叫做高德纳箭头（↑）了，这个高德纳，就是我们之前介绍过的计算机科学家高德纳。</p>\n<p>在讲高德纳箭头之前，我们先说说常人能够想到的增长最快的函数，人们大多会想到最快的增长不过是指数增长，比如2翻番64次，就大得不得了了。但是，指数增长只是高德纳箭头中增长最慢的一种。高德纳箭头是这样定义的。</p>\n<ul>\n<li>2↑3=2×2×2=8</li>\n<li>2↑4=2×2×2×2=16</li>\n<li>3↑3=3×3×3=27</li>\n</ul>\n<p>以此类推，这其实就是指数增长。</p>\n<p>接下来高德纳定义两个箭头↑↑：</p>\n<p>比如2↑↑2=2↑2↑2，注意：此处要从右往左计算，也就是说它等于2↑（2↑2）＝2↑4=16，而<br>3↑↑3=3↑（3↑3）=3↑27=7625597484987，这就已经大得不得了了。</p>\n<p>再接下来，高德纳定义了三个箭头↑↑↑，它每一次要先拆解为两个箭头，比如<br>2↑↑↑3=2↑↑（2↑↑2）= 65536，而<br>3↑↑↑3=3↑↑3↑↑3=3↑↑7625597484987=3^3^3^3……^3^3^3^3^3^3，这已经太多了，没法写下来，因为一共是七万多亿层（7，625，597，484，987层，3的三次方的嵌套）。<br>四个箭头、五个箭头自己想象吧，我已经想象不出来了，但是它们依然是有限数。<br>最后说葛立恒数是如何定义的：</p>\n<p>它是两个3中间有好多好多箭头，有多少个呢？多得写不下，只好再用一个高德纳箭头表示其中的箭头数目，即第一层的箭头数目等于第二层的数字，而第二层的数字，又是一个巨大的高德纳箭头数（3之间很多箭头），就这样一层层嵌套下去，一直嵌套64层，而最后一层是3的四个箭头。我们知道3的三个箭头已经写不下了，3的四个箭头我已经无法想象了。而葛立恒数有这样的64层，它的大小可想而知。</p>\n<p><img data-src=\"/images/google-methodology-20181031/3.png\" alt=\"\"></p>\n<h3 id=\"大数字的意义\"><a href=\"#大数字的意义\" class=\"headerlink\" title=\"大数字的意义\"></a>大数字的意义</h3><p>今天给大家讲这个大数字有什么意义呢？</p>\n<p>首先是让大家体会数学世界和真实世界的差异。</p>\n<p>我在小时候，曾经有过这样的疑问，很多数学上的规律，明明通过测量，或者试验很多次的方式来证实，而且每次都是对的，为什么还要用逻辑严格证明呢？后来我才体会到，我们能够试验，能够测量的世界其实非常有限，在这个有限的世界里被证实，不等于真的被证实了。</p>\n<p>比如今天说的超立方体染色问题，在我们能够想象的、足够高的维度，都是可以找到染色的方法，不出现同一种颜色的平面。但是当维度增加到葛立恒数时，这个规律就打破了。也就是说我们在小世界里证实的规律，未必适合于大世界。</p>\n<p>数学的力量在于，它给我们提供了一个远远超过我们能够身体力行的想象空间。在那个近乎无限的空间里，人类有着超越我们现在的潜力空间。</p>\n<p>第二，数学能够让我们感受到自身认知的局限性。人越是发现世界之大，越是能体会自己的渺小。真正的科学家都会说他们的贡献微乎其微，微不足道，这倒不完全是谦虚，而是他们了解的东西越多，就发现自己所做的事情真的只是很小的一个子集。世界上绝大多数顶级科学家都信神，这并不意味着他们笃信某种宗教或者周末要去教堂，而是觉得和“神的力量”相比，人类的见识很渺小罢了。</p>\n<p>第三，理解计算机的作用。计算机，特别是今天热门的人工智能是延伸了人们想象力的工具，而不是限制了我们的敌人。没有计算机，我们很难想清楚葛立恒数这样的事情。很多年前，数学家们借助于计算机证明了著名的四色地图问题，这其实就是对我们人脑的智力作了一次延伸。</p>\n<p>我知道，这周的内容有点烧脑，总的目的就是让大家了解一下数学的世界，它和我们现实世界的差别，以及相互的关联。</p>\n<blockquote>\n<p>思考题：想象一个你心目中真实有意义的大数字。</p>\n</blockquote>\n<p>祝 近安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"对经济学一窍不通：看完这18个段子将会醍醐灌顶！","url":"/2013/08/18/thinking/note-18-sentences/","content":"<h3 id=\"1、利息\"><a href=\"#1、利息\" class=\"headerlink\" title=\"1、利息\"></a>1、利息</h3><p>银行家的儿子问爸爸：“爸爸，银行里的钱都是客户和储户的。那你是怎样赚来房子、奔驰车和游艇的呢？”银行家：“儿子，冰箱里有一块肥肉，你把它拿来。”儿子拿来了。“再放回去吧。”儿子问：“什么意思？”银行家说：“你看你的手指上是不是有油啊？”<br><a id=\"more\"></a></p>\n<h3 id=\"2、投行\"><a href=\"#2、投行\" class=\"headerlink\" title=\"2、投行\"></a>2、投行</h3><p>有一个投行菜鸟问：“什么是投行?”前辈拿了一些烂水果问他：“你打算怎么把这些水果卖出去?”菜鸟想了半天说：“我按照市场价打折处理掉。”这位前辈摇头，拿起一把水果刀，把烂水果去皮切块，弄个漂亮的水果拼盘：“这样，按照几十倍的价格卖掉”。</p>\n<h3 id=\"3、销售\"><a href=\"#3、销售\" class=\"headerlink\" title=\"3、销售\"></a>3、销售</h3><p>男生对女生说：我是最棒的，我保证让你幸福，跟我好吧。——这是推销。<br>男生对女生说：我老爹有3处房子，跟我好，以后都是你的。——这是促销。<br>男生根本不对女生表白，但女生被男生的气质和风度所迷倒。——这是营销。<br>女生不认识男生，但她的所有朋友都对那个男生夸赞不已。——这是品牌。</p>\n<h3 id=\"4、停车费\"><a href=\"#4、停车费\" class=\"headerlink\" title=\"4、停车费\"></a>4、停车费</h3><p>一位富豪到华尔街银行借了5000元贷款，借期为两周，银行贷款须有抵押，他用停在门口的劳斯莱斯做抵押。银行职员将他的劳斯莱斯停在地下车库里，然后借给富豪5000元。两周后富豪来还钱，利息共15元，银行职员发现富豪账上有几千万美元，问为啥还要借钱。富豪说：15元两周的停车场，在华尔街是永远找不到的。</p>\n<h3 id=\"5、奢侈品\"><a href=\"#5、奢侈品\" class=\"headerlink\" title=\"5、奢侈品\"></a>5、奢侈品</h3><p>经济学老师一日讲到奢侈品，为了便于理解，说道：“同学们知道什么是奢侈品么，假设你跟你的女朋友逛街，你女朋友盯着一个东西超过30秒，你付钱买了下来，那么这个东西就是奢侈品。”同学们都会心一笑。还没完，“继续逛，你的女朋友又盯着一个东西超过30秒，同学们，那你的女朋友就是奢侈品啊！”</p>\n<h3 id=\"6、长线投资\"><a href=\"#6、长线投资\" class=\"headerlink\" title=\"6、长线投资\"></a>6、长线投资</h3><p>一位8岁的女孩拿着三角钱来到瓜园买瓜，瓜农见她钱太少，便想糊弄小姑娘离开，指着一个未长大的小瓜说：“三角钱只能买到那个小瓜”，女孩答应了，兴高采烈的把钱递给瓜农，瓜农很惊讶：“这个瓜还没熟，你要它怎么吃呢?”女孩：“交上钱这瓜就属于我了，等瓜长大熟了我再来取吧。”</p>\n<h3 id=\"7、产业经济学\"><a href=\"#7、产业经济学\" class=\"headerlink\" title=\"7、产业经济学\"></a>7、产业经济学</h3><p>课堂上，教授讲授经济学：“何谓第一产业?喂牛，养羊。何谓第二产业?杀牛，宰羊。何谓第三产业?吃牛肉，喝羊汤。”有学生问：“那么，文化产业呢?”教授眼睛一亮：“问得好!不愧是俺的好学生。”然后回答：“所谓文化产业，就是吹牛皮，出羊相!”</p>\n<h3 id=\"8、无利润投资\"><a href=\"#8、无利润投资\" class=\"headerlink\" title=\"8、无利润投资\"></a>8、无利润投资</h3><p>“请举例说明，什么叫无利润投资。”经济学教授提问。“带自己的妹妹出去玩。”一个男学生答道。</p>\n<h3 id=\"9、博弈论\"><a href=\"#9、博弈论\" class=\"headerlink\" title=\"9、博弈论\"></a>9、博弈论</h3><p>如四个男生都去追一个漂亮女生，那她一定会摆足架子，谁也不搭理。这时男生再去追别的女孩，别人也不会接受，因为没人愿当次品。但是，如果他们四个先追其她女生，那个漂亮女孩就会被孤立，这时再追她就简单多了。——数学大师纳什关于博弈论最简单表述。</p>\n<h3 id=\"10、没有免费的午餐\"><a href=\"#10、没有免费的午餐\" class=\"headerlink\" title=\"10、没有免费的午餐\"></a>10、没有免费的午餐</h3><p>这句话最早由经济学大师弗里德曼提出来。它的本义是即使你不用付钱吃饭，可你还是要付出代价的。因为你吃这顿饭的时间，可以用来做其他事情，比如谈一笔100万的生意，你把时间用于吃这顿饭，就失去了这些本来能有的价值。这是机会成本的概念，以前你知道吗?</p>\n<h3 id=\"11、商业模式\"><a href=\"#11、商业模式\" class=\"headerlink\" title=\"11、商业模式\"></a>11、商业模式</h3><p>少妇报案：“我把钱放在胸衣内，在拥挤的地铁内被一帅哥偷走了…”警察纳闷：“这么敏感的地方你就没觉察到？”少妇红着脸答：“谁能想到他是摸钱呢？”<br>评论：让客户的钱在愉快体验中不知不觉地被摸走，是商业模式的最高境界。</p>\n<h3 id=\"12、分享经济学\"><a href=\"#12、分享经济学\" class=\"headerlink\" title=\"12、分享经济学\"></a>12、分享经济学</h3><p>如果你有6个苹果，请不要都吃掉，因为这样你只吃到一种苹果味道。若把其中5个分给别人，你将获得其他五个人的友情和好感，将来你会得到更多，当别人有了其它水果时，也会和你分享。人一定要学会用你拥有的东西去换取对你来说更加重要和丰富的东西。放弃是一种智慧，分享是一种美德。</p>\n<h3 id=\"13、择偶观\"><a href=\"#13、择偶观\" class=\"headerlink\" title=\"13、择偶观\"></a>13、择偶观</h3><p>假如把男人、女人分为ABCD四种优秀程度，那现在的现状就是，A男想找B女，B男想找C女，C男找D女，所以D男就剩了。反之，女人方面却不同，即是，ABCD女都想找A男。最后结果是剩下A女和D男。<br>经济学里有个案例：两个人在森林里遇到一只熊，那么对手不会是熊!只要比另一个人快一步就胜利。</p>\n<h3 id=\"14、帕累托分布\"><a href=\"#14、帕累托分布\" class=\"headerlink\" title=\"14、帕累托分布\"></a>14、帕累托分布</h3><p>把全世界每个人拥有的财富从大到小排起来，一边是一个纤细但高耸入云的头，另一边是漫长的一望无际，低矮的让人绝望的尾。这样的分布在经济学里被冠名为“帕累托分布”。</p>\n<h3 id=\"15、穷人税\"><a href=\"#15、穷人税\" class=\"headerlink\" title=\"15、穷人税\"></a>15、穷人税</h3><p>最典型的是买彩票的人大多都是穷人(经常买彩票的人请不要介意)，这是他们承受能力和支付能力范围以内能够实现财富剧增的少有机会，但中奖毕竟是小概率，长期以往，细水长流(不过是往外流)，出得多、进得少，就权当缴税了。</p>\n<h3 id=\"16、幸福公式\"><a href=\"#16、幸福公式\" class=\"headerlink\" title=\"16、幸福公式\"></a>16、幸福公式</h3><p>经济学中有个公式：幸福=效用÷期望值。如果您男友发奖金，拿到1000块，可您期望他给自己买10000块的LV包，1000除以10000，幸福感只有0.1。但如果您的期望是让男友请自己吃顿200块的西餐，1000除以200，幸福感是5。<br>要获得爱情中的幸福，最好不要让欲望影响您的生活。</p>\n<h3 id=\"17、快乐VS痛苦\"><a href=\"#17、快乐VS痛苦\" class=\"headerlink\" title=\"17、快乐VS痛苦\"></a>17、快乐VS痛苦</h3><p>一次捡75元，和先捡50后捡25，选哪个?一次丢75元，和先丢50再丢25，选哪个？实验证明，绝大多数人选分开捡75元，一起丢75元。<br>这就是经济学的快乐痛苦的原则：n个好消息要分开发布；n个坏消息要一起发布；一个大的坏消息和一个小的好消息，分别公布；一个大的好消息和一个小的坏消息，一起公布。</p>\n<h3 id=\"18、泡沫经济\"><a href=\"#18、泡沫经济\" class=\"headerlink\" title=\"18、泡沫经济\"></a>18、泡沫经济</h3><p>当您决定上网聊天，这叫创业；上来一看MM真多，这叫市场潜力大；但GG也不少，这叫竞争激烈；您决定吸引美女眼球，这叫定位；您说您又帅又有钱，这叫炒作；您问“谁想和我聊天”，这叫广告；您又问“有美女吗”，这叫市场调查；有200人同时答“我是美女”，这叫“泡沫经济”。</p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"生活无处不编程","url":"/2019/08/22/thinking/note-life-is-programmed-everywhere/","content":"<p>有人说编程很难，但笔者觉得编程（准确地说应该是“软件工程”）中的很多思想，与生活中的事例异曲同工。本文将从生活中点滴小事来阐述编程中用到的思想。<br><a id=\"more\"></a></p>\n<ul>\n<li>IaaS：基础设施服务，Infrastructure as a service。假如你要打算做披萨生意。你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。基础设施服务，就是他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。</li>\n<li>PaaS：平台服务，Platform as a service。除了基础设施，他人还提供披萨饼皮。你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。</li>\n<li>SaaS：软件服务，Software as a service。他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。</li>\n<li>BaaS：后端即服务，Backend as a Service。他人把后厨包了，你前台需要什么直接告诉后厨再稍等一下就可以了。</li>\n<li>FaaS：函数即服务，Function as a Service。</li>\n<li>容错：（fault tolerance）指的是， 发生故障时，系统还能继续运行。飞机有四个引擎，如果一个引擎坏了，剩下三个引擎，还能继续飞，这就是&quot;容错&quot;。同样的，汽车的一个轮子扎破了，剩下三个轮子，也还是勉强能行驶。容错的目的是，发生故障时，系统的运行水平可能有所下降，但是依然可用，不会完全失败。<strong>（发生故障时，如何让系统继续运行。异常控制）</strong></li>\n<li>高可用：（high availability）指的是， 系统能够比正常时间更久地保持一定的运行水平。汽车的备胎就是一个高可用的例子。如果没有备胎，轮胎坏了，车就开不久了。备胎延长了汽车行驶的可用时间。注意，高可用不是指系统不中断（那是容错能力），而是指一旦中断能够快速恢复，即中断必须是短暂的。如果需要很长时间才能恢复可用性，就不叫高可用了。上面例子中，更换备胎就必须停车，但只要装上去，就能回到行驶状态。<strong>（系统中断时，如何尽快恢复。模块化、版本控制）</strong></li>\n<li>灾备：（又称灾难恢复，disaster recovery）指的是， 发生灾难时恢复业务的能力。飞机是你的 IT 基础设施，飞行员是你的业务，飞行员弹射装置就是灾备措施。一旦飞机即将坠毁，你的基础设施就要没了，灾备可以让你的业务幸存下来。灾备的目的就是，保存系统的核心部分。一个好的灾备方案，就是从失败的基础设施中获取企业最宝贵的数据，然后在新的基础设施上恢复它们。注意，灾备不是为了挽救基础设置，而是为了挽救业务。<strong>（系统毁灭时，如何抢救数据。备份、镜像）</strong></li>\n<li>云计算：王坚院士说过，云计算就是自来水供水系统，用管道把水送到千家万户。打开就用，不用就关。把计算资源抽象成粒度可控的对象，随意取用。</li>\n</ul>\n","categories":["thinking"],"tags":["thinking"]},{"title":"最有效的五步推销法","url":"/2018/11/28/thinking/note-most-effective-sales-promotion/","content":"<p>很多场合，我们需要说服别人。比如，说服客户购买产品，说服风投投钱。<br>如果你只有一次 PPT 演讲的机会，怎么才有最大的说服力？<br><a id=\"more\"></a></p>\n<p>今天，我读到一篇文章，作者是美国的一个企业咨询专家，介绍他见过的最有效的 PPT，总结了其中的模式。我觉得太实用了，一定要做一下笔记。</p>\n<h3 id=\"第一步，提出一个当今世界的变化趋势\"><a href=\"#第一步，提出一个当今世界的变化趋势\" class=\"headerlink\" title=\"第一步，提出一个当今世界的变化趋势\"></a>第一步，提出一个当今世界的变化趋势</h3><p>不要首先谈论你的产品、你的顾客、你的投资者等等，任何你自己的事情都不要首先谈。第一件事是要介绍世界的趋势。</p>\n<p>你要以一种显而易见的、不可否认的、正在发生的世界趋势来开场。这种趋势跟你的产品必须是相关的，可以为你的产品带来重大利益，或者使得你的产品具有重大的急迫性。</p>\n<p>你要让对方意识到，这种趋势会影响到他们。如果正确反应的话，他们就能获得机会。</p>\n<p>开场即使不能打动听众，也要获取他们的注意力，让他们愿意听你讲下去。注意力是最关键的。</p>\n<h3 id=\"第二步，提出会有赢家和输家\"><a href=\"#第二步，提出会有赢家和输家\" class=\"headerlink\" title=\"第二步，提出会有赢家和输家\"></a>第二步，提出会有赢家和输家</h3><p>即使对方从上面的趋势看到了机会，但是如果同时需要承担巨大风险，他们很可能会选择维持现状。</p>\n<p>为了克服这种&quot;风险厌恶&quot;，你需要明确提出，这种趋势会带来大赢家和大输家。如果顺应变化，前景一片光明；如果抵抗变化，前景一片灰暗。也就是说，你要给对方提供巨大的诱因，让他们愿意参与变化。如果保持现状，他们可能会有巨大损失。</p>\n<h3 id=\"第三步，描绘美好的未来\"><a href=\"#第三步，描绘美好的未来\" class=\"headerlink\" title=\"第三步，描绘美好的未来\"></a>第三步，描绘美好的未来</h3><p>到了这个时候，你大概已经忍不住要推销自己产品了。但是，还没到时候，你需要再忍一下。如果太快引入产品，跟前面好不容易营造的上下文可能脱节，对方感到突兀的话，就前功尽弃了。</p>\n<p>这时，你要做的是，描绘使用你的产品之后的美好未来，但不要提到你的产品。比如，你可以说&quot;如果发生 xxx 的改变，我们的社会就会出现 xxx 的情景&quot;。你描绘的未来应该非常诱人，同时也应该是很难达到的，否则你的产品就没有存在的理由了。</p>\n<h3 id=\"第四步，介绍克服困难、到达未来所需要的那个关键步骤\"><a href=\"#第四步，介绍克服困难、到达未来所需要的那个关键步骤\" class=\"headerlink\" title=\"第四步，介绍克服困难、到达未来所需要的那个关键步骤\"></a>第四步，介绍克服困难、到达未来所需要的那个关键步骤</h3><p>最成功的推销方法，很像英雄电影或者童话故事。主角达成目标之前，总是需要学会某种技能，或者获得某种宝物。你这时要介绍的，就是那种技能或宝物。</p>\n<p>正是因为有了前面那些上下文，你才能在这个部分谈一些细节，否则那些细节就会变得相当乏味和无趣。你这时可以详细解释，为什么传统方法无法达到美好的未来，新的方法如何克服现存的困难。</p>\n<h3 id=\"第五步，提出证据，你能让这一切变成现实\"><a href=\"#第五步，提出证据，你能让这一切变成现实\" class=\"headerlink\" title=\"第五步，提出证据，你能让这一切变成现实\"></a>第五步，提出证据，你能让这一切变成现实</h3><p>既然你已经描述了未来，现在是时候告诉大家，怎样才能到达那里，也就是你的产品跟这一切到底有何相关。</p>\n<p>因为前面你已经说了到达那里很困难，所以听众对于你的能力是有怀疑的。你必须举出证据，让人相信你能让这一切成真。</p>\n<p>最好的证据莫过于举出一个例子，你已经帮助其他人成功了。如果你还没有成功案例，那可以演示一下产品，演示的重点应该是如何达到你描述的未来。</p>\n<p>说服对方，一般很难只靠一次推销演讲。但是，如果你按照上面的结构来做推销，会使得你的机会最大化。</p>\n<p>（完）</p>\n<p>转自阮一峰博客，<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMTEvbW9zdC1lZmZlY3RpdmUtc2FsZXMtcHJvbW90aW9uLmh0bWw=\">文章链接<i class=\"fa fa-external-link-alt\"></i></span></p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"我们相隔的不仅是时间，还有渐行渐远的价值观（转）","url":"/2011/08/18/thinking/note-separated-not-only-by-time/","content":"<p>今天有点不开心，一个群里因为一些事，彼此熟悉的人吵了起来，我只能沉默。沉默是我对这类事情唯一的能做的事。现在通讯发达了，想了解一个人的基本价值观，通过微信群，朋友圈都可以。只要你发言了，转发了，就可以窥探到你的世界。而这种窥探，其实让人很难受，一些熟人、朋友的价值观让你大跌眼镜，但你还什么都不能说。也没有必要说。只能感叹下，原来我们如此陌生。<br><a id=\"more\"></a></p>\n<h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1.\"></a>1.</h3><p>有一次，我在朋友圈看到从小认识的一位朋友的言论，真把我恶心住了，我想在下面评论，又怕引起不必要的争论，就只能把那段话截图给知道价值观还相近的同学看看，然后发了一通牢骚。最后还是实在没忍住，在朋友圈写了这么一段话：“相隔的不仅是岁月，还有渐行渐远的价值观。从年少到现在还能保持三观一致太难太难了。相忘于江湖，才是最好的结局。”有人以为是同学聚会后的感言，其实不是，聚会一般只聊过去，只喝酒，只谈青春，而在朋友圈，在微信群，在QQ群，才能把这些基本的观点暴露。</p>\n<p>没过几天，一位朋友就说，这段话，她借用了。随后，她和我说，她用了一个美国品牌的杯子，在朋友圈发了张图，而被一位曾经要好的同学用民族大义教育了一番，感觉非常难受，干脆直接把好友都删除。而这同学，在整个中学期间关系都还不错。可能一起上厕所，一起学习，相互鼓励。这些曾经的温情，都被这一番民族大义式的言论给毁掉了。</p>\n<p>那一刻，巨大的悲哀笼罩了我，我们这地方有多少思维都不正常的人类。</p>\n<p>年岁渐长，已经没有说教别人的欲望，也不想被别人说教。我们从一个原点出发，已经走向不同的方向。那就彼此相忘于江湖吧。</p>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2.\"></a>2.</h3><p>这是个巨大裂痕的社会。不是多元，而是裂痕。我们连基本的价值观都没有，怎么会有统一的共识？普世价值都能否定的地方，有什么不能被否定。我想说的是，随着时间流逝，相互之间的裂痕太大太大了。如果你有一个三十多年还保持着三观一致的朋友，请你珍惜，这是上辈子修来的福分。更多的是，我们彼此已经不再了解，价值观也已经完全改变。</p>\n<p>新闻联播是很多人的饭前甜点，而我一年也看不了一个画面。很多人教科书上的内容，就是他们的全部知识，而我就算最无聊的时候，也会保持着一个月两三本书的阅读量，多的时候一周可能三四本。我对权力和管教他人一点欲望都没有，而权力是多少人的梦想。</p>\n<p>方舟子和韩寒之争让多少好朋友分裂，而争吵王宝强和马蓉之间谁是谁非，让一对夫妻离婚了。到底是支持日货还是抵制日货，让多少人智商暴露了，而我一直坚决抵制的是蠢货，从来不是外国货。南海战争到底打不打。朝鲜战争到底是不是正义。爱国家还是爱政府，这两者到底有什么样的区别等等等。可能任何一个话题都可以让你和许多人产生强烈的分歧。有些分歧可能谈谈就过了，而有些分歧，可能让你难以释怀。有些，我们干脆就不交流吧。</p>\n<p>我们学着不同的历史，从许多事件的看法自然完全不同，甚至对人本身的看法都不同。</p>\n<p>我们在分裂。这种分裂随着时间推移会越来越大。</p>\n<p>有一次，在同学群里，看到某个明显是谣言的言论，我实在忍不住，说了一堆个人的观点，发出去之后，虽然有人认同，但彻底把发言的同学得罪了，然后就渐渐陌生了，从那以后，每次遇上热点话题，我几乎都沉默。</p>\n<p>越熟悉越如此。熟悉，并不代表了解。只是时间把你更早的推到我前面。</p>\n<p>我们唯一的相似点可能就是对故乡美食的热爱，性取向可能都不同了。</p>\n<p>我们相隔的不仅是几十年的时间，还有渐行渐远的价值观。</p>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3.\"></a>3.</h3><p>所以感谢城市。这个包容的城市，会让你总会寻找到和你相似的人，相似的灵魂总会相遇。而不至于让自己无话可说。我们不需要对不懂的人说太多，而懂你的人，自然你说一个词就会明白。这里总能找到和你价值观相似的人。</p>\n<p>我们可以找喜欢诗歌的人聊诗歌，找喜欢打球的人聊打球，和工作的人聊工作，和八卦的人聊八卦，和有着过去的人聊过去。总能找到和你兴趣相同的人。</p>\n<blockquote>\n<p>“一堆堆人头走向远方。我在他们中间缩小。没人看到我。但在仍然/活着的书里，在儿童的游戏我将从死者中/升起来，太阳在照耀。”（曼德尔施塔姆《积聚如山的人头走向远方》）</p>\n</blockquote>\n<p>越来越觉得没有辩驳的必要了，越来越抗拒一些言论，越来越觉得在人群中独立多好。</p>\n<p>以前可能还会因为某个观点而在熟人圈里，说上那么几句，现在发现完全是多余的。因为一个人成长过程已经接受完了教育，而你现在所说的，只不过是你所受教育的一部分，他人并不一定需要你这些。</p>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h3><p>时间会让我们遇见谁，而你的心决定谁将留下。</p>\n<p>十年不见，我们聊点什么。</p>\n<p>还是谈谈我们曾经的青春吧。</p>\n<p>思想就像内裤，别轻易露出来。</p>\n<p>只有知根知底了，我们才开始讨论深一点的话题。</p>\n<p>现在我们就聊聊曾经，聊聊彼此熟悉的人。</p>\n<blockquote>\n<p>“忠实的老友，伸出你的手，<br>让我们握手聚一堂，<br>再来痛饮一杯欢乐酒，<br>为了往昔的时光！”<br>（罗伯特·彭斯《往昔时光》）</p>\n</blockquote>\n<p>来，我们为往昔干杯，然后别谈未来。</p>\n<p>愿你出走多年，归来还是少年。最近流行这么一句话。那是多么艰难。少年时期的那种梦想，活力，没受沾染世俗的清澈，那种蔑视日常的勇气，有多少人能够保持？</p>\n<p>我宁愿相信，无论你表达什么样的价值观，都还是真诚善良。只是眼界会局限一个人，这个勉强不了。在旧时光里，会有你美好的一面。而未来，愿你安康，善良。</p>\n<p>其实价值观，只是一种调剂，并不影响一个人日常生活，不影响你在生活里是一位好父亲好儿子好丈夫，就像没有阅读也可以活着，没有精神也可以在黑压压的人群中走过。在拥挤的地铁里和公交上，谁会在意你的思想。所以，十年不见，我还渴望遇见你。因为，可能价值观不同，但我们有着彼此的过去。</p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"请警惕你的“弱者思维”(转)","url":"/2014/08/18/thinking/note-weak-thinking/","content":"<p>年纪越大，看的人越多，经历事情越多，越坚定这么一个观点——造成人与人之间差距的，真的就不是差在钱上，而一定是差在思维上。<br><a id=\"more\"></a><br>有些人说我这是站着说话不腰疼。其实只有穷人才觉得，“有钱了就什么都有了”——这个真是扯淡。思维没跟上，即使中了彩票几千万，也会马上败光，更别提什么财富增值的可能。</p>\n<p>很多人事业起不来，财富无法实现大的增长，一般不是缺资金，更可能是缺思维。</p>\n<p>现在和一些人聊天，只要看他思考问题的角度，看待事情的方式，一般就能判断出这个人未来行不行，或者说现在混的这么好就是有原因的。有些人说性格决定命运，我倒更倾向于认为是思维决定命运。有些人即使现在事业没起来，可能只是缺少一个风口和平台，但是你知道ta的insight很强，只要风口一开，必成大器；而另一些人，ta混成现在这个迷茫的样子，其实就是注定的，而且可悲的是，知道未来也不会有太大的起色。</p>\n<p>这两年自己的成长过程中，最大的财富，真不是银行存款的数字，那只代表过去的财富；而自己的思维方式，思考体系，比以前高了几个维度，这个自己是有感觉的。这种思维的升级，来自于自己看更大世界带来的更高眼界，来自于和各个领域牛人的交流碰撞启发，来自于自己平台和圈层升级后的思维迭代。</p>\n<p>这才是最安心和踏实的。知道哪怕现在一无所有，也可以凭这个东山再起。</p>\n<p>所以有些人职场上起不来，不是弱在看得见的行动力上，而是弱在一种虚的东西，我称之为：弱者思维。</p>\n<p>今天想和大家分享下我认为的几种典型“弱者思维”。</p>\n<h4 id=\"1-对于自己不懂的新生事物，不是选择了解而是拒绝；然后找出拒绝的理由，证明自己正确。\"><a href=\"#1-对于自己不懂的新生事物，不是选择了解而是拒绝；然后找出拒绝的理由，证明自己正确。\" class=\"headerlink\" title=\"1. 对于自己不懂的新生事物，不是选择了解而是拒绝；然后找出拒绝的理由，证明自己正确。\"></a>1. 对于自己不懂的新生事物，不是选择了解而是拒绝；然后找出拒绝的理由，证明自己正确。</h4><p>举个例子，比如这两年直播比较火，争议也比较大。</p>\n<p>如果你问一些人对于直播怎么看，首先，他们自己没尝试过直播，然后就会根据自己得到的二手信息判断说：直播，不就是一帮整容过的网红脸在镜头前露胸露腿么，说些毫无营养的话，太low了。</p>\n<p>确实，这是直播的1.0版本，也是野蛮生长的阶段，但是未来的直播，从美女网红向各领域KOL扩展，一定会走向大众化、垂直化和专业化。你都不了解，就直接否定这个现象，就等于否定了未来的可能性和你的参与度。等到有一天你身边的某个朋友在直播红利期迅速圈粉成为KOL的时候，你方才醒悟和惊呼——但是，你太晚了。</p>\n<p>而你看另一些大咖们，他们对于陌生领域或新生事物的判断，从来就是谨慎但乐观，喜欢亲自体验。罗振宇当直播出来的时候，一个四十多岁没有颜值的胖子，跟着一帮美女主播同一平台，乐呵呵地做着直播，经常插一句“谢谢XX送的保时捷”，多搞笑，多和谐。</p>\n<p>我现在基本上能做到，当我完全无法理解一个新生事物的时候，我第一反应不是用我传统的观念去质疑，而是保持像小孩子一样的好奇心，去了解，去发现，去找到存在必定合理的逻辑。</p>\n<p>这样，你就有可能比大多数人，更快一步找到风口，更早一步采取行动。</p>\n<p>而弱者思维的人，永远都只能活在现在，而无法拥有未来。因为陌生的未来才是现在，而你熟悉的现在，已经成为过去。</p>\n<p>弱者思维不仅反对新生事物，更要命的是，他会找出一堆二手理由，去否定他，以满足自己的天然正确。这个其实更可怕。</p>\n<p>比如别人的突然成功，你不认为是背后的努力和眼光，而认为是运气或巧合，表示不屑，觉得“我也可以，只是我没那么做”——这是弱者思维。</p>\n<p>当新生事物和大脑原有的思维产生冲突，做否定的结论实在太容易了，意味着大脑可以不走出舒适区，还是可以惬意地走原来的路；但是如果新鲜事儿和原来的认知冲突，你试图说服自己否定自己的话，不仅打击自信，还要以一种烧脑的方式去探究，太累了，太辛苦了。</p>\n<p>所以，对新生事物的否定，本质上是源于内心的自卑和脆弱，因为弱，所以需要去保护，需要去捍卫。简称，自我麻痹，自我开脱。</p>\n<p>所以弱者思维的人，很有可能一辈子注定翻不了身，因为不是缺钱缺机会，而是缺更大的包容胸怀，和格局。</p>\n<h4 id=\"2-希望轻松得到，而不愿付出代价\"><a href=\"#2-希望轻松得到，而不愿付出代价\" class=\"headerlink\" title=\"2. 希望轻松得到，而不愿付出代价\"></a>2. 希望轻松得到，而不愿付出代价</h4><p>希望不用花什么成本，最好免费得到一样好东西，是典型的弱者思维。</p>\n<p>因为贪小便宜的心理害死人。</p>\n<p>不妨自黑一下，去年我就一直嚷嚷着要减肥，要健身，要瘦成一道闪电，结果一直没有成功，而且在健身房因为姿势不对，造成了一些运动损伤。今年我请了一个私教，真不便宜，800块港币一小时，他就很专业地分析了我身体肌肉和骨骼的一些问题，告诉我之前训练的方式方法不仅没有帮助，反而有可能伤害身体，并给我做了一对一的健身计划。</p>\n<p>但是我当时贪便宜呀，觉得私教太贵了，想省钱啊，觉得自己看看Youtube的视频就差不多了呀，下载个健身软件在家练就可以了呀。</p>\n<p>贪便宜确实能省钱，但牺牲了更大的时间成本和机会成本，其实更不划算。</p>\n<p>同样20分钟，如果你用来集赞换红包的话，是不是就意味着放弃了把这20分钟用于成长提升的机会？</p>\n<p>别跟我说20分钟得不到突破，万一你用这20分钟录制了一段“蓝瘦，香菇”的视频发到网上，第二天早上就红了呢？</p>\n<p>听说蓝瘦香菇哥前些日子都结婚了啊。人家已经娶到那个“第一次为一个女孩子这么想哭”的女孩子了，好么。</p>\n<p>别跟我说“万一”才不会轮到自己。你知道买彩票的人除了助力了社会福利事业，还有啥别的值得尊敬的地方吗？那就是，别人至少舍得投资那回报未知的几块钱。</p>\n<p>而你不舍得，只会骂别人异想天开好吃懒做。</p>\n<p>当然，这里要把那些视彩票为人生唯一出路的投机者除外。</p>\n<p>你永远要相信，好东西一定不便宜。互联网最大的好处在于，一样好东西因为可以被N人购买，从而降低了每一个人的成本，但低成本并不表示没有成本。</p>\n<p>我们要知道，如果2017年以前好东西还能以免费的方式给到大家，是因为它需要获取流量和用户，那么今年开始，当移动互联网通路已经铺成，好的东西一定会收费。因为收费才体现价值对等，免费永远是不正常的。</p>\n<p>就像前两年的专车市场补贴大战，大家好像可以花很少的钱就拥有更好的出行服务，但是现在价格又上来了，其实不是价格更贵了，而是市场回归理性了。</p>\n<p>其实贪小便宜的这种思维方式，本质上也印证了一个人的性格，是属于“索取型人格”，还是“付出型人格”。</p>\n<p>弱者一般都是索取型人格，因为害怕失去，希望得到更多，便不断攫取；而强者一般是付出型人格，知道自己精神的富有，更包容，更懂感恩——更愿意创造些新东西给别人，世界便逐渐转移到他们手上。</p>\n<p>而哪一种人更受欢迎，更容易让大家愿意帮助他成功，大家心里都有数。所以到最后，强者愈强，弱者愈弱。</p>\n<p>其实弱者思维还有一些典型症状，篇幅有限，这次先写个上篇，下篇留着下次再表。</p>\n<p>别总把时间花在抱怨“我好迷茫”上或者求助“下个风口在哪里了”，其实风口一直都在，一直在呼呼地吹，只是你自己的思维屏障，人为挡住了吹向你的大风。</p>\n<p>所以，与其羡慕外面的可能，不如先改变思维方式吧。</p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"最大的财富是智慧：由犹太人卖铜的故事说起","url":"/2021/09/13/thinking/the-greatest-wealth-is-wisdom/","content":"<p>《孟子·滕文公上》曰：“或劳心，或劳力。劳心者治人，劳力者治于人。治于人者食人，治人者食于人：天下之通义也。”意思是说：“脑力劳动者统治人，体力劳动者被人统治；被统治者养活别人，统治者靠别人养活。”<br><a id=\"more\"></a></p>\n<p>据说，多年以前，有对父子被关进集中营，当时，犹太人所有的家当都被纳粹没收了。爸爸对儿子说：“现在，我们唯一的财富就是我们的脑袋，记住，当别人说一加一等于二的时候，你应该想到让它大于二的方法。”</p>\n<p>数百万犹太人死于集中营，父子俩凭意志力活下来。后来他们来到美国，白手起家，在休斯敦做起铜器生意。</p>\n<p>有天，爸爸问儿子：“你知道一磅铜的价格多少钱吗？”儿子很精确地回答：“三十五分钱。”爸爸说：“这不是我要的答案。整个德州的人都知道，每磅铜的价格是三十五分钱，你身为犹太人的儿子，应该说，一磅铜是三块五美元。试着把一磅铜做成门把看看吧。”</p>\n<p>许多年过去了，父亲去世后，儿子一样经营铜器生意。他不只把铜做成门把，也做成瑞士钟表上的簧片和奥运奖牌，一磅铜曾被他卖到三千五百美元。这个时候，他已经是一家铜器公司的董事长了。</p>\n<p>他始终奉行着父亲的教诲。真正使他“点石成金”的，是纽约的一堆垃圾。1974年，美国政府为清理自由女神像翻新所造成的废料招标，但因为纽约的垃圾处理环保规定非常严格，弄不好就会被起诉倾家荡产，好几个月过去了，没人投标。这位董事长听说此事之后，立即飞往纽约，看着自由女神下堆积如山的铜块、螺丝和木料后，当场与州政府签了处理废弃物的合约。</p>\n<p>许多运输公司等着看他笑话，都认为承包这个生意，吃力不讨好。不过，犹太人立即着手组织进行废料分类：<strong>把废铜料熔化，铸成小自由女神、把水泥块和木头加工成底座、把废铅、废铝做成纽约广场的钥匙</strong>——最精彩的是，他一丁点废料也不浪费，甚至把从自由女神身上扫下的灰包装起来出售给花店，称之为“自由之尘”。几个月的时间，他让这堆废料变成了超过三百五十万的美元现金。</p>\n","categories":["thinking"],"tags":["note"]},{"title":"那些让我深思的话","url":"/2016/02/28/thinking/the-words-which-make-us-think-deeply/","content":"<p>本文搜集一些令人深思的话，时常回来看看。<br><a id=\"more\"></a></p>\n<p>如果有人在电话里说有害的言论，你不会让电话公司负责。我们也应该这样对待网站。——马克·扎克伯格</p>\n<p>我们都知道，如果可以回到过去，改变任何一件小事情，都将极大地改变未来。然而，几乎没有人想到，今天只要小小改变，就会改变自己的未来。<br>——BenSassiAladin@Twitter</p>\n<p>我口袋里有一个小设备，可以访问几乎全部的人类知识。我却用它与不认识的人进行毫无意义的争论，并看猫的照片。——HN 读者</p>\n<p>不要构建系统，而要构建子系统。这就像 Unix 哲学：每个工具做好一件事，不同的工具协同工作。——Jessitron</p>\n<p>推出一个新产品很难，组建一个能够持续推出新产品的团队更难。我最引以为傲的产品，就是苹果公司和我在苹果公司建立的团队。——史蒂夫·乔布斯</p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"何谓“人各有志”","url":"/2016/04/23/thinking/what-is-rengeyouzhi/","content":"<p>人生就是一条路，会遇到很多分叉口。每个人都会选择自己认为正确的一条，继续往前走。再选择再走，再选择再走。直至生命终点。<br><a id=\"more\"></a><br>人各有志，本意是每个人都有自己心中的志向，其他人不应该说三道四。</p>\n<p>今天突然对这个词有了新的想法，说出来，请大家一起讨论。</p>\n<p>人往高处走，水往低处流。一个有进取心的人，他的志向肯定是向上的。肯定是顺应社会趋势的。也应该是实现最大化人生价值的。</p>\n<p>如果你说北京瘫，吃西瓜，吹空调看电视，整天无所事事，也是一种志向的话，那这篇文章你就不用看了。</p>\n<p>人最初的志向肯定是依照自己的事业、能力和见解，对这个社会有一个认知之后形成的一个理想、一个行动指南。</p>\n<p>但这种理想，这种行动指南，应该是随着年龄的增长、阅历的增加，对社会的理解程度而发生变化的。但他抽象的、总体的方向，是不应该经常发生变化的。</p>\n<p>它应该是你的价值观在你的行动上的真实反映。如果你的价值观是扭曲的，那么你的行动肯定也是扭曲的。</p>\n<p>因此，一个人的志向在不同的时期，不同的人生阶段，应该是不一样的。这里的不一样，是指战术上的不一样，而不是战略上的不一样。</p>\n<p>周恩来总理小时候说，为中华之崛起而读书。这个志向贯穿了他的一生，这是战略上的，从来没有变过。</p>\n<p>一个人的志向应该是平时经常思索的、深深植根于脑海的。</p>\n<p>如果我问到你，你会第一时间脱口而出的这种志向。如果你还要花三分钟时间去想的话，那说明你大概率没有志向。</p>\n<p>如果你的志向从小到老，从来没有变过。同时在你有行动力的中年时期，你的工作与你的志向背道而驰。或者毫不相关，那说明你从来没有为志向付出过什么。</p>\n<p>一个人去追逐自己的志向，应该是这样的一个过程：年轻时，努力提高自己的思想水平，思考并确立自己的志向，并不断向此方向储备知识、人脉等各种资源；壮年和中年甚至老年时，对世界的认识愈加深刻，自己的世界观肯定会发生变化，也肯定会修正自己的志向，修正自己的行动。但大的方向不会发生大的变化。</p>\n<p>如果你根本没有一个长远的计划，根本不知道自己要走向何方，那么你肯定会随波逐流，蹉跎人生。</p>\n<p>人生就是一条路，会遇到很多分叉口。每个人都会选择自己认为正确的一条，继续往前走。再选择再走，再选择再走。直至生命终点。</p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"发刊词|智能时代的行动指南","url":"/2017/11/26/thinking/google-methodology-20171126/","content":"<p>这是一封来自智能时代战略最前沿的信。<br><a id=\"more\"></a></p>\n<p>2016年，Google 的围棋程序 AlphaGo 和李世石对弈之前，围棋的国手们称呼它为阿尔法狗。在此之后，则称呼它为“阿老师”。从狗到老师的变化，仅仅隔了几个月。</p>\n<p>在高看机器智能一眼的同时，大家开始恐慌，就连霍金这样的大科学家也不例外。我们不妨把这种恐慌叫做“21世纪的恐慌”。</p>\n<p>这多少和菲律宾的土著，在见到拿着洋枪洋炮的麦哲伦时的恐慌一样。但是，最终土著人发现，麦哲伦和他们一样，是人而不是神，甚至也会死，和他们不同的是，麦哲伦等人手里有洋枪洋炮。</p>\n<h3 id=\"所有人都面临着思维方式的升级\"><a href=\"#所有人都面临着思维方式的升级\" class=\"headerlink\" title=\"所有人都面临着思维方式的升级\"></a>所有人都面临着思维方式的升级</h3><p>未来的时代，又将是一个“洋枪洋炮”对“大刀长矛”的时代。</p>\n<p>在过去的十年里，传统行业在和经过 IT 改造后的行业竞争时，无一例外地败北。08年金融危机前，全世界市值前十的公司只有微软一家是 IT 企业。仅仅过去了十年，市值前十的公司中有六家是 IT 企业了。</p>\n<p>但是另一方面，世界上又有一些受益于这个时代的人，比如设计了 AlphaGo 深度学习系统架构的杰夫∙迪恩等人，更不用说马云了。</p>\n<p>他们和普通人有什么不同呢？简单地讲就是他们拿着洋枪洋炮，而普通人，都在使用大刀长矛。<br>这里面的武器，并非是计算机，而是思维方式。将这种思维方式用于工作和生活中，就是一种方法论。</p>\n<p>具体地讲，这是一种适应计算机的思维方式，和人本能的思维完全不同。</p>\n<p>还是以围棋的例子来说明。</p>\n<p>在人看来，围棋是什么？是棋道，是文化。但是在计算机看来，围棋是一道数学题。那么哪一种看法对呢？当然是后者。</p>\n<p>人之所以把它称为棋道和文化，说得不客气一点，是人太“笨”，根本算不清楚这道题。计算机当然没有主动思维，帮助它思维的是它背后的人。</p>\n<p>具体讲到 AlphaGo 这个团队，这个团队一开始依然保留了常人的很多思维，比如学围棋时觉得就应该使用人类高手对弈的棋谱。但最终他们发现，那些人类的棋谱反而教坏了计算机。不使用人类对弈数据的 AlphaGo 的升级版 AlphaGo Zero，反而比 AlphaGo 本身厉害得多。</p>\n<p>这就是思维方式的升级。</p>\n<h3 id=\"你需要更好的方法论来指导\"><a href=\"#你需要更好的方法论来指导\" class=\"headerlink\" title=\"你需要更好的方法论来指导\"></a>你需要更好的方法论来指导</h3><p>15年前，我加入 Google 公司时，公司还只有100多个工程师，连同我在内开发外国语（主要包括亚洲的中、日、韩语，简称 CJK，欧洲的法、意、德、西语，简称 FIGS）的工程师只有四个人。</p>\n<p>我们当时已经占了全世界搜索流量的70%（包括为雅虎提供服务），相比之下我们的竞争对手们，人数比我们多出一到两个数量级。而且，我们中间没有人懂得韩、法、意、西这四种语言。</p>\n<p>那么这个奇迹是如何创造的？显然不是靠拼人力，也并非我们的智力比别人高多少，而在于我们的方法和别人不同。</p>\n<p>人通常会把每一种语言的搜索问题看成是一个单独的问题，因为各种语言在形式上完全不同，然后从自己熟悉的语言开始，一个语言一个语言，一件事一件事地做。</p>\n<p>而我们则不同，我们直接面对所有的语言（当时我们处理了70种），找到语言的共性，也就是承载信息，然后从信息的数学基础出发，让机器同时完成所有事情。</p>\n<p>直到今天，Google 中、日、韩文搜索算法的主体依然是我当初设计的方法，而英、法、意、德、西语搜索中的构词法部分，依然是我们四人和辛格博士（Amit Singhal）共同设计的。它们依然比世界上其它任何搜索引擎都要好。</p>\n<p>今天，很多成功的企业、个人，有意无意地采用了这样的方法，也取得了惊人的成就。</p>\n<p>比如说，支付宝的被欺诈比例极低，比一般的银行交易，低两个数量级。</p>\n<p>这并非是因为传统银行没有资源，而在于它们的思维方式太落后——传统银行把每一个交易，每一个案子孤立地看待，这虽然符合常人的本能，但是效果却有限。</p>\n<p>而支付宝，从一开始就是网状的，并有意无意地在网络基础上变得“聪明”起来。要知道，人的智能是一个个体行为，而机器的智能在很大程度上来自于网络效应。</p>\n<p>但是，并非所有人、所有机构都能自觉地采用适合智能时代的思维方式和方法。</p>\n<p>由于受到过去环境以及生理上的限制，人在思维上存在先天不足。好在有一些人，他们的思维水平超出我们常人，他们善用现在的各种 IT 工具，能更快更好地达到目的。</p>\n<p>学习这些人的思维方式和方法，是在今后智能时代赢得胜利的唯一方式。</p>\n<p><strong>今后不论是从事什么行业，思维方式改进了，方法论先进了，境界提高了，在竞争中就是用洋枪洋炮在对付别人的大刀长矛。</strong></p>\n<p>我给这种方法论取了一个名字——<strong>Google 方法论</strong>。</p>\n<p>这倒不是因为它是 Google 发明的，也并非只存在于 Google 公司内部（虽然专栏内容里面很多例子来自于 Google 公司），而是 Google 在这方面做到了极致，是这种方法论的代表。</p>\n<p>在过去的十多年里，Google 能够长期稳健地发展，就是受益于具有比别人更好的方法论。</p>\n<h3 id=\"未来一年你将得到\"><a href=\"#未来一年你将得到\" class=\"headerlink\" title=\"未来一年你将得到\"></a>未来一年你将得到</h3><p>在接下来的一年里，我会以思维方式和方法论为主线，和你分享我对计算机世界、创新和文明、以及教育和人生的思考。目的只有一个，帮你掌握未来时代最强有力的方法论。<br>当然，讲方法论不能泛泛而谈，既要具体生动，又要结合我们日常的工作和生活，还要有具体行动的指南。未来一年，我会通过下面四个模块构建出完整的课程体系：</p>\n<ol>\n<li><p>Google的计算机思维<br>“21世纪的恐慌”的产生，是因为不了解计算机世界。所以，在未来的一年时间里，我会为你拆解计算机世界里的各种门道，帮你熟悉计算机的思维方式，掌握未来时代的洋枪洋炮。</p>\n</li>\n<li><p>改变人类的发明的逻辑<br>每一个重要的发明，都是人类最杰出的智慧和方法的凝聚，它们揭示了创新和创意的核心本质。未来一年，我还会为你梳理历史和当代那些改变了世界的发明， 帮你掌握背后的深层逻辑，提升应对挑战时的创造力。</p>\n</li>\n<li><p>世界一流的教育理念和学习方法<br>未来时代的竞争，是学习能力的竞争。掌握了有效的学习方法，在竞争中的优势就会更强。未来一年，我会详细向你介绍英美顶级学府的培养之道，帮你事半功倍地学习。</p>\n</li>\n<li><p>社会、职场中的人生智慧<br>在这个模块中，我会和你分享精英们精进和自我提升的诀窍，帮你站在前人的肩膀上，在未来的竞争中走得更远。</p>\n</li>\n</ol>\n<p>每个模块大致占到内容的四分之一，并在一年的时间中交替讲述。同时，我也会延续第一季的风格，在第二季专栏中 ，仍然采用来信的形式，和你分享我对智能时代的思考。</p>\n<p>接下来，就让我们直面“21世纪的恐慌”，掌握属于自己的“洋枪洋炮”。</p>\n<p>祝学有所成！</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"从知识图谱到图数据库","url":"/2019/01/07/ai/from-knowledge-graph-to-db/","content":"<p>说到人工智能技术，首先会联想到深度学习、机器学习技术；谈到人工智能应用，很可能会马上想起语音助理、自动驾驶等等。实际上，人工智能要在行业中得到应用的先决条件是首先要对行业建立起认知，只有理解了行业和场景，才能真正智能化。简单的说，就是要建立行业知识图谱，才能给行业AI方案。<br><a id=\"more\"></a><br>机器通过人工智能技术与用户的互动，从中获取数据、优化算法，更重要的是构建和完善知识图谱，认知和理解世界，进而服务于这个世界。</p>\n<p>那什么是知识图谱呢？</p>\n<h2 id=\"知识图谱\"><a href=\"#知识图谱\" class=\"headerlink\" title=\"知识图谱\"></a>知识图谱</h2><p>知识图谱本质上是语义网络的知识库，从实际应用的角度出发其实可以简单地把知识图谱理解成多关系图。</p>\n<p>那什么是多关系图呢？ 回忆在数据结构中的“图”。图是由节点和边来构成，通常用来描述某些事物之间的某种特定关系。图用点代表事物，用连接两点的边表示相应两个事物间具有某种关系，但这些图通常只包含一种类型的节点和边，在IOTA,物联网区块链？一文中就谈到了有向无环图。多关系图一般包含多种类型的节点和多种类型的边。 图的数学基础是图论，本身是应用数学的一部分，在往下大概要涉及到拓扑学的领域了。</p>\n<p>在知识图谱里，通常用“实体”来表达图里的节点、用“关系”来表达图里的“边”。实体指的是现实世界中的事物，关系则用来表达不同实体之间的某种联系，实体和关系也会拥有各自的属性。知识图谱的构建是后续应用的基础，而且构建的前提是需要把数据从不同的数据源中抽取出来。数据抽取的难点在于处理非结构化数据，这回涉及到NLP中的相关技术，例如实体命名识别、关系抽取、实体统一、指代消解等等。</p>\n<p>知识图谱工程本身还是业务为重心，以数据为中心。不要低估业务和数据的重要性。</p>\n<p>知识图谱最重要的核心在于对业务的理解以及对知识图谱本身的设计。要从业务逻辑出发，并且通过观察知识图谱的设计也很容易推测其背后业务的逻辑，而且设计时也要想好未来业务可能的变化。让知识图谱尽量轻量化、并决定哪些数据放在知识图谱，哪些数据不需要放在知识图谱，在于把知识图谱设计成小而轻的存储载体。</p>\n<p>知识图谱主要有两种存储方式：RDF和图数据库。它们之间的区别如下图所示。RDF一个重要的设计原则是数据的易发布以及共享，图数据库则把重点放在了高效的图查询和搜索上。其次，RDF以三元组的方式来存储数据而且不包含属性信息，但图数据库一般以属性图为基本的表示形式，所以实体和关系可以包含属性，这就意味着更容易表达现实的业务场景。</p>\n<p><img data-src=\"/images/from-knowledge-graph-to-db/1.jpg\" alt=\"\"></p>\n<p>那为什么要用图数据库呢？ 核心在于“关系”。</p>\n<h2 id=\"重新认识“关系”\"><a href=\"#重新认识“关系”\" class=\"headerlink\" title=\"重新认识“关系”\"></a>重新认识“关系”</h2><p>关系是指人与人之间，人与事物之间，事物与事物之间的相互联系。</p>\n<p>不同事物按着各种不同类型的关系而彼此联系在一起，例如，空间与时间的关系，整体与部分的关系，原因与结果的关系，内容与形式的关系以及遗传关系、函数相依关系、内部关系与外部关系等等。 数据结构中的关系指的是集合中元素之间的某种相关性。关系的运算包括集合的子，交，并，补等等。</p>\n<p>在数学中，相关关系是一种非确定的相互依存关系：</p>\n<ul>\n<li>按程度：完全相关、不完全相关和不相关</li>\n<li>按影响： 正相关和负相关</li>\n<li>按形式：线性相关和非线性相关</li>\n<li>按变量数目：单相关、复相关和偏相关</li>\n<li>......</li>\n</ul>\n<p>事物之间的关系也是复杂的、无限多样的。</p>\n<p>在现实生活中，每一个实体都和周围的其他实体有着千丝万缕的关系，这些关系里面所存储的信息甚至要大于实体本身的属性。</p>\n<p>但是数据库有很多，为什么需要图数据库呢？关系型数据库和众多的NoSQL为什么不能完全拥有知识图谱的构建呢？ </p>\n<h2 id=\"“关系”的数据库存储与表达\"><a href=\"#“关系”的数据库存储与表达\" class=\"headerlink\" title=\"“关系”的数据库存储与表达\"></a>“关系”的数据库存储与表达</h2><p>世界是由关系组成的，关系型数据库能够处理好关系吗？</p>\n<h3 id=\"关系型数据库\"><a href=\"#关系型数据库\" class=\"headerlink\" title=\"关系型数据库\"></a>关系型数据库</h3><p>传统的关系型数据库更注重刻画实体内部的属性，实体与实体之间的关系通常都是利用外键来实现，将所有的数据用竖立的堆栈表示，并且保持它们直接的关系，在求解关系的时候通常需要join操作，而join操作通常又是耗时的。常常被优化用于聚合数据，而非高度关联的数据。</p>\n<p>互联网尤其是移动互联网的爆发式增长本来就使得传统关系型数据库不堪重负，再加上诸如社交网络等应用对于关系的高需求，关系型数据库显得力不从心。</p>\n<p>从应用开发的角度上看，不增加关系型数据库复杂性就不能建模和存储数据和关系。随着关系数量和层次的增加，数据库尺寸的增加，性能降低。当增加新类型的数据和关系的时候，需要重新设计，增加了时间成本，这些导致传统数据库不适用于有实时价值的数据关系。</p>\n<p>既然这样，对于高度关联的数据存储与分析就需要求助于NoSQL了。</p>\n<h3 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h3><p>在NoSQL之于大数据一文中将NoSQL分为了4类：key-value，文档型，列存储和图数据库。</p>\n<p>Key-Value模型适合用于简单的数据或者列表。当数据之间不断交互关联时，实际上更需要一张图。文档型NoSQL用来管理文档。在传统的数据库中，信息被分割成离散的数据段，而在文档数据库中，文档是处理信息的基本单位。文档可以很长，可以很复杂，可以是无结构的，与字处理文档类似。一个文档相当于关系数据库中的一条记录。文档型NoSQL用文档进行层次划分，而自由的数据规划也很容易被表示成一颗树。成长为一张图的话，文档之间的关联需要更有代表性的数据结构来存储，列存储的NoSQL也是如此。</p>\n<p>从应用开发的角度看，这些NoSQL数据库不处理关系，没有数据结构建模或存储数据关系，没有查询结构支持些数据关系。而且，在应用中连接数据同样需要JOIN操作， 对事务没有 ACID 的支持。</p>\n<blockquote>\n<p>ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p>\n</blockquote>\n<p>因此，这三种 NoSQL 数据库也不适用于有实时价值的数据关系。</p>\n<p>图数据库终于登场，它作为重点描述数据之间关系的数据库应运而生，最适合处理关系，能够制作从简单到到复杂的数据结构且互相连接的数据。图数据库成为了NoSQL中非常重要的一部分。</p>\n<h2 id=\"图数据库\"><a href=\"#图数据库\" class=\"headerlink\" title=\"图数据库\"></a>图数据库</h2><p>图数据库是基于数学里图论的思想和算法而实现的高效处理复杂关系网络的数据库。图形数据库善于高效处理大量的、复杂的、互连的、多变的数据，计算效率远远高于传统的关系型数据库。</p>\n<p>图中每个节点代表一个对象，节点之间的连线代表对象之间的关系。节点可带标签，节点和关系都可以带若干属性。关系可以将节点组织成任意的结构，允许一张图被组织成一个列表，一棵树，一张地图，或者一个复杂的实体。这个实体本身也是由复杂的，关系高度关联的结构组成。</p>\n<p>以图数据库Neo4J为例，用 Cypher 创建节点和关系的示意如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE (:Person &#123; Name:“Abel Cao”&#125; )-[:Love]-&gt; (:Person &#123; Name:“Andy Cao”&#125; )</span><br></pre></td></tr></table></figure></p>\n<p>查询也很简单：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MATCH (:Person &#123; Name:“Abel Cao”&#125; ) -[:Love]-&gt; (:Person &#123; Name:“Andy Cao”&#125; )</span><br></pre></td></tr></table></figure><br>一个节点可以从单属性开始，成长为成千上亿，虽然会有一点点麻烦。从某种意义上讲，将数据用关系连接起来分布到不同节点上才是有意义的。对于通过某一给定的属性值来找到节点或者关系，对比遍历图查找，用索引将会更加高效。</p>\n<p>用图来存储数据，是最接近高性能的一种用于存储数据的数据结构方式之一。图数据库也有很多，常用且比较闻名的应该是Neo4j了。</p>\n<h3 id=\"图数据库中的Neo4j\"><a href=\"#图数据库中的Neo4j\" class=\"headerlink\" title=\"图数据库中的Neo4j\"></a>图数据库中的Neo4j</h3><p>图数据库中的 Neo4j 是专为数据关系而生的，模型维护容易，白板模型即物理模型，查询也较简单，表映射关系变成了图关系,使用较少的资源就可以获得较高的性能。</p>\n<p><img data-src=\"/images/from-knowledge-graph-to-db/2.jpg\" alt=\"用图来表示社交网络中人与人的关系\"></p>\n<p>用图来表示社交网络中人与人的关系</p>\n<p>实际上，Neo4j最适合一个完整的企业部署或者用于一个轻量级项目中服务器的一个子集，有以下几个显著特特性:</p>\n<h4 id=\"ACID支持\"><a href=\"#ACID支持\" class=\"headerlink\" title=\"ACID支持\"></a>ACID支持</h4><p>ACID操作是保证数据一致性的基础。Neo4j确保了在一个事务里面的多个操作同时发生，保证数据一致性。不管是采用嵌入模式还是多服务器集群部署，都支持这一特性。</p>\n<h4 id=\"高可用性\"><a href=\"#高可用性\" class=\"headerlink\" title=\"高可用性\"></a>高可用性</h4><p>图存储可以非常轻松的集成到任何一个应用中。随着应用在运营中的不断发展，性能问题肯定会逐步凸显出来，而Neo4j不管应用如何变化，只会受到计算机硬件性能的影响，而不受业务本身的约束。</p>\n<h4 id=\"轻松扩展\"><a href=\"#轻松扩展\" class=\"headerlink\" title=\"轻松扩展\"></a>轻松扩展</h4><p>可以扩展到上亿级别的节点和关系，部署一个neo4j服务器便可以承载上亿级的节点和关系。当单节点无法承载数据需求时，可以进行分布式集群部署。通常来讲，对于10亿节点以下规模的图谱来说Neo4j已经足够了。</p>\n<h4 id=\"高速检索\"><a href=\"#高速检索\" class=\"headerlink\" title=\"高速检索\"></a>高速检索</h4><p>通过Neo4j提供的遍历工具，可以非常高效的进行数据检索，每秒可以达到上亿级的检索量。</p>\n<p>Neo4j的用户包括电子港湾、必能宝、沃尔玛、德国汉莎航空公司、思科、惠普、埃森哲等很多知名企业。</p>\n<h3 id=\"Neo4j编程概要\"><a href=\"#Neo4j编程概要\" class=\"headerlink\" title=\"Neo4j编程概要\"></a>Neo4j编程概要</h3><p>Neo4j是是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。主要有三种访问Neo4j数据库的方式：</p>\n<h4 id=\"嵌入式\"><a href=\"#嵌入式\" class=\"headerlink\" title=\"嵌入式\"></a>嵌入式</h4><p>通过指定数据库地址直接访问数据库。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new GraphDatabaseFactory().newEmbeddedDatabase(DB_PATH);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"REST-API\"><a href=\"#REST-API\" class=\"headerlink\" title=\"REST API\"></a>REST API</h4><p>通过请求API访问数据库。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -D - -H Accept:application&#x2F;json &quot;http:&#x2F;&#x2F;neo4j:123456@localhost:8474&#x2F;db&#x2F;data&#x2F;&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h4><p>通过Java API的方式访问数据库。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">DriverManager.getConnection(&quot;jdbc:neo4j:123456&#x2F;&#x2F;localhost:8474&#x2F;&quot;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"人生苦短，我用Python\"><a href=\"#人生苦短，我用Python\" class=\"headerlink\" title=\"人生苦短，我用Python\"></a>人生苦短，我用Python</h4><p>应用Python完成基于Neo4j的应用，需要从<code>http://py2neo.org/v3/</code>安装py2neo:</p>\n<h4 id=\"连接Neo4j\"><a href=\"#连接Neo4j\" class=\"headerlink\" title=\"连接Neo4j\"></a>连接Neo4j</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mygraph &#x3D; Graph(host&#x3D;&#39;localhost&#39;, http_port&#x3D;8474, https_port&#x3D;8473, bolt_port&#x3D;8687, username&#x3D;&#39;Abel_Cao&#39;, password&#x3D;&#39;xxxxxx&#39;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建节点和关系\"><a href=\"#创建节点和关系\" class=\"headerlink\" title=\"创建节点和关系\"></a>创建节点和关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">abel &#x3D; Node(&#39;Person&#39;, name&#x3D;&#39;Abel&#39;)  </span><br><span class=\"line\">zmx &#x3D; Node(&#39;Person&#39;, name&#x3D;&#39;Zmx&#39;)</span><br><span class=\"line\">abel_love_zmx &#x3D; Relationship(abel, &#39;Love&#39;, zmx) </span><br><span class=\"line\">graph.create(abel_love_zmx)</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改属性\"><a href=\"#修改属性\" class=\"headerlink\" title=\"修改属性\"></a>修改属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">abel.properties[&#39;age&#39;] &#x3D; 47</span><br><span class=\"line\">andy.properties[&#39;age&#39;] &#x3D; 17</span><br><span class=\"line\">abel.push()</span><br><span class=\"line\">andy.push()</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找节点或关系\"><a href=\"#查找节点或关系\" class=\"headerlink\" title=\"查找节点或关系\"></a>查找节点或关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">abel &#x3D; graph.find_one(label&#x3D;&#39;Person&#39;, property_key&#x3D;&#39;name&#39;, property_value&#x3D;&#39;Abel&#39;)</span><br><span class=\"line\">zmx &#x3D; graph.find_one(label&#x3D;&#39;Person&#39;, property_key&#x3D;&#39;name&#39;, property_value&#x3D;’Zmx&#39;)</span><br><span class=\"line\">abel_love_zmx&#x3D; graph.match_one(start_node&#x3D;abel, rel_type&#x3D;&#39;Love’, end_node&#x3D;zmx)</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除节点、关系\"><a href=\"#删除节点、关系\" class=\"headerlink\" title=\"删除节点、关系\"></a>删除节点、关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">graph.delete(alice_knows_bob)</span><br><span class=\"line\">graph.delete(alice)</span><br><span class=\"line\">graph.delete(bob)</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义查询\"><a href=\"#自定义查询\" class=\"headerlink\" title=\"自定义查询\"></a>自定义查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">cursor &#x3D; graph.run(Cipher_statement)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cipher-简要\"><a href=\"#Cipher-简要\" class=\"headerlink\" title=\"Cipher 简要\"></a>Cipher 简要</h3><p>简单的类比一下，可以把Cipher查询语言理解为SQL语句。</p>\n<h4 id=\"删除节点、关系-1\"><a href=\"#删除节点、关系-1\" class=\"headerlink\" title=\"删除节点、关系\"></a>删除节点、关系</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MATCH (abel:&#96;Person&#96; &#123;name:&quot;Abel&quot;&#125;)-[abel_love_andy:&#96;Love&#96;]-&gt;(andy:&#96;Person&#96; &#123;name:&quot;Andy&quot;&#125;) DELETE abel_love_andy; MATCH (abel:&#96;Person&#96; &#123;name:&quot;Abel&quot;&#125;), (andy:&#96;Person&#96; &#123;name:&quot;Andy&quot;&#125;) DELETE abel, andy;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找路径\"><a href=\"#查找路径\" class=\"headerlink\" title=\"查找路径\"></a>查找路径</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MATCH p&#x3D;(abel:&#96;Person&#96; &#123;name:&quot;Abel&quot;&#125;)-[]-&gt;(andy:&#96;Person&#96; &#123;name:&quot;Andy&quot;&#125;) DELETE p;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找最短路径\"><a href=\"#查找最短路径\" class=\"headerlink\" title=\"查找最短路径\"></a>查找最短路径</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">MATCH p&#x3D;shortestPath((abel:&#96;Person&#96; &#123;name:&quot;Abel&quot;&#125;)-[*..5]-&gt;(zmx:&#96;Person&#96; &#123;name:&quot;Zmx&quot;&#125;)) DELETE p;</span><br></pre></td></tr></table></figure>\n<p>Cipher中的其他操作指令包括：</p>\n<ul>\n<li>删除标签和属性 REMOVE</li>\n<li>遍历节点 FOREACH</li>\n<li>过滤条件 WHERE</li>\n<li>使用索引 START</li>\n<li>排序 ORDER BY</li>\n<li>分页 LIMIT SKIP</li>\n<li>索引 INDEX</li>\n<li>唯一性约束 UNIQUE</li>\n<li>聚合函数 COUNT SUM AVG DISTINCT 等等</li>\n</ul>\n<p>在Neo4j的集群部署中，一般使用zookeeper来负责neo4j server的心跳检测。</p>\n<p><img data-src=\"/images/from-knowledge-graph-to-db/3.jpg\" alt=\"\"></p>\n<p>需要注意的是，在 zookeeper master选举期间，write请求不可处理，会直接返回异常，最好在客户端提供一种故障切换的重试机制进行控制。</p>\n<h2 id=\"各种的图数据库\"><a href=\"#各种的图数据库\" class=\"headerlink\" title=\"各种的图数据库\"></a>各种的图数据库</h2><p>在<code>db-engines.com</code>上，可以看到图数据库的市场排名。</p>\n<p><img data-src=\"/images/from-knowledge-graph-to-db/4.jpg\" alt=\"\"></p>\n<p>市场有着较大的变化，曾经的记忆好像是这样的：</p>\n<ul>\n<li>AWS使用titan，分布式图形数据库。</li>\n<li>titan不是数据库，而是客户端库，依赖于下面的存储引擎，例如Cassandra或者Hadoop，也依赖于索引引擎，比如Lucene、ElasticSearch或Solr，来执行相关的查询。</li>\n<li>arangoDB支持灵活的数据模型，比如文档Document、图Graph以及键值对Key-Value存储。</li>\n<li>OrientDB的主要特点是支持多模型对象，支持不同的模型，如文档，图形，键/值和真实对象。</li>\n<li>GUN是一个实时的、分布式的、嵌入式图形数据库引擎。</li>\n</ul>\n<p>曾经关注的几种图数据库部分属性对比：</p>\n<p><img data-src=\"/images/from-knowledge-graph-to-db/5.jpg\" alt=\"\"></p>\n<h2 id=\"图数据库的应用\"><a href=\"#图数据库的应用\" class=\"headerlink\" title=\"图数据库的应用\"></a>图数据库的应用</h2><p>对于在数据捕获设计之后，追求数据驱动运营和决策的组织而言，图分析可能是最有效的竞争优势.因此，图形数据库在社交网络、征信系统等诸多领域有着广泛的应用，例如：</p>\n<ul>\n<li>实时推荐</li>\n<li>主数据管理：组织架构，社交网络，产品订购，IT网络</li>\n<li>欺诈检测，合成身份诈骗环</li>\n<li>基于图的搜索</li>\n<li>IT网络管理</li>\n<li>身份和访问管理</li>\n<li>地理信息系统</li>\n</ul>\n<p>其中重要的是，图数据库能够将大数据洞察付诸于行动，是构建知识图谱的基石之一，在人工智能及其应用中有着重要的一席之地。<br><img data-src=\"/images/from-knowledge-graph-to-db/6.jpg\" alt=\"\"></p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9uZW80ai5jb20vZGV2ZWxvcGVy\">https://neo4j.com/developer<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlxaXpoaXhpbi5jb20vYXJ0aWNsZXMvMjAxOC0wNi0yMC00\">https://www.jiqizhixin.com/articles/2018-06-20-4<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYi1lbmdpbmVzLmNvbS8=\">https://db-engines.com/<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>Ian，Robinson、Jim，Webber、Emil，Eifrem 著，刘璐，梁越 译 《图数据库（第二版）》，人民邮电出版社，2016</li>\n</ul>\n</blockquote>\n","categories":["Ai"],"tags":["Ai","KnowledgeGraph"]},{"title":"RDF 和 SPARQL 初探：以维基数据为例","url":"/2020/05/08/ai/rdf-and-sparql/","content":"<p>大家都知道，关系型数据库是目前使用最广泛的数据库，将数据抽象成行和列的表格关系。但是，现实世界不像表格，更像网络。各种事物通过错综复杂的关系，连接在一起，组成一张网。网络在数学里面称为<strong>图</strong>（graph），每样事物就是图的一个节点，节点之间的关系就是将它们连在一起的那条边。如果数据库以图的方式储存数据，就称为<strong>图数据库</strong>。RDF 就是图数据库的一种描述方式，或者说是一种使用协议。它以&quot;<strong>三元组</strong>&quot;（triple）的方式，描述事物与事物之间的直接关系。<br><a id=\"more\"></a></p>\n<p>维基百科有一个姐妹项目，叫做&quot;维基数据&quot;（Wikidata）。你可以从维基百科左侧边栏点进去。</p>\n<p><img data-src=\"/images/rdf-and-sparql/1.jpg\" alt=\"\"></p>\n<p>&quot;维基数据&quot;将维基百科的所有数据，整理成一个可以机器处理的数据库，方便查询。比如，山西省人口最多的地区是哪一个？</p>\n<p>这种问题在维基百科查询，非常费时，必须人工从一个个条目提取信息。但是，维基数据可以只执行一条命令，就返回答案（详见后文）。因为它提供结构化数据，可以机器查询。</p>\n<p>但是，维基数据不是关系型数据库，而是 RDF 数据库；查询语言不是 SQL，而是 SPARQL。我粗浅地学了一点 RDF 和 SPARQL，本文就是学习笔记，演示如何使用维基数据查询信息。</p>\n<p><img data-src=\"/images/rdf-and-sparql/2.jpg\" alt=\"\"></p>\n<h2 id=\"一、RDF-的含义\"><a href=\"#一、RDF-的含义\" class=\"headerlink\" title=\"一、RDF 的含义\"></a>一、RDF 的含义</h2><p>大家都知道，关系型数据库是目前使用最广泛的数据库，将数据抽象成行和列的表格关系。</p>\n<p><img data-src=\"/images/rdf-and-sparql/3.jpg\" alt=\"\"></p>\n<p>但是，现实世界不像表格，更像网络。各种事物通过错综复杂的关系，连接在一起，组成一张网。</p>\n<p><img data-src=\"/images/rdf-and-sparql/4.jpg\" alt=\"\"></p>\n<p>网络在数学里面称为图（graph），每样事物就是图的一个节点，节点之间的关系就是将它们连在一起的那条边。如果数据库以图的方式储存数据，就称为<strong>图数据库</strong>。</p>\n<p><strong>RDF 就是图数据库的一种描述方式，或者说是一种使用协议。它以&quot;三元组&quot;（ triple）的方式，描述事物与事物之间的直接关系。</strong></p>\n<p>&quot;<strong>三元组</strong>&quot;是 RDF 的核心概念，指的是两个事物和它们之间的关系，在语法上呈现为&quot;主语 + 谓语 + 宾语&quot;。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">天空是蓝色的。</span><br></pre></td></tr></table></figure>\n<p>上面这句话，就是一个 RDF 三元组。&quot;天空&quot;（主语）和&quot;蓝色&quot;（宾语）是两种事物，它们通过颜色关系（谓语）连接在一起。</p>\n<p><img data-src=\"/images/rdf-and-sparql/5.jpg\" alt=\"\"></p>\n<p>RDF 要求，谓语（即事物之间的关系）必须有明确定义。大家这样想，如果谓语是给定的，就可以用主语去查询宾语，或者用宾语去查询主语。比如，颜色关系是给定的，那么就可以向数据库进行下面的查询。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">查询一：天空 + 颜色 &#x3D; ？</span><br><span class=\"line\"></span><br><span class=\"line\">查询二：？ + 颜色 &#x3D; 蓝色</span><br></pre></td></tr></table></figure>\n<p>任何组织和个人，都可以定义自己的谓语。RDF 要求每套谓语必须有一个明确的 URL，通过 URL 区分不同的谓语。RDF 官方定义了一套常用的谓语，URL 如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns</span><br></pre></td></tr></table></figure><br>使用的时候，只要引用这个 URL，别人就知道用的是哪一套谓语。</p>\n<p>URL 比较冗长，引用不方便。RDF 允许指定一个前缀，代表 URL 地址，比如上面那个官方谓语的 URL，通常用前缀rdf表示。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PREFIX rdf: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns&gt;</span><br></pre></td></tr></table></figure><br>每个 URL 里面可以包含多种谓语，通过&quot;前缀 : 谓语&quot;的形式来区分。比如，官方定义了一个&quot;type&quot;谓语，说明主语的类型，就可以用<code>rdf:type</code>表示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">小明是学生。</span><br></pre></td></tr></table></figure>\n<p>上面这句话，写成 RDF 三元组，就是下面的形式。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PREFIX rdf: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns&gt;</span><br><span class=\"line\">小明 rdf:type 学生.</span><br></pre></td></tr></table></figure><br>由于<code>rdf:type</code>是一个常用谓语，RDF 允许把它简写成a，因此&quot;小明是学生&quot;又可以表示成小明 a 学生。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PREFIX rdf: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns&gt;</span><br><span class=\"line\">小明 a 学生.</span><br></pre></td></tr></table></figure><br>注意，每个 RDF 三元组的结尾是一个英文的句号，用来区分多个三元组。</p>\n<h2 id=\"二、-RDF-的语法示例\"><a href=\"#二、-RDF-的语法示例\" class=\"headerlink\" title=\"二、 RDF 的语法示例\"></a>二、 RDF 的语法示例</h2><p>下面通过一个例子，演示 RDF 如何定义事物之间的关系。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">甲壳虫是一个乐队，成员有 John Lennon、Paul McCartney、Ringo Starr 和George Harrison。他们都是艺术家，1963年出版过一张专辑《Please Please Me》，里面包含《Love Me Do》这首单曲，长度125秒。</span><br></pre></td></tr></table></figure><br>上面这段话，是自然语言的文本。我们先画出网络关系图。</p>\n<p><img data-src=\"/images/rdf-and-sparql/6.jpg\" alt=\"\"></p>\n<p>然后，转成 RDF 三元组。首先，给出谓语的 URL，及其对应的前缀。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PREFIX : &lt;http:&#x2F;&#x2F;foo.com&#x2F;tutorial&#x2F;&gt;</span><br><span class=\"line\">PREFIX rdf: &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;02&#x2F;22-rdf-syntax-ns&gt;</span><br></pre></td></tr></table></figure><br>上面例子中，有两个 URL，表示使用两套谓语。其中一套是官方谓语，使用前缀rdf表示；另一套是自己定义的，前缀为空，表示这是默认的前缀。</p>\n<p>&quot;甲壳虫是一个乐队，成员有 John Lennon、Paul McCartney、Ringo Starr 和George Harrison。&quot;这句话对应的三元组如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">甲壳虫 rdf:type Band .</span><br><span class=\"line\">甲壳虫 :name &quot;甲壳虫&quot; .</span><br><span class=\"line\">甲壳虫 :member John_Lennon .</span><br><span class=\"line\">甲壳虫 :member Paul_McCartney .</span><br><span class=\"line\">甲壳虫 :member Ringo_Starr .</span><br><span class=\"line\">甲壳虫 :member George_Harrison .</span><br></pre></td></tr></table></figure><br>上面例子中，<code>rdf:type</code>、<code>:name</code>、<code>:member</code>都是谓语。由于这些三元组的主语相同，RDF 允许将它们合并。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">甲壳虫 a 乐队 ;</span><br><span class=\"line\">      :name &quot;甲壳虫&quot; ;</span><br><span class=\"line\">      :member John_Lennon, Paul_McCartney, George_Harrison, Ringo_Starr .</span><br></pre></td></tr></table></figure><br>上面的代码中，主语相同的三元组采用合并写法时，每个三元组之间使用分号隔开，最后一个三元组采用句号结尾。</p>\n<p>其余部分对应的 RDF 三元组如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">John_Lennon      a 艺术家 .</span><br><span class=\"line\">Paul_McCartney   a 艺术家 .</span><br><span class=\"line\">Ringo_Starr      a 艺术家 .</span><br><span class=\"line\">George_Harrison  a 艺术家 .</span><br><span class=\"line\">Please_Please_Me a 专辑 ;</span><br><span class=\"line\">                 :name &quot;Please Please Me&quot; ;</span><br><span class=\"line\">                 :date &quot;1963&quot; ;</span><br><span class=\"line\">                 :artist &quot;甲壳虫&quot; ;</span><br><span class=\"line\">                 :track Love_Me_Do .</span><br><span class=\"line\">Love_Me_Do       a Song ;</span><br><span class=\"line\">                 :name &quot;Love Me Do&quot; ;</span><br><span class=\"line\">                 :length 125 .</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、SPARQL-查询语言\"><a href=\"#三、SPARQL-查询语言\" class=\"headerlink\" title=\"三、SPARQL 查询语言\"></a>三、SPARQL 查询语言</h2><p>SPARQL 是 RDF 数据库的查询语言，跟 SQL 的语法很像。它的核心思想是，根据给定的谓语动词，从三元组提取符合条件的主语或宾语。</p>\n<p>SPARQL 查询的语法如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT &lt;variables&gt;</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">   &lt;graph pattern&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，<code>&lt;variables&gt;</code>是所要提取主语或宾语，<code>&lt;graph pattern&gt;</code>是所要查询的三元组模式。</p>\n<p>比如，查询数据库里面的所有专辑。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT ?album</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">   ?album rdf:type :Album .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，<code>?album</code>是一个变量，名字可以随便起，第一个字符必须是问号<code>?</code>。查询的条件是，<code>?album</code>这个变量是主语，根据<code>rdf:type</code>这个谓语，可以得到<code>:Album</code>这个宾语。这个宾语也有前缀，表示这是当前数据库定义的。</p>\n<p>如果返回的是符合条件的所有记录，变量可以用星号<code>*</code>代替，并且<code>WHERE</code>这个关键词在<code>SELECT</code>查询里面可以省略，最后一个三元组的结尾句号也可以省略，所以上面的查询也可以写成下面的样子。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * &#123; ?album a ：Album &#125;</span><br></pre></td></tr></table></figure><br>除了专辑名称，如果还要返回专辑的演唱者，可以增加一个变量<code>?artist</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT ?album ?artist</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   ?album a :Album .</span><br><span class=\"line\">   ?album :artist ?artist .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，<code>?artist</code>这个变量必须是<code>?album</code>（主语）和<code>:artist</code>（谓语）的宾语。</p>\n<h2 id=\"四、维基数据查询示例：山西省人口最多的地区\"><a href=\"#四、维基数据查询示例：山西省人口最多的地区\" class=\"headerlink\" title=\"四、维基数据查询示例：山西省人口最多的地区\"></a>四、维基数据查询示例：山西省人口最多的地区</h2><p>下面通过维基数据查询&quot;山西省人口最多的是哪一个地区&quot;，进一步学习 SPARQL 语法。</p>\n<p>首先，进入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2lraWRhdGEub3JnLw==\">维基数据<i class=\"fa fa-external-link-alt\"></i></span>网站，在页面顶部的搜索栏，搜索&quot;山西&quot;。或者，维基百科的&quot;山西省&quot;页面，左边栏也有跳转到维基数据的链接。</p>\n<p><img data-src=\"/images/rdf-and-sparql/7.jpg\" alt=\"\"></p>\n<p>然后，进入<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2lraWRhdGEub3JnL3dpa2kvUTQ2OTEz\">山西省的页面<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<p><img data-src=\"/images/rdf-and-sparql/8.jpg\" alt=\"\"></p>\n<p>这时，留意一下这个页面的 URL。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;www.wikidata.org&#x2F;wiki&#x2F;Q46913</span><br></pre></td></tr></table></figure><br>上面 URL 最后结尾的<code>Q46913</code>，就是山西省这个条目在维基数据的编号（即主语），后面要用到。</p>\n<p>接着，页面向下滚动，找到&quot;contains administrative territorial entity&quot;（所包含的行政实体）这个部分，它列出了山西省下辖的各个地区。</p>\n<p><img data-src=\"/images/rdf-and-sparql/9.jpg\" alt=\"\"></p>\n<p>点击&quot;contains administrative territorial entity&quot;这个标题，进入它的页面，也留意一下 URL。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;www.wikidata.org&#x2F;wiki&#x2F;Property:P150</span><br></pre></td></tr></table></figure><br>上面 URL 的最后部分<code>P150</code>，就是&quot;所包含的行政实体&quot;这个谓语动词的编号。</p>\n<p>现在，就可以开始查询了。进入维基数据的在线查询页面 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWVyeS53aWtpZGF0YS5vcmcv\">query.wikidata.org<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><img data-src=\"/images/rdf-and-sparql/10.jpg\" alt=\"\"></p>\n<p>在查询框里面，输入下面的 SPARQL 语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT ?area</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">   wd:Q46913  wdt:P150 ?area .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面代码要求返回变量<code>?area</code>，该变量必须满足主语&quot;山西省&quot;<code>（wd:Q46913）</code>和谓语&quot;所包含的行政实体&quot;<code>（wdt:P150）</code>。前缀wd表示这是维基数据的条目，而前缀wdt表示这是维基数据定义的谓语关系。</p>\n<p>点击左侧边栏的三角形运行按钮，就可以在页面下方得到查询的结果。</p>\n<p><img data-src=\"/images/rdf-and-sparql/11.jpg\" alt=\"\"></p>\n<p>从上图可以看到，返回的都是条目的编号。修改一下查询语句，增加一栏文字标签。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?area</span><br><span class=\"line\">  ?areaLabel</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">   wd:Q46913  wdt:P150 ?area .</span><br><span class=\"line\">   ?area rdfs:label ?areaLabel .</span><br><span class=\"line\">   FILTER(LANGMATCHES(LANG(?areaLabel), &quot;zh-CN&quot;)) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，增加了一个返回的变量<code>?areaLabel</code>，该变量是前一个变量<code>?area</code>的文字标签（满足谓语<code>rdfs:label</code>），同时增加了一个过滤语句FILTER，要求只返回中文标签。</p>\n<p>运行这段查询，就可以看到每个地区的中文名字了。</p>\n<p><img data-src=\"/images/rdf-and-sparql/12.jpg\" alt=\"\"></p>\n<p>接着，再增加一个人口变量<code>?popTotal</code>，返回每个地区的人口总数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?area </span><br><span class=\"line\">  ?areaLabel </span><br><span class=\"line\">  ?popTotal</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">   wd:Q46913  wdt:P150 ?area .</span><br><span class=\"line\">   ?area rdfs:label ?areaLabel .</span><br><span class=\"line\">   FILTER(LANGMATCHES(LANG(?areaLabel), &quot;zh-CN&quot;)) </span><br><span class=\"line\"></span><br><span class=\"line\">   ?area wdt:P1082 ?popTotal .</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行这段代码，就可以看到人口总数了。</p>\n<p><img data-src=\"/images/rdf-and-sparql/13.jpg\" alt=\"\"></p>\n<p>然后，增加一个排序子句<code>order by</code>，按照人口的倒序排序。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?area </span><br><span class=\"line\">  ?areaLabel </span><br><span class=\"line\">  ?popTotal</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">   wd:Q46913  wdt:P150 ?area .</span><br><span class=\"line\">   ?area rdfs:label ?areaLabel .</span><br><span class=\"line\">   FILTER(LANGMATCHES(LANG(?areaLabel), &quot;zh-CN&quot;)) </span><br><span class=\"line\"></span><br><span class=\"line\">   ?area wdt:P1082 ?popTotal .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ORDER BY desc(?popTotal)</span><br></pre></td></tr></table></figure><br>运行结果如下。</p>\n<p><img data-src=\"/images/rdf-and-sparql/14.jpg\" alt=\"\"></p>\n<p>最后，加上一个<code>limit 1</code>子句，只返回第一条数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?area </span><br><span class=\"line\">  ?areaLabel </span><br><span class=\"line\">  ?popTotal</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">   wd:Q46913  wdt:P150 ?area .</span><br><span class=\"line\">   ?area rdfs:label ?areaLabel .</span><br><span class=\"line\">   FILTER(LANGMATCHES(LANG(?areaLabel), &quot;zh-CN&quot;)) </span><br><span class=\"line\"></span><br><span class=\"line\">   ?area wdt:P1082 ?popTotal .</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ORDER BY desc(?popTotal)</span><br><span class=\"line\">limit 1</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"/images/rdf-and-sparql/15.jpg\" alt=\"\"></p>\n<p>这样就得到了山西省人口最多的地区。</p>\n<h2 id=\"五、维基数据查询示例：程序员名录\"><a href=\"#五、维基数据查询示例：程序员名录\" class=\"headerlink\" title=\"五、维基数据查询示例：程序员名录\"></a>五、维基数据查询示例：程序员名录</h2><p>下面再看一个例子，找出维基百科收入的所有程序员。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?programmer </span><br><span class=\"line\">  ?programmerLabel</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">  ?programmer wdt:P106 wd:Q5482740 .</span><br><span class=\"line\">  ?programmer rdfs:label ?programmerLabel .  </span><br><span class=\"line\">  FILTER (LANGMATCHES(LANG(?programmerLabel), &quot;zh-CN&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面代码中，<code>Q5482740</code> 是程序员，<code>P106</code> 是职业。</p>\n<p>运行这个查询，就可以看到程序员名单了。</p>\n<p><img data-src=\"/images/rdf-and-sparql/16.jpg\" alt=\"\"></p>\n<p>注意，这里只返回有中文名的程序员。如果数据库里面没有收入程序员的中文名，这里就不会返回。</p>\n<p>然后，查询每个程序员的主要成就。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?programmer </span><br><span class=\"line\">  ?programmerLabel </span><br><span class=\"line\">  ?notableworkLabel</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">  ?programmer wdt:P106 wd:Q5482740 .</span><br><span class=\"line\">  ?programmer rdfs:label ?programmerLabel .  </span><br><span class=\"line\">  FILTER (LANGMATCHES(LANG(?programmerLabel), &quot;zh-CN&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  ?programmer wdt:P800 ?notablework .  </span><br><span class=\"line\">  ?notablework rdfs:label ?notableworkLabel .  </span><br><span class=\"line\">  FILTER(LANGMATCHES(LANG(?notableworkLabel), &quot;zh-CN&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>运行结果如下。</p>\n<p><img data-src=\"/images/rdf-and-sparql/17.jpg\" alt=\"\"></p>\n<p>有的程序员有多项成就，比如，约翰·卡马克有&quot;毁灭战士&quot;和&quot;雷神之锤&quot;两项成就。这时可以用GROUP BY子句将它们合并在一起。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?programmer </span><br><span class=\"line\">  ?programmerLabel </span><br><span class=\"line\">  (GROUP_CONCAT(?notableworkLabel; separator&#x3D;&quot;; &quot;) AS ?works)</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">  ?programmer wdt:P106 wd:Q5482740 .</span><br><span class=\"line\">  ?programmer rdfs:label ?programmerLabel .  </span><br><span class=\"line\">  FILTER(LANGMATCHES(LANG(?programmerLabel), &quot;zh-CN&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  ?programmer wdt:P800 ?notablework .  </span><br><span class=\"line\">  ?notablework rdfs:label ?notableworkLabel .  </span><br><span class=\"line\">  FILTER (LANGMATCHES(LANG(?notableworkLabel), &quot;zh-CN&quot;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">GROUP BY ?programmer ?programmerLabel</span><br></pre></td></tr></table></figure><br>上面代码中，<code>GROUP_CONCAT</code>函数用来把多个<code>?notableworkLabel</code>变量合并成新的一栏works。</p>\n<p>运行结果如下。</p>\n<p><img data-src=\"/images/rdf-and-sparql/18.jpg\" alt=\"\"></p>\n<p>上面图片中，&quot;毁灭战士&quot;和&quot;雷神之锤&quot;已经合并成一个单元格了。</p>\n<p>接着，为每个人增加一个头像照片。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">  ?programmer</span><br><span class=\"line\">  ?programmerLabel </span><br><span class=\"line\">  (GROUP_CONCAT(?notableworkLabel; separator&#x3D;&quot;; &quot;) AS ?works) </span><br><span class=\"line\">  ?image</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">  ?programmer wdt:P106 wd:Q5482740 .</span><br><span class=\"line\">  ?programmer rdfs:label ?programmerLabel .  </span><br><span class=\"line\">  FILTER(LANGMATCHES ( LANG ( ?programmerLabel ), &quot;zh-CN&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  ?programmer wdt:P800 ?notablework .  </span><br><span class=\"line\">  ?notablework rdfs:label ?notableworkLabel .  </span><br><span class=\"line\">  FILTER (LANGMATCHES ( LANG ( ?notableworkLabel ), &quot;zh-CN&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  OPTIONAL &#123;?programmer wdt:P18 ?image&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">GROUP BY ?programmer ?programmerLabel ?image</span><br></pre></td></tr></table></figure><br>上面代码中，返回值增加了一个照片变量<code>?image</code>。由于不是每个人都有照片，所以把照片要求放在<code>OPTIONAL</code>条件中，表示这一项是可选的。</p>\n<p>得到查询结果后，把结果的表格视图<code>（table）</code>切换成图像视图<code>（image grid）</code>。</p>\n<p><img data-src=\"/images/rdf-and-sparql/19.jpg\" alt=\"\"></p>\n<p>这时，照片就可以显示出来了。</p>\n<p><img data-src=\"/images/rdf-and-sparql/20.jpg\" alt=\"\"></p>\n<p>最后，我们想知道他们是哪个地方的人，维基数据提供他们的出生地。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT ?programmer </span><br><span class=\"line\">  ?programmerLabel </span><br><span class=\"line\">  (GROUP_CONCAT(?notableworkLabel; separator&#x3D;&quot;; &quot;) AS ?works) </span><br><span class=\"line\">  ?image</span><br><span class=\"line\">  ?cood</span><br><span class=\"line\">WHERE &#123;</span><br><span class=\"line\">  ?programmer wdt:P106 wd:Q5482740 .</span><br><span class=\"line\">  ?programmer rdfs:label ?programmerLabel .  </span><br><span class=\"line\">  FILTER(LANGMATCHES ( LANG ( ?programmerLabel ), &quot;zh-CN&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  ?programmer wdt:P800 ?notablework .  </span><br><span class=\"line\">  ?notablework rdfs:label ?notableworkLabel .  </span><br><span class=\"line\">  FILTER (LANGMATCHES ( LANG ( ?notableworkLabel ), &quot;zh-CN&quot;))</span><br><span class=\"line\"></span><br><span class=\"line\">  OPTIONAL &#123;?programmer wdt:P18 ?image&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  OPTIONAL &#123;</span><br><span class=\"line\">    ?programmer wdt:P19 ?birthplace .</span><br><span class=\"line\">    ?birthplace wdt:P625 ?cood .</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">GROUP BY ?programmer ?programmerLabel ?image ?cood</span><br></pre></td></tr></table></figure>\n<p>上面代码中，返回值增加了坐标变量<code>cood</code>，先查询程序员的出生地，然后查询出生地的地理坐标。</p>\n<p>运行查询之后，默认的表格视图就会出现坐标。<br><img data-src=\"/images/rdf-and-sparql/21.jpg\" alt=\"\"></p>\n<p>把视图切换成地图（map）。</p>\n<p><img data-src=\"/images/rdf-and-sparql/22.jpg\" alt=\"\"></p>\n<p>这时就能看到这些程序员在世界地图上的位置。</p>\n<p><img data-src=\"/images/rdf-and-sparql/23.jpg\" alt=\"\"></p>\n<p>这篇教程就到这里为止，维基数据的查询方法还有很多，继续学习可以点击<span class=\"exturl\" data-url=\"aHR0cHM6Ly9xdWVyeS53aWtpZGF0YS5vcmcv\">查询页<i class=\"fa fa-external-link-alt\"></i></span>头部的<code>Examples</code>按钮，看看官方提供的示例。</p>\n<p><img data-src=\"/images/rdf-and-sparql/24.jpg\" alt=\"\"></p>\n<h2 id=\"六、参考链接\"><a href=\"#六、参考链接\" class=\"headerlink\" title=\"六、参考链接\"></a>六、参考链接</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUkRG\">RDF<i class=\"fa fa-external-link-alt\"></i></span>, Wikipedia</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3RhcmRvZy5jb20vdHV0b3JpYWxzL2RhdGEtbW9kZWw=\">RDF Graph Data Model<i class=\"fa fa-external-link-alt\"></i></span>, Stardog</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc3RhcmRvZy5jb20vdHV0b3JpYWxzL3NwYXJxbC8=\">Learn SPARQL<i class=\"fa fa-external-link-alt\"></i></span>, Stardog</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY2FtYnJpZGdlc2VtYW50aWNzLmNvbS9ibG9nL3NlbWFudGljLXVuaXZlcnNpdHkvbGVhcm4tc3BhcnFsL3NwYXJxbC1udXRzLWJvbHRzLw==\">SPARQL Nuts &amp; Bolts<i class=\"fa fa-external-link-alt\"></i></span>, Cambridge Semantics</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly90b3dhcmRzZGF0YXNjaWVuY2UuY29tL2hvdy10by1leHRyYWN0LWtub3dsZWRnZS1mcm9tLXdpa2lwZWRpYS1kYXRhLXNjaWVuY2Utc3R5bGUtMzVmNTBmMDk1ZDFh\">How to Extract Knowledge from Wikipedia, Data Science Style<i class=\"fa fa-external-link-alt\"></i></span>, Michael Li</li>\n</ul>\n<blockquote>\n<p>转自阮一峰博客<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMjAvMDIvc3BhcnFsLmh0bWw=\">《RDF 和 SPARQL 初探：以维基数据为例》<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n","categories":["Ai"],"tags":["Ai","KnowledgeGraph"]},{"title":"第24讲 | 比特币专题（一）历史与货币","url":"/2014/09/22/blockchain/blockchain-btc-1-history-and-currency/","content":"<p>我们终于到了“信仰”篇。“信仰”这个词是我经常在公司调侃新员工，问他们有没有为“信仰”充值，这里的信仰指代的就是比特币。<br><a id=\"more\"></a><br>比特币相关的技术前面一个专题已经介绍过了，再深入挖掘就是隔离见证和扩容之争了，我们今天重点介绍比特币本身的来龙去脉，感受一下这个世界的变化之大。</p>\n<h3 id=\"比特币的逆袭史\"><a href=\"#比特币的逆袭史\" class=\"headerlink\" title=\"比特币的逆袭史\"></a>比特币的逆袭史</h3><p>俗话说读史明智，我们就从比特币的历史开始聊起。比特币的历史总结起来大约有四个时期：创立前期、创立期、成长和稳定期。</p>\n<h3 id=\"创立前期\"><a href=\"#创立前期\" class=\"headerlink\" title=\"创立前期\"></a>创立前期</h3><p>在比特币创立之前，世界上已有多种类似技术产品，最早的是 Ecash 协议，接着 Ecash 又有多种数字货币产品出现，其中以亚当·贝克的“Hashcash”和戴维 (Wei Dai) 的“B-money”、尼克·萨博的“Bit-gold”，以及哈尔·芬尼在“Hashcash”技术上发展出来的“RPOW”等技术产品。</p>\n<h3 id=\"创立期\"><a href=\"#创立期\" class=\"headerlink\" title=\"创立期\"></a>创立期</h3><p>2008 年 11 月，中本聪发表了比特币的白皮书《比特币：一种点对点的电子现金系统》，接下来的时间中本聪实现了他所描述的比特币系统。</p>\n<p>2009 年 1 月 3 日，比特币网络正式开始运行。中本聪在创始区块中写道“The Times 03/Jan/2009 Chancellor on brink of second bailout for banks”。这句话有两层意义，第一层意思是表示了中本聪没有预先挖矿，毕竟这是当天泰晤士报的新闻，中本聪显然不可能预先获知泰晤士报将要报道些什么。通常对这句话第二层意思的解读是：认为中本聪嘲讽了当下的中心化银行体系。</p>\n<p>2009 年 1 月 9 日，Bitcoin v0.1 版本发布，12 日中本聪进行了第一次交易，这一次交易中，中本聪给海尔发送了 10 个比特币。</p>\n<p>2009 年秋天, 一个叫“新自由标准”的用户通过 Paypal 支付了 5.02 美元，购买了 5050 个比特币，折合 0.000994 美元一个比特币，这是比特币和法币的第一次兑换。</p>\n<p>2009 年到 2010 年初，已经有一些其他的开发者被逐渐吸引过来，大家一起开发、维护、挖矿，那时候普通电脑还可以挖到比特币。</p>\n<p>2010 年 4 月, 一个叫拉斯诺的人发现可以使用 GPU 来挖比特币，5 月 22 日，他用挖到的比特币购买了两个比萨，共花费 10000BTC，这是比特币第一次被用于实物支付，也就是著名的比特币披萨事件。</p>\n<p>2010 年 7 月，世界上第一家比特币交易所在日本东京成立，名叫 Mt.Gox，中文“门头沟”。</p>\n<h3 id=\"成长期和稳定期\"><a href=\"#成长期和稳定期\" class=\"headerlink\" title=\"成长期和稳定期\"></a>成长期和稳定期</h3><p>2014 年 2 月，发生“门头沟事件”，门头沟交易所被黑一事震惊全球，比特币价格应声跳水；</p>\n<p>2014 年 6 月，以太坊开始了为期 42 天的 ICO，众筹使用的是 BTC；</p>\n<p>2017 年 11 月 28 日，比特币价格超过一万美元。</p>\n<p>最后附一份由维基百科归纳的比特币价格变化以及对应的事件。</p>\n<p>从上图可以看出，比特币的成长史就是对美元的逆袭史，比特币的发展经历了很多争议和阻碍，但是依然不妨碍它成为一种世界级现象，甚至是很多人的信仰，那么比特币的意义到哪在那里呢？</p>\n<h3 id=\"比特币的意义\"><a href=\"#比特币的意义\" class=\"headerlink\" title=\"比特币的意义\"></a>比特币的意义</h3><p>这个话题可能会引起一些争论，我姑且将本节的内容限定为“我”所理解的比特币，仅供你参考。</p>\n<p>首先比特币没有通常意义上的实用价值，不单单是比特币，所有的信用货币，包括黄金白银在内都不具备实用价值。</p>\n<p>这里的实用价值是指解决人的低层次需求，如果按照马斯洛需求层次理论来分，是指衣食住行等生存需求。</p>\n<p>换句话说，比特币也好，黄金也好，在生活面前都是废物，而无法直接利用，毕竟黄金吃下去也不能饱还有生命危险，比特币的私钥即使看得见却也摸不到。</p>\n<p>但是用货币就是能买东西，买来的东西可以帮你解决生存需求，换句话了吃饱了才能干其他事情。“买”这个动作就是比特币所要解决的，当然信用货币也能解决，也就是我们所说的支付功能。</p>\n<p>所以作为信用货币的比较，比特币到底有什么不同？它的意义超过信用货币吗？我个人认为是超过的。老生常谈的去中心化、防篡改我这里就不谈了，我们接下来换几个角度来聊聊它。</p>\n<h4 id=\"无国界的共识\"><a href=\"#无国界的共识\" class=\"headerlink\" title=\"无国界的共识\"></a>无国界的共识</h4><p>它打破了一般信用货币的局限性，我称作无国界的共识。</p>\n<p>比较常见的论调，比特币你信它就有价值，不信就什么用途也没有。这里隐含的语义是“承认过程”。</p>\n<p>例如你在美国吃顿饭，使用人民币支付，美国人一定不是特别同意，毕竟在美国就必须使用美元支付。换句话来说，“承认过程”很大程度上是身不由己，你所处的国家决定了必须承认某种信用货币。</p>\n<p>比特币奇怪就奇怪在，没有人会强迫你使用比特币，你的一念之间就可以决定比特币对于你的价值。</p>\n<p>如果类比到黄金，比如你长这么大，一直都是别人告诉你黄金非常值钱，所以你也觉得黄金值钱，这其实就是共识灌输的过程，当然你也可以公开表示“我觉得黄金不值钱”，这当然也没什么问题。</p>\n<p>想象一下，如果全世界都能达成比特币都可以用于支付的共识，比特币和黄金在共识的效果上也没什么不同了，那么声称“我觉得黄金不值钱”就变成了“我觉得比特币不值钱”，这里的逻辑是一样的。</p>\n<h4 id=\"记账是本职\"><a href=\"#记账是本职\" class=\"headerlink\" title=\"记账是本职\"></a>记账是本职</h4><p>比特币的本职是记账，不要想得太复杂，它就是来帮你记账的。例如你在宜家买了一套家具，比特币可以帮你记下来，当然不是说这个事件，而是帮你记录价值转移，你动用了你曾经创造的价值的多少（BTC）来购买这套家具。</p>\n<p>这个记账过程防篡改能力非常强，几乎没人能操控，也没有国界之分，只要你的交易方承认比特币，这笔买卖就可以达成。</p>\n<h4 id=\"高效的资源调度\"><a href=\"#高效的资源调度\" class=\"headerlink\" title=\"高效的资源调度\"></a>高效的资源调度</h4><p>比特币使用的是 PoW 算法，这个需要消耗大量能源进行挖矿的算法一直被人诟病；但是结合上述记账本职，我们也换个角度来看看这件事。</p>\n<p>目前全国的电力分配不均，中国的内蒙东北有着丰富的风力电，可惜这些富余的电力难以调度，超高压输电线路造价高昂，甚至超出了电厂本身。</p>\n<p>而比特币挖矿恰好需要极大地耗费能源，如果在偏远的资源丰富地区进行挖矿，相当于将架设超高压输电线路蜕化为网络通信设施，地方政府可以把庞大的风电资源转化成比特币，最多只需要十分钟，就可以在资本市场变现。所以每个人每次使用比特币的过程，相当于让偏远地区获得了平等参与社会运作的过程。</p>\n<h4 id=\"三权分立的社区自治形态\"><a href=\"#三权分立的社区自治形态\" class=\"headerlink\" title=\"三权分立的\b社区自治形态\"></a>三权分立的\b社区自治形态</h4><p>这里讨论的三权分立的形态，并不是指政府组织结构的形式，而是指矿工、开发者、投资者三者组成了相互制衡的数字货币的治理形态。</p>\n<p>比特币并没有真正意义上完全地去中心化，在记账权上，它目前被 5 大矿池所把持。当人们抨击 EOS 的 21 个节点有中心化的嫌疑时，BM 总是拿出比特币矿池的例子来反击。</p>\n<p>实际上这里偷换了概念，比特币中矿工的权力其实是有限的。</p>\n<p>技术限制：由于 PoW 的特性，矿工无法进行长程攻击（Long Range Attack），篡改和分叉的边际成本随着篡改的区块数量线性攀升，所以看似矿工的 51% 攻击，也就改一两个块而已。</p>\n<p>开发者制衡：扩容之争是很好的例子，我们下一篇会详细介绍，矿工是逐利的，而开发者决定了比特币的长期发展，所以从某种意义上来说，作弊不如和开发者合作。</p>\n<p>投资者制衡：矿工是比特币的直接利益相关者，无论是社区分歧还是主链分叉，矿工首先确保的是收益稳定，黑天鹅事件造成的巨大价格波动是不利于收益预期的。</p>\n<p>总结起来就是，虽然比特币在记账权上没有彻底去中心化，但是目前的情况也可以接受，至少矿工还受两方制约，矿工看收益，收益的价格看投资者，投资者看比特币长期发展，比特币长期发展看开发者，开发者受制于矿工，三者相互制衡。</p>\n<h4 id=\"BIP-及其发展\"><a href=\"#BIP-及其发展\" class=\"headerlink\" title=\"BIP 及其发展\"></a>BIP 及其发展</h4><p>比特币 BIP（Bitcoin Imrpovement Proposals) 是一种设计文档，用来描述比特币新特性的提案，第一个比特币 BIP 是 2011 年 8 月 19 号一个名为 Amir Taaki 的人提交的，编号 bip001，它描述了 BIP 本身是什么。</p>\n<p>随后几年直到现在，比特币的 BIP 编号将近 200 个，它展示了比特币强大的社区协作能力。</p>\n<p>很多人认为某个区块链项目一旦上线这个链就稳了，实际上，做公链好比一场没有尽头的马拉松长跑，主网上线表示长跑开始，接下来才是真正拼实力的时候。</p>\n<p>具体怎么拼？则要看 IP（Improvement Proposal）。可以说 IP 代表了一个区块链项目的生命力。例如 HD 账户是 bip32 和 bip39 提出的，最开始的比特币是没有这个功能的，隔离见证也是由一系列 bip 组成的。</p>\n<p>我们再比如说，就算是你想修改比特币的 2100 万上限也是可以的，只要你提的 BIP 详细论证了改上限的必要性以及充分验证了达成条件，如果最终社区同意了你的提案，2100 万上限改成 3000 万个也不是梦，一切都是可以操作的。</p>\n<p>这就回到了社区自治的特性上了，你承认并持有比特币，那么你就可以参与决策比特币的发展。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>好了，今天我们简要回顾了比特币的历史和货币形态，最后还介绍了 BIP，为下一篇介绍扩容之争做准备。</p>\n<p>其实比特币作为整个数字货币的标杆和领头，对区块链生态和未来有不可忽视的力量。虽然现在号称区块链 2.0、区块链 3.0 的项目很多，但是真正意义上达到了工业级水准的，还是只有比特币。</p>\n<p>无独有偶，我有一次在外面帮投资机构评估一个区块链项目，我也提到了信仰，项目方不约而同地表示持有，不过，他们的信仰是以太坊，所以今天的问题是，你觉得以太坊以后会取代比特币的地位吗？</p>\n","tags":["bitcoin","blockchain"]},{"title":"第18讲 | 智能合约与以太坊","url":"/2014/09/21/blockchain/blockchain-smart-contract-and-ethereum/","content":"<p>在前面的文章里，我们介绍了区块链的核心技术，也穿插介绍了一些项目。然而每个区块链都有自己的特色，接下来我们将针对每个项目进行详细讲解。今天我们就来讲讲智能合约和以太坊项目。<br><a id=\"more\"></a><br>几天我们从智能合约这个概念入手，聊聊什么是以太坊项目以及它的发展历史。最后还会介绍几款钱包给你，希望通过今天文章的讲解，你也可以尝试在以太坊上编写简单的智能合约。</p>\n<h3 id=\"智能合约的概念\"><a href=\"#智能合约的概念\" class=\"headerlink\" title=\"智能合约的概念\"></a>智能合约的概念</h3><p>不同于法律意义上的合约概念，区块链领域的合约表达的是可以“自治自理”的 计算机协议，这套协议具有自我执行、自我验证的属性。</p>\n<p>如果完全从技术角度来看，智能合约等价于一段事先就被规定好逻辑和条款的计算机代码被激活运行的状态，同时，智能合约也提供了通用的用户接口，用户可以通过接口与用户交互。</p>\n<p>智能合约这一概念早在 20 世纪 90 年代就有人提出，这个人是从事智能合约和数字货币研究的尼克萨博（Nick Szabo）博士，尼克 1996 年在《Extopy》期刊上发表了对智能合约的描述，他认为智能合约是一个由数字表单指定的承诺，这个承诺包含关系到多方执行的一组协议。</p>\n<p>从定义中我们可以得知，智能合约由多个协议组成，这些协议包含了用户接口，能表达用户的承诺，它可以安全有效地确定公共网络上的关系。</p>\n<p>换句话说，智能合约是一个由计算机处理、可执行合约条款的交易协议，其总体目标是满足协议既定的条件，例如支付、抵押、保密协议。这可以降低合约欺诈造成的损失，降低仲裁和强制执行所产生的成本以及其他的交易成本。</p>\n<p>我们举个实际的例子解释一下，今年 4 月 9 日，上海某建设银行支行开放了“无人银行”，银行中充斥了众多机器和显示屏，智慧柜员机、VTM 机、外汇兑换机、VR 设备和两台机器人代替了传统的柜台。</p>\n<p>这里的智慧柜员机、外汇兑换机器人众多电子设备都可以认为是智能合约的一种表现形式，用户在办理银行业务时，如办理大额汇兑业务，业务流程和逻辑依据已经定在程序中，用户只需要按照操作一步一步进行，办理完成后即可获得单据。</p>\n<p>这里“既定的业务流程、机器人模样的人机交互界面、双方同意承诺”组成了智能合约的概念，它甚至具有一定的法律效力。</p>\n<p>萨博提出的是智能合约的概念，以及我们举的例子，都是广义的智能合约概念。智能合约具有多种实践形式，而在区块领域所说的智能合约概念，我们其实是指 Blockchain-based 这种形式。</p>\n<p>在萨博的智能合约概念中提到了开放式网络，而我们知道开放式网络的基本要求就是拜占庭容错，通过前面文章的讲解我们知道，区块链天然具有拜占庭容错特性。所以如果在区块链上实践智能合约这个概念，两者会非常契合，天造地设。</p>\n<p>首先实践了智能合约这一概念的是比特币，比特币脚本（bitcoin script）包含了 5 种标准交易脚本，这些脚本的功能不仅仅提供了普通单人支付的情况，它还提供了多方共同签名支付的脚本，叫做多重签名支付，多重签名支付可以看成是萨博语义下的智能合约。</p>\n<p>除了比特币，发扬光大智能合约这个概念的区块链项目就是以太坊了，下面，我重点来介绍一下以太坊项目。</p>\n<h3 id=\"以太坊及其发展历史\"><a href=\"#以太坊及其发展历史\" class=\"headerlink\" title=\"以太坊及其发展历史\"></a>以太坊及其发展历史</h3><p>以太坊 Ethereum 项目的目标是打造一个去中心化的新一代互联网应用平台，这个平台称作 Dapp 平台。</p>\n<p>这些 Dapp 基于以太坊智能合约虚拟机开发、编译、部署，并且可以自定义业务逻辑，部署后全网可见且自动执行，理想情况下不存在宕机、审查、欺诈、第三方干预的情况。</p>\n<p>2013 年底以太坊的创始人 Vitalik 在比特币开发者社区提出了可以运行图灵完备（Turing-complete）形式的应用，但这一思想并没有得到比特币社区的支持。</p>\n<p>2014 年，Vitalik 带着自己的想法，宣布以太坊项目正式成立，2014 年上半年开始筹集资金，聚拢一些早期开发者，同年 7 月份进行了为期 42 天的 ICO，共筹集了超过 1800 万美元的比特币。</p>\n<p>2015 年 7 月，第一个版本的以太坊发布，主网正式上线，这一阶段 Bug 和设计缺陷较多，多是开发者在使用。</p>\n<p>2016 年以太坊发布第二个大版本 Homestead，用户逐渐多了起来，同期也吸纳了不少 Dapp 开发者。</p>\n<p>2016 年 6 月，以太坊上发生了著名的黑天鹅事件——TheDAO 事件，这打开了 ICO 市场，同时也造成了以太坊社区分叉，形成了以太坊和以太坊经典两个代币。</p>\n<p>2017 年 4 月，ICO 风靡中国，ERC20 提供了低成本方便高效的资金募集方式，为 ICO 提供了极大的便利，趁着数字货币牛市，以太坊的价格涨幅达十多倍，2018 年 1 月以太坊价格突破 1000 美元。</p>\n<h3 id=\"以太坊的核心概念\"><a href=\"#以太坊的核心概念\" class=\"headerlink\" title=\"以太坊的核心概念\"></a>以太坊的核心概念</h3><p>以太坊核心概念包括：智能合约虚拟机 EVM 和 Solidity 编程语言、账户模型、以太币和 Gas，交易和消息。</p>\n<h4 id=\"智能合约虚拟机-EVM-和-Solidity-编程语言\"><a href=\"#智能合约虚拟机-EVM-和-Solidity-编程语言\" class=\"headerlink\" title=\"智能合约虚拟机 EVM 和 Solidity 编程语言\"></a>智能合约虚拟机 EVM 和 Solidity 编程语言</h4><p>以太坊的核心概念首先是智能合约。</p>\n<p>智能合约包含两部分，一部分是开发语言，主要以 Solidity 为主，Solidity 与 Javascript 语言在使用上十分接近，这极大地降低了 Dapp 开发人员的学习成本。</p>\n<p>Dapp 开发者编写好代码以后，使用 Solidity 编译成十六进制字节码，然后部署到 EVM 上，也就是把合约广播到全网，等矿工打包后就形成了常年运行的 Dapp 了。</p>\n<p>另一部分就是 EVM。 EVM 是以太坊智能合约虚拟机，我们可以等价理解它为 Javascript、Python 等脚本语言的执行引擎。</p>\n<p>它是一个轻量级的虚拟机隔离环境，它并不提供访问本地网络、进程、文件系统的功能，它更像是一个封闭的容器，这个容器里面装了一个正在运行 Dapp，可以看成是无法和外界交互的 Docker Container。</p>\n<p>Dapp 在运行过程中，可以被请求或其他事件触发，然后执行相应的逻辑，这些请求和事件是由以太坊上的交易产生的，不是来自本地操作系统的事件。</p>\n<p>Dapp 运行过程中，每次状态发生变化，则意味着全网同步更新，大家的计算结果都是一致的，这有两个特性：</p>\n<p>所有 Dapp 的计算结果经过全网共识，一旦确认过几乎无法被伪造和篡改；<br>由于必须经过全网共识，所以这限制了整个网络的容量。</p>\n<h4 id=\"账户模型\"><a href=\"#账户模型\" class=\"headerlink\" title=\"账户模型\"></a>账户模型</h4><p>以太坊并没有采用 UTXO 模型，也不同于银行账户，它是由以太坊开发者设计了自己的账户模型。</p>\n<p>以太坊上的账户有两种类型，第一类叫做合约账户 CA（Contracts Accounts)，第二类叫做外部账户 EOA（Externally Owned Accounts）。</p>\n<p>简单理解就是：CA 是智能合约代码用的账户，EOA 是人用的账户；所以 CA 可以存储并执行智能合约代码，它的智能被 EOA 激活，它也不保存和存储私钥，合约账户可以调用其他合约。</p>\n<p>EOA 则是人们直接控制的账户，可以存储以太币，可以发送交易到合约账户，触发既定的逻辑。EOA 账户由公钥标识，由对应的私钥控制。</p>\n<p>当合约账户被调用时，存储其中的智能合约可以在矿工处的虚拟机中自动执行，并消耗 Gas，如果 Gas 不足则会触发“Out of Gas”异常，被终止执行。</p>\n<p>无论是 CA 还是 EOA，在以太坊内部都被看做状态对象（state objects），意思就是说这些账户都有自己的状态，EOA 具有以太币余额的状态，而 CA 除了余额，还多了合约存储状态。</p>\n<h4 id=\"以太币和-Gas\"><a href=\"#以太币和-Gas\" class=\"headerlink\" title=\"以太币和 Gas\"></a>以太币和 Gas</h4><p>Gas 是执行智能合约操作的燃料，智能合约的每一个步骤都会消耗 Gas，Gas 是由以太坊的平台代币以太币转化而来，最小单位是 wei，1ETH 相当于 10 的 18 次方 wei。</p>\n<p>以太币可以通过 PoW 挖矿而产生，目前以太坊主要通过 GPU 挖矿。挖出一个块可以换得 5 个以太币，并且还有一定的交易费、以及叔伯块的奖励。今年 4 月 6 日爆出著名矿机芯片厂商比特大陆已经开发出针对以太坊的 ASIC 专业矿机，相比 GPU 的效率提升 2.5 倍。</p>\n<h4 id=\"交易和消息\"><a href=\"#交易和消息\" class=\"headerlink\" title=\"交易和消息\"></a>交易和消息</h4><p>以太坊上的交易与比特币中的 UTXO 交易不同，它是指 EOA 账户将一个经过签名的数据包发送到另外一个账户的过程，这个过程产生的账户状态变化将被存储到以太坊区块链上。</p>\n<p>以太坊上除了交易还有消息这个概念，消息指一个合约账户调用其他合约账户的过程，可以类比函数调用过程。</p>\n<p>所以以太坊上的 Dapp 如果被触发，有两种可能，第一种是交易触发，第二种是消息触发。</p>\n<p>这两种的区别在于前者是 EOA 发起的，后者只能是其他合约账户发起的。</p>\n<p>状态对象的状态变化被以太坊共识机制的记录下来，交易和消息驱动着状态的变化，于是，在一个开放式的网络中构建一个全球共享的 Dapp 变得十分方便。</p>\n<p>以太坊上智能合约具有全网准实时同步、准确执行、去中心化运行、较低的人为干预风险等特性，EVM 和 Solidity 为全球开发者提供了较低的进入门槛。</p>\n<h4 id=\"与比特币的主要区别\"><a href=\"#与比特币的主要区别\" class=\"headerlink\" title=\"与比特币的主要区别\"></a>与比特币的主要区别</h4><p>以太坊项目又被称作区块链 2.0 项目，这里 2.0 就是指智能合约。那么以太坊与比特币相比，到底智能在那里呢？我们具体来看看。</p>\n<p>与比特币相比，以太坊首先不是一个单纯的数字货币项目，它可以提供全世界无差别的区块链智能合约应用平台，这个平台基于我们前面文章所介绍的区块链四大核心技术要素，即 P2P 网络、共识机制、账户模型、加密模块。</p>\n<p>除了以上的四个技术要素，以太坊还推出了 EVM——以太坊智能合约虚拟机，并且，它还推出了自己的智能合约语言 Solidity。</p>\n<p>于是，区块链的开发者因为智能合约的出现开始分为两类。第一类是公链底层开发者，主要是以 C++ 和 Go 语言为主的全节点开发者，他们需要对区块链各个技术模块有很深的理解。</p>\n<p>第二类是智能合约开发者，也就是应用开发者，这类开发者对区块链的运行原理不需要理解很深，只需要会编写 Solidity，了解规范即可。</p>\n<p>除了以太坊智能合约这个概念以外，它还设计了下面的内容。</p>\n<ul>\n<li>研究并实现了自己的 PoW 挖矿算法——ETHASH，这是一个内存困难型的挖矿算法。<br>叔伯块激励机制，降低了挖矿中心化的趋势。 取消了 UTXO 模型，采用了账户模型和世界状态，提供了数据结构的可塑性。</li>\n<li>设计了 Gas 机制，避免程序死循环消耗全网资源的情况出现。 研究并实现了自己的 PoS 共识算法——Casper，可防止 Nothing-at-Stake 攻击。</li>\n<li>以太坊提供了在区块链自由编程的能力，智能合约让所有人得以开发属于自己的 Dapp，这是与比特币作为单纯的数字货币所不具有的能力。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本篇我们介绍了智能合约的概念以及以太坊项目，并且讲解了与比特币的主要区别，以太坊上的一些核心概念，下一篇我们将结合实际案例讲解智能合约，带领你认识一些智能合约模板，并顺便介绍一下其他区块链智能合约平台。</p>\n","tags":["blockchain","smart_contract","ethereum"]},{"title":"HTTPS原理大白话","url":"/2018/06/08/frontend/https-principle/","content":"<p>HTTPS（全称：HyperText Transfer Protocol over Secure Socket Layer），其实 HTTPS 并不是一个新鲜协议，Google 很早就开始启用了，初衷是为了保证数据安全。 近两年，Google、Baidu、Facebook 等这样的互联网巨头，不谋而合地开始大力推行 HTTPS， 国内外的大型互联网公司很多也都已经启用了全站 HTTPS，这也是未来互联网发展的趋势。<br><a id=\"more\"></a></p>\n<p>为鼓励全球网站的 HTTPS 实现，一些互联网公司都提出了自己的要求：</p>\n<ol>\n<li>Google 已调整搜索引擎算法，让采用 HTTPS 的网站在搜索中排名更靠前；</li>\n<li>从 2017 年开始，Chrome 浏览器已把采用 HTTP 协议的网站标记为不安全网站；</li>\n<li>苹果要求 2017 年 App Store 中的所有应用都必须使用 HTTPS 加密连接；</li>\n<li>当前国内炒的很火热的微信小程序也要求必须使用 HTTPS 协议；</li>\n<li>新一代的 HTTP/2 协议的支持需以 HTTPS 为基础。</li>\n</ol>\n<p>等等，因此想必在不久的将来，全网 HTTPS 势在必行。</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><ol>\n<li><p>HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是客户端浏览器或其他程序与Web服务器之间的应用层通信协议 。</p>\n</li>\n<li><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。</p>\n</li>\n</ol>\n<p><img data-src=\"/images/https-principle/1.png\" alt=\"\"></p>\n<p>如上图所示 HTTPS 相比 HTTP 多了一层 SSL/TLS</p>\n<p>SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p>\n<p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。</p>\n<h3 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h3><p>据记载，公元前400年，古希腊人就发明了置换密码；在第二次世界大战期间，德国军方启用了“恩尼格玛”密码机，所以密码学在社会发展中有着广泛的用途。</p>\n<h4 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h4><p>有流式、分组两种，加密和解密都是使用的同一个密钥。</p>\n<p>例如：DES、AES-GCM、ChaCha20-Poly1305等</p>\n<h4 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h4><p>加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。</p>\n<p>例如：RSA、DSA、ECDSA、 DH、ECDHE</p>\n<h4 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h4><p>将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。</p>\n<p>例如：MD5、SHA-1、SHA-2、SHA-256 等</p>\n<h4 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h4><p>签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。</p>\n<h2 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h2><h3 id=\"一、HTTP-访问过程\"><a href=\"#一、HTTP-访问过程\" class=\"headerlink\" title=\"一、HTTP 访问过程\"></a>一、HTTP 访问过程</h3><p><img data-src=\"/images/https-principle/2.png\" alt=\"\"></p>\n<p>抓包如下：</p>\n<p><img data-src=\"/images/https-principle/3.png\" alt=\"\"></p>\n<p>如上图所示，HTTP请求过程中，客户端与服务器之间没有任何身份确认的过程，数据全部明文传输，“裸奔”在互联网上，所以很容易遭到黑客的攻击，如下：</p>\n<p><img data-src=\"/images/https-principle/4.png\" alt=\"\"></p>\n<p>可以看到，客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”，现象如下：</p>\n<p>下面两图中，浏览器中填入的是相同的URL，左边是正确响应，而右边则是被劫持后的响应</p>\n<p><img data-src=\"/images/https-principle/5.png\" alt=\"\"></p>\n<p>所以 HTTP 传输面临的风险有：</p>\n<ol>\n<li>窃听风险：黑客可以获知通信内容。</li>\n<li>篡改风险：黑客可以修改通信内容。</li>\n<li>冒充风险：黑客可以冒充他人身份参与通信。</li>\n</ol>\n<h3 id=\"二、HTTP-向-HTTPS-演化的过程\"><a href=\"#二、HTTP-向-HTTPS-演化的过程\" class=\"headerlink\" title=\"二、HTTP 向 HTTPS 演化的过程\"></a>二、HTTP 向 HTTPS 演化的过程</h3><p>第一步：为了防止上述现象的发生，人们想到一个办法：对传输的信息加密（即使黑客截获，也无法破解）</p>\n<p><img data-src=\"/images/https-principle/6.png\" alt=\"\"></p>\n<p>如上图所示，此种方式属于对称加密，双方拥有相同的密钥，信息得到安全传输，但此种方式的缺点是：</p>\n<ol>\n<li>不同的客户端、服务器数量庞大，所以双方都需要维护大量的密钥，维护成本很高</li>\n<li>因每个客户端、服务器的安全级别不同，密钥极易泄露</li>\n</ol>\n<p>第二步：既然使用对称加密时，密钥维护这么繁琐，那我们就用非对称加密试试</p>\n<p><img data-src=\"/images/https-principle/7.png\" alt=\"\"></p>\n<p>如上图所示，客户端用公钥对请求内容加密，服务器使用私钥对内容解密，反之亦然，但上述过程也存在缺点：</p>\n<ol>\n<li>公钥是公开的（也就是黑客也会有公钥），所以第 ④ 步私钥加密的信息，如果被黑客截获，其可以使用公钥进行解密，获取其中的内容</li>\n</ol>\n<p>第三步：非对称加密既然也有缺陷，那我们就将对称加密，非对称加密两者结合起来，取其精华、去其糟粕，发挥两者的各自的优势</p>\n<p><img data-src=\"/images/https-principle/8.png\" alt=\"\"></p>\n<p>如上图所示</p>\n<ol>\n<li>第 ③ 步时，客户端说：（咱们后续回话采用对称加密吧，这是对称加密的算法和对称密钥）这段话用公钥进行加密，然后传给服务器</li>\n<li>服务器收到信息后，用私钥解密，提取出对称加密算法和对称密钥后，服务器说：（好的）对称密钥加密</li>\n<li>后续两者之间信息的传输就可以使用对称加密的方式了</li>\n</ol>\n<p>遇到的问题：</p>\n<ol>\n<li>客户端如何获得公钥</li>\n<li>如何确认服务器是真实的而不是黑客</li>\n</ol>\n<p>第四步：获取公钥与确认服务器身份</p>\n<p><img data-src=\"/images/https-principle/9.png\" alt=\"\"></p>\n<p>1、获取公钥</p>\n<ul>\n<li>提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）</li>\n<li>会话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥）</li>\n</ul>\n<p>2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书</p>\n<p><img data-src=\"/images/https-principle/10.png\" alt=\"\"></p>\n<p>如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有：</p>\n<ol>\n<li>证书的发布机构CA</li>\n<li>证书的有效期</li>\n<li>公钥</li>\n<li>证书所有者</li>\n<li>签名</li>\n<li>………</li>\n</ol>\n<p>3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下：</p>\n<ol>\n<li>首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验</li>\n<li>浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</li>\n<li>如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</li>\n<li>如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密</li>\n<li>浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</li>\n<li>对比结果一致，则证明服务器发来的证书合法，没有被冒充</li>\n<li>此时浏览器就可以读取证书中的公钥，用于后续加密了</li>\n</ol>\n<p>4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成</p>\n<p>所以相比HTTP，HTTPS 传输更加安全</p>\n<ol>\n<li>所有信息都是加密传播，黑客无法窃听。</li>\n<li>具有校验机制，一旦被篡改，通信双方会立刻发现。</li>\n<li>配备身份证书，防止身份被冒充。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>综上所述，相比 HTTP 协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。所以在这个互联网膨胀的时代，其中隐藏着各种看不见的危机，为了保证数据的安全，维护网络稳定，</p>\n","categories":["FrontEnd","http"],"tags":["https"]},{"title":"React哲学","url":"/2020/08/06/frontend/react-philosophy/","content":"<p>React 最棒的部分之一是引导我们思考如何构建一个应用。在这篇文档中，我们将会通过 React 构建一个可搜索的产品数据表格来更深刻地领会 React 哲学。<br><a id=\"more\"></a></p>\n<h2 id=\"从设计稿开始\"><a href=\"#从设计稿开始\" class=\"headerlink\" title=\"从设计稿开始\"></a>从设计稿开始</h2><p>假设我们已经有了一个返回 JSON 的 API，以及设计师提供的组件设计稿。如下所示：</p>\n<p><img data-src=\"/images/react-philosophy/1.png\" alt=\"\"></p>\n<p>该 JSON API 会返回以下数据：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;,</span><br><span class=\"line\">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;,</span><br><span class=\"line\">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;,</span><br><span class=\"line\">  &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;,</span><br><span class=\"line\">  &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;,</span><br><span class=\"line\">  &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"第一步：将设计好的-UI-划分为组件层级\"><a href=\"#第一步：将设计好的-UI-划分为组件层级\" class=\"headerlink\" title=\"第一步：将设计好的 UI 划分为组件层级\"></a>第一步：将设计好的 UI 划分为组件层级</h2><p>首先，你需要在设计稿上用方框圈出每一个组件（包括它们的子组件），并且以合适的名称命名。如果你是和设计师一起完成此任务，那么他们可能已经做过类似的工作，所以请和他们进行交流！他们的 Photoshop 的图层名称可能最终就是你编写的 React 组件的名称！</p>\n<p>但你如何确定应该将哪些部分划分到一个组件中呢？你可以将组件当作一种函数或者是对象来考虑，根据单一功能原则来判定组件的范围。也就是说，<strong>一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。</strong></p>\n<p>在实践中，因为你经常是在向用户展示 JSON 数据模型，所以如果你的模型设计得恰当，UI（或者说组件结构）便会与数据模型一一对应，这是因为 UI 和数据模型都会倾向于遵守相同的信息结构。将 UI 分离为组件，其中每个组件需与数据模型的某部分匹配。</p>\n<p><img data-src=\"/images/react-philosophy/2.png\" alt=\"\"></p>\n<p>你会看到我们的应用中包含五个组件。我们已经将每个组件展示的数据标注为了斜体。</p>\n<ol>\n<li>FilterableProductTable (橙色): 是整个示例应用的整体</li>\n<li>SearchBar (蓝色): 接受所有的用户输入</li>\n<li>ProductTable (绿色): 展示数据内容并根据用户输入筛选结果</li>\n<li>ProductCategoryRow (天蓝色): 为每一个产品类别展示标题</li>\n<li>ProductRow (红色): 每一行展示一个产品</li>\n</ol>\n<p>你可能注意到，ProductTable 的表头（包含 “Name” 和 “Price” 的那一部分）并未单独成为一个组件。这仅仅是一种偏好选择，如何处理这一问题也一直存在争论。就这个示例而言，因为表头只起到了渲染数据集合的作用——这与 ProductTable 是一致的，所以我们仍然将其保留为 ProductTable 的一部分。但是，如果表头过于复杂（例如，我们需为其添加排序功能），那么将它作为一个独立的 ProductTableHeader 组件就显得很有必要了。</p>\n<p>现在我们已经确定了设计稿中应该包含的组件，接下来我们将把它们描述为更加清晰的层级。设计稿中被其他组件包含的子组件，在层级上应该作为其子节点。</p>\n<ul>\n<li>FilterableProductTable<ul>\n<li>SearchBar</li>\n<li>ProductTable<ul>\n<li>ProductCategoryRow</li>\n<li>ProductRow</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第二步：用-React-创建一个静态版本\"><a href=\"#第二步：用-React-创建一个静态版本\" class=\"headerlink\" title=\"第二步：用 React 创建一个静态版本\"></a>第二步：用 React 创建一个静态版本</h2><p>现在我们已经确定了组件层级，可以编写对应的应用了。最容易的方式，是先用已有的数据模型渲染一个不包含交互功能的 UI。<strong>最好将渲染 UI 和添加交互这两个过程分开。</strong>这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。我们会在接下来的代码中体会到其中的区别。</p>\n<p>在构建应用的静态版本时，我们需要创建一些会重用其他组件的组件，然后通过 <code>props</code> 传入所需的数据。<code>props</code> 是父组件向子组件传递数据的方式。即使你已经熟悉了 <code>state</code> 的概念，也完全不应该使用 <code>state</code> 构建静态版本。<strong><code>state</code> 代表了随时间会产生变化的数据，应当仅在实现交互时使用。</strong>所以构建应用的静态版本时，你不会用到它。</p>\n<p>你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件（比如 FilterableProductTable），自下而上意味着从最基本的组件开始编写（比如 ProductRow）。<strong>当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。</strong></p>\n<p>到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。由于我们构建的是静态版本，所以这些组件目前只需提供 <code>render()</code> 方法用于渲染。最顶层的组件 FilterableProductTable 通过 <code>props</code> 接受你的数据模型。如果你的数据模型发生了改变，再次调用 <code>ReactDOM.render()</code>，UI 就会相应地被更新。<strong>数据模型变化、调用 render() 方法、UI 相应变化，这个过程并不复杂，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。React 单向数据流（也叫单向绑定）的思想使得组件模块化，易于快速开发。</strong></p>\n<p>如果你在完成这一步骤时遇到了困难，可以参阅 React 文档。</p>\n<blockquote>\n<p>补充说明: 有关 <code>props</code> 和 <code>state</code></p>\n<p>在 React 中，有两类“模型”数据：props 和 state。清楚地理解两者的区别是十分重要的；如果你不太有把握，可以参阅 React 官方文档。你也可以查看 FAQ: state 与 props 的区别是什么？</p>\n</blockquote>\n<h2 id=\"第三步：确定-UI-state-的最小（且完整）表示\"><a href=\"#第三步：确定-UI-state-的最小（且完整）表示\" class=\"headerlink\" title=\"第三步：确定 UI state 的最小（且完整）表示\"></a>第三步：确定 UI state 的最小（且完整）表示</h2><p>想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过实现 <code>state</code> 来完成这个任务。</p>\n<p>为了正确地构建应用，你首先需要找出应用所需的 <code>state</code> 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 <strong>DRY: Don’t Repeat Yourself</strong>。只保留应用所需的可变 <code>state</code> 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。</p>\n<p>我们的示例应用拥有如下数据：</p>\n<ul>\n<li>包含所有产品的原始列表</li>\n<li>用户输入的搜索词</li>\n<li>复选框是否选中的值</li>\n<li>经过搜索筛选的产品列表</li>\n</ul>\n<p>通过问自己以下三个问题，你可以逐个检查相应数据是否属于 <code>state</code>：</p>\n<ol>\n<li>该数据是否是由父组件通过 <code>props</code> 传递而来的？如果是，那它应该不是 <code>state</code>。</li>\n<li>该数据是否随时间的推移而保持不变？如果是，那它应该也不是 <code>state</code>。</li>\n<li>你能否根据其他 <code>state</code> 或 <code>props</code> 计算出该数据的值？如果是，那它也不是 <code>state</code>。</li>\n</ol>\n<p>包含所有产品的原始列表是经由 <code>props</code> 传入的，所以它不是 <code>state</code>；搜索词和复选框的值应该是 state，因为它们随时间会发生改变且无法由其他数据计算而来；经过搜索筛选的产品列表不是 state，因为它的结果可以由产品的原始列表根据搜索词和复选框的选择计算出来。</p>\n<p>综上所述，属于 <code>state</code> 的有：</p>\n<ul>\n<li>用户输入的搜索词</li>\n<li>复选框是否选中的值</li>\n</ul>\n<h2 id=\"第四步：确定-state-放置的位置\"><a href=\"#第四步：确定-state-放置的位置\" class=\"headerlink\" title=\"第四步：确定 state 放置的位置\"></a>第四步：确定 state 放置的位置</h2><p>我们已经确定了应用所需的 <code>state</code> 的最小集合。接下来，我们需要确定哪个组件能够改变这些 <code>state</code> ，或者说拥有这些 <code>state</code>。</p>\n<p>注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 <code>state</code> 这件事，对初学者来说往往是最难理解的部分。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：</p>\n<p>对于应用中的每一个 <code>state</code>：</p>\n<ul>\n<li>找到根据这个 <code>state</code> 进行渲染的所有组件。</li>\n<li>找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 <code>state</code> 的组件）。</li>\n<li>该共同所有者组件或者比它层级更高的组件应该拥有该 <code>state</code>。</li>\n<li>如果你找不到一个合适的位置来存放该 <code>state</code>，就可以直接创建一个新的组件来存放该 <code>state</code>，并将这一新组件置于高于共同所有者组件层级的位置。</li>\n</ul>\n<p>根据以上策略重新考虑我们的示例应用：</p>\n<ul>\n<li>ProductTable 需要根据 <code>state</code> 筛选产品列表。SearchBar 需要展示搜索词和复选框的状态。</li>\n<li>他们的共同所有者是 FilterableProductTable。</li>\n<li>因此，搜索词和复选框的值应该很自然地存放在 FilterableProductTable 组件中。</li>\n</ul>\n<p>很好，我们已经决定把这些 <code>state</code> 存放在 FilterableProductTable 组件中。首先，将实例属性 <code>this.state = {filterText: &#39;&#39;, inStockOnly: false}</code> 添加到 FilterableProductTable 的 <code>constructor</code> 中，设置应用的初始 <code>state</code>；接着，将 filterText 和 inStockOnly 作为 <code>props</code> 传入 ProductTable 和 SearchBar；最后，用这些 <code>props</code> 筛选 ProductTable 中的产品信息，并设置 SearchBar 的表单值。</p>\n<p>你现在可以看到应用的变化了：将 filterText 设置为 &quot;ball&quot; 并刷新应用，你能发现表格中的数据已经更新了。</p>\n<h2 id=\"第五步：添加反向数据流\"><a href=\"#第五步：添加反向数据流\" class=\"headerlink\" title=\"第五步：添加反向数据流\"></a>第五步：添加反向数据流</h2><p>到目前为止，我们已经借助自上而下传递的 <code>props</code> 和 <code>state</code> 渲染了一个应用。现在，我们将尝试让数据反向传递：处于较低层级的表单组件更新较高层级的 FilterableProductTable 中的 <code>state</code>。</p>\n<p><strong>React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。</strong></p>\n<p>如果你在这时尝试在搜索框输入或勾选复选框，React 不会产生任何响应。这是正常的，因为我们之前已经将 input 的值设置为了从 FilterableProductTable 的 <code>state</code> 传递而来的固定值。</p>\n<p>让我们重新梳理一下需要实现的功能：每当用户改变表单的值，我们需要改变 <code>state</code> 来反映用户的当前输入。由于 <code>state</code> 只能由拥有它们的组件进行更改，FilterableProductTable 必须将一个能够触发 <code>state</code> 改变的回调函数（callback）传递给 SearchBar。我们可以使用输入框的 <code>onChange</code> 事件来监视用户输入的变化，并通知 FilterableProductTable 传递给 SearchBar 的回调函数。然后该回调函数将调用 <code>setState()</code>，从而更新应用。</p>\n<h2 id=\"这就是全部了\"><a href=\"#这就是全部了\" class=\"headerlink\" title=\"这就是全部了\"></a>这就是全部了</h2><p>希望这篇文档能够帮助你建立起构建 React 组件和应用的一般概念。尽管你可能需要编写更多的代码，但是别忘了：<strong>比起写，代码更多地是给人看的</strong>。我们一起构建的这个模块化示例应用的代码就很易于阅读。当你开始构建更大的组件库时，你会意识到这种代码模块化和清晰度的重要性。并且随着代码重用程度的加深，你的代码行数也会显著地减少。:)</p>\n","categories":["FrontEnd"],"tags":["React"]},{"title":"用动图展示10大 Git 命令","url":"/2020/04/23/git/display-10-git-command-by-gif/","content":"<p><code>git merge</code>、<code>git rebase</code>、<code>git reset</code>、<code>git revert</code>、<code>git fetch</code>、<code>git pull</code>、<code>git reflog</code>……你知道这些 <code>git</code> 命令执行的究竟是什么任务吗？如果你还有些分不清楚，那千万不能错过这篇文章。<br><a id=\"more\"></a></p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/1.webp\" alt=\"\"></p>\n<p>本文将介绍的很多命令都有可选参数——你可以使用这些参数来改变对应命令的行为。而本文的示例只会涵盖命令的默认行为，而不会添加（或添加太多）可选配置！</p>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>拥有多个分支是很方便的，这样可以将不同的新修改互相隔离开，而且还能确保你不会意外地向生产代码推送未经许可或破损的代码修改。但一旦这些修改得到了批准许可，我们就需要将其部署到我们的生产分支中！</p>\n<p>可将一个分支的修改融入到另一个分支的一种方式是执行 git merge。Git 可执行两种类型的合并：fast-forward 和 no-fast-forward。现在你可能分不清，但我们马上就来看看它们的差异所在。</p>\n<h3 id=\"Fast-forward-—ff\"><a href=\"#Fast-forward-—ff\" class=\"headerlink\" title=\"Fast-forward (—ff)\"></a><code>Fast-forward (—ff)</code></h3><p>在当前分支相比于我们要合并的分支没有额外的提交（commit）时，可以执行 fast-forward 合并。Git 很懒，首先会尝试执行最简单的选项：fast-forward！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/2.gif\" alt=\"\"></p>\n<p>完美！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。那么 no-fast-forward 又是什么意思呢？</p>\n<h3 id=\"No-fast-foward-—no-ff\"><a href=\"#No-fast-foward-—no-ff\" class=\"headerlink\" title=\"No-fast-foward (—no-ff)\"></a><code>No-fast-foward (—no-ff)</code></h3><p>如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git 将会执行 no-fast-forward 合并。</p>\n<p>使用 no-fast-forward 合并时，Git 会在当前活动分支上创建新的 merging commit。这个提交的父提交（parent commit）即指向这个活动分支，也指向我们想要合并的分支！</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/3.gif\" alt=\"\"></p>\n<p>没什么大不了的，完美的合并！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。</p>\n<h2 id=\"合并冲突\"><a href=\"#合并冲突\" class=\"headerlink\" title=\"合并冲突\"></a>合并冲突</h2><p>尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git 就不知道如何取舍了。</p>\n<p>在这样的情况下，Git 会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了 <code>README.md</code> 的第一行。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/4.png\" alt=\"\"></p>\n<p>如果我们想把 dev 合并到 master，就会出现一个合并冲突：你想要标题是 Hello! 还是 Hey!？</p>\n<p>当尝试合并这些分支时，Git 会向你展示冲突出现的位置。我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/5.gif\" alt=\"\"></p>\n<p>完成！尽管合并冲突往往很让人厌烦，但这是合理的：Git 不应该瞎猜我们想要保留哪些修改。</p>\n<h2 id=\"变基（Rebasing）\"><a href=\"#变基（Rebasing）\" class=\"headerlink\" title=\"变基（Rebasing）\"></a>变基（Rebasing）</h2><p>我们刚看到可通过执行 <code>git merge</code> 将一个分支的修改应用到另一个分支。另一种可将一个分支的修改融入到另一个分支的方式是执行 <code>git rebase</code>。</p>\n<p><code>git rebase</code> 会将当前分支的提交复制到指定的分支之上。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/6.gif\" alt=\"\"></p>\n<p>完美，现在我们在 dev 分支上获取了 master 分支上的所有修改。</p>\n<p>变基与合并有一个重大的区别：Git 不会尝试确定要保留或不保留哪些文件。我们执行 rebase 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录。</p>\n<p>上面这个例子展示了在 master 分支上的变基。但是，在更大型的项目中，你通常不需要这样的操作。git rebase 在为复制的提交创建新的 hash 时会修改项目的历史记录。</p>\n<p>如果你在开发一个 feature 分支并且 master 分支已经更新过，那么变基就很好用。你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。</p>\n<h2 id=\"交互式变基（Interactive-Rebase）\"><a href=\"#交互式变基（Interactive-Rebase）\" class=\"headerlink\" title=\"交互式变基（Interactive Rebase）\"></a>交互式变基（Interactive Rebase）</h2><p>在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。</p>\n<p>在我们正在 rebase 的提交上，我们可以执行以下 6 个动作：</p>\n<ul>\n<li>reword：修改提交信息；</li>\n<li>edit：修改此提交；</li>\n<li>squash：将提交融合到前一个提交中；</li>\n<li>fixup：将提交融合到前一个提交中，不保留该提交的日志消息；</li>\n<li>exec：在每个提交上运行我们想要 rebase 的命令；</li>\n<li>drop：移除该提交。</li>\n</ul>\n<p>很棒！这样我们就能完全控制我们的提交了。如果你想要移除一个提交，只需 <code>drop</code> 即可。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/7.gif\" alt=\"\"></p>\n<p>如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/8.gif\" alt=\"\"></p>\n<p>交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。</p>\n<h2 id=\"重置（Resetting）\"><a href=\"#重置（Resetting）\" class=\"headerlink\" title=\"重置（Resetting）\"></a>重置（Resetting）</h2><p>当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 WIP 提交或者可能是引入了 bug 的提交，这时候就要执行 <code>git reset</code>。</p>\n<p><code>git reset</code> 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。</p>\n<h3 id=\"软重置\"><a href=\"#软重置\" class=\"headerlink\" title=\"软重置\"></a>软重置</h3><p>软重置会将 HEAD 移至指定的提交（或与 HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！</p>\n<p>假设我们不想保留添加了一个 style.css 文件的提交 9e78i，而且我们也不想保留添加了一个 index.js 文件的提交 035cc。但是，我们确实又想要保留新添加的 style.css 和 index.js 文件！这是软重置的一个完美用例。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/9.gif\" alt=\"\"></p>\n<p>输入 git status 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！</p>\n<h3 id=\"硬重置\"><a href=\"#硬重置\" class=\"headerlink\" title=\"硬重置\"></a>硬重置</h3><p>有时候我们并不想保留特定提交引入的修改。不同于软重置，我们应该再也无需访问它们。Git 应该直接将整体状态直接重置到特定提交之前的状态：这甚至包括你在工作目录中和暂存文件上的修改。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/10.gif\" alt=\"\"></p>\n<p>Git 丢弃了 9e78i 和 035cc 引入的修改，并将状态重置到了 ec5be 的状态。</p>\n<h2 id=\"还原（Reverting）\"><a href=\"#还原（Reverting）\" class=\"headerlink\" title=\"还原（Reverting）\"></a>还原（Reverting）</h2><p>另一种撤销修改的方法是执行 git revert。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。</p>\n<p>假设 ec5be 添加了一个 index.js 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/11.gif\" alt=\"\"></p>\n<p>完美！提交 9e78i 还原了由提交 ec5be 引入的修改。在撤销特定的提交时，git revert 非常有用，同时也不会修改分支的历史。</p>\n<h2 id=\"拣选（Cherry-picking）\"><a href=\"#拣选（Cherry-picking）\" class=\"headerlink\" title=\"拣选（Cherry-picking）\"></a>拣选（Cherry-picking）</h2><p>当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 cherry-pick！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。</p>\n<p>假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。我们并不想要整个 dev 分支，而只需要这个提交！</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/12.gif\" alt=\"\"></p>\n<p>现在 master 分支包含 76d12 引入的修改了。</p>\n<h2 id=\"取回（Fetchin）\"><a href=\"#取回（Fetchin）\" class=\"headerlink\" title=\"取回（Fetchin）\"></a>取回（Fetchin）</h2><p>如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。比如当合并了另一个分支或你的同事推送了一个快速修复时。</p>\n<p>通过在这个远程分支上执行 git fetch，我们就可在本地获取这些修改。这不会以任何方式影响你的本地分支：fetch 只是单纯地下载新的数据而已。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/13.gif\" alt=\"\"></p>\n<p>现在我们可以看到自上次推送以来的所有修改了。这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。</p>\n<h2 id=\"拉取（Pulling）\"><a href=\"#拉取（Pulling）\" class=\"headerlink\" title=\"拉取（Pulling）\"></a>拉取（Pulling）</h2><p>尽管 <code>git fetch</code> 可用于获取某个分支的远程信息，但我们也可以执行 <code>git pull</code>。<code>git pull</code> 实际上是两个命令合成了一个：<code>git fetch</code> 和 <code>git merge</code>。当我们从来源拉取修改时，我们首先是像 <code>git fetch</code> 那样取回所有数据，然后最新的修改会自动合并到本地分支中。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/14.gif\" alt=\"\"></p>\n<p>很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！</p>\n<h2 id=\"Reflog\"><a href=\"#Reflog\" class=\"headerlink\" title=\"Reflog\"></a>Reflog</h2><p>每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。</p>\n<p><code>git reflog</code> 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/15.gif\" alt=\"\"></p>\n<p>如果你犯了错，你可以根据 <code>reflog</code> 提供的信息通过重置 HEAD 来轻松地重做！</p>\n<p>假设我们实际上并不需要合并原有分支。当我们执行 <code>git reflog</code> 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。</p>\n<p><img data-src=\"/images/display-10-git-command-by-gif/16.gif\" alt=\"\"></p>\n<p>我们可以看到最新的动作已被推送给 <code>reflog</code>。</p>\n","categories":["tools"],"tags":["note","git","tools"]},{"title":"人类工具简史","url":"/2024/01/04/knowledge/human-tools-history/","content":"<p>人类发展经历了漫长时期。最重要的进化，是学会使用工具，有了“技术”。没有工具，人类就是一个脆弱的物种，没有任何人种可以手无寸铁面对自然。技术伴随人类成长，从野蛮走向文明。人类历史就是一部技术史。<br><a id=\"more\"></a></p>\n<div class=\"posts-collapse\">\n    <div class=\"collection-title\">\n        <span class=\"collection-header\">很久以前，人与动物没有明显区别，过着茹毛饮血的生活。</span>\n    </div>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">约150万到250万年前，能人出现。旧石器时代开始</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">打制石器</div>\n            <span>采割果实，捕猎动物，剥制兽皮。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">约20万到200万年前，直立人出现</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">火</div>\n            <span>煮熟食物、提供温暖，加快了人类进化。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">语言</div>\n            <span>交换、传递思想，编造故事、信条，集结同类。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">约12000年前，新石器时代开始</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">制陶技术</div>\n            <span>建造房屋、器皿。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">掌握植物生长规律</div>\n            <span>从食物采集转至食物生产，发展出农业和牧业技术。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">编织技术</div>\n            <span>剪羊毛，种植亚麻和棉花，纺线，织布。人类开始定居。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">约6000年前，青铜器时代开始</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">金属制造</div>\n            <span>采矿、冶炼、锻造和铸造等复杂技术出现，出现了车、船。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">灌溉技术和农业技术</div>\n            <span>生产力提高，人口增加，国家开始出现。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">书写和计算</div>\n            <span>用于分配剩余产品。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">历法</div>\n            <span>用于农业、仪式活动和经济活动。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">天文学、占星术、巫术</div>\n            <span>预测庄稼收成、军事行动或皇帝的未来。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">医术</div>\n            <span>积累解剖学和草药的经验和知识。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">青铜器时代后期，出现埃及、华夏、印度、希腊、罗马等古文明</span>\n    </div>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">公元前600年，古希腊时代</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">科学，又称为自然哲学</div>\n            <span>开始了发现世界和认识自然的观察和思索</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">公元前100年</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">水泥</div>\n            <span>改变了建筑工程和人居面貌。水泥支撑了罗马帝国的扩张。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">此后的一千多年里，中国成为技术输出的中心</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">造纸术，印刷术</div>\n            <span>对人类文明的传播具有深远影响。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">火药</div>\n            <span>以其杀伤力和震慑力，带来安全感与战争。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">指南针</div>\n            <span>在航海上的应用对地理大发现和海上贸易有极大的促进作用。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">铸铁</div>\n            <span>对生产和生活产生了重大推进作用。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">瓷器</div>\n            <span>中华文明的瑰宝，极具生产、生活和艺术价值。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">挽具</div>\n            <span>马替代牛，提高了效率，扩大了人的活动范围。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">马镫</div>\n            <span>让骑手稳坐马背，使骑士成为职业军人，由贵族领主供养，由此产生了封建关系。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">新能源，水车、风车</div>\n            <span>机械的使用节省了劳力，奴隶制度随之消失。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">火炮、滑膛枪</div>\n            <span>冷兵器退出历史，削弱了骑士和封建领主的军事作用，取而代之的是用火药装备的陆军海军。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">大学</div>\n            <span>培养牧师、医生、律师。</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">万有引力和三大运动定律</div>\n            <span>奠定此后三个世纪物理学和天文学的基础。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">18世纪六十年代，第一次工业革命</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">蒸汽机</div>\n            <span>加快了新能源（煤）的开采和使用，人类进入“机器时代”。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">1814年</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">蒸汽机车</div>\n            <span>迎来铁路时代</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">汽车</div>\n            <span>卡尔•本茨制造出世界上第一辆汽车</span>\n        </header>\n    </article>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">汽车流水线</div>\n            <span>亨利•福特在汽车工业中发展成生产流水线。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">1870年，第二次工业革命</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">电力</div>\n            <span>发电机、电动机、电力系统、电灯、电车、电话、电报，电影放映机以及以煤气和燃油为能源的内燃机、柴油机、内燃汽车、远洋轮船、飞机等，令能源、制造、交通、通讯、材料、供水等发生革命性变革，生产力空前发展，人类社会开始步入电气化时代。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">20世纪，信息时代</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">集成电路、微处理器和互联网</div>\n            <span>揭开了科技发展的新一页。</span>\n        </header>\n    </article>\n    <div class=\"collection-year\">\n        <span class=\"collection-header\">21世纪，智能时代</span>\n    </div>\n    <article>\n        <header class=\"post-header\">\n            <div class=\"post-meta\">人工智能，云计算，机器人</div>\n            <span>展示了无可限量的前景。</span>\n        </header>\n    </article>\n</div>","tags":["note"]},{"title":"11个方法，让高度同质化产品也能快速找到差异化的价值主张","url":"/2023/01/27/knowledge/product-differentiation/","content":"<p>很多创业者和我咨询，说他们找不到很好的差异点，我说“任何东西都有差异化”，就像每一个人都是独一无二的，即使是双胞胎，也有截然不同的地方。关键是找到真正能让用户感知并买单的差异点。这篇文章，我提供了11个可以用到的差异化思路，对于创业者来说，可以收藏作为一个思考清单，经常去想一想你的产品如何才能做得与众不同。<br><a id=\"more\"></a><br>前两天，我和两岁多的孩子一起玩儿，我发现他一下就能在几张相似的图片中，找出不同的那一张。</p>\n<p>人天生就会记住不同的东西，并对它们产生兴趣，而相同的东西就会被合并同类项，这样减少大脑带宽的使用。</p>\n<p><strong>与其更好，不如不同</strong>。</p>\n<p>这句话在商业中特别适用。只有与众不同，才能形成差异化的优势，才能被消费者记住。才可以最大限度的避免同类商品的红海竞争。这也就是所谓的错位竞争，避免与大家在同一个领域里争夺消费者的注意力。</p>\n<p>但是，如果你的产品是高度同质化的，就像瓶装水，油，盐，糖，烟，酒，乳制品，农产品，日用品，这些产品科技含量较低，一般都是处于自由竞争的状态，怎么打造差异化的品牌呢？</p>\n<p>其实任何产品和服务都可以人为的制造“差异化”，毕竟“东西是死的，人是活的”。这篇文章我就从营销4P的角度来介绍：高度同质化的产品应该如何打造自己的差异化？包括<strong>产品差异化，定价差异化，渠道差异化和传播差异化</strong>。</p>\n<h2 id=\"产品差异化\"><a href=\"#产品差异化\" class=\"headerlink\" title=\"产品差异化\"></a>产品差异化</h2><h3 id=\"1、产品状态差异化\"><a href=\"#1、产品状态差异化\" class=\"headerlink\" title=\"1、产品状态差异化\"></a>1、产品状态差异化</h3><p>用相同的原料做成不同状态的产品，从而形成一种产品状态的差异化。特别典型的是蒙牛的奶球，奶片，奶酪，奶粉和奶茶，就用相同的奶制品制作出了不同状态的产品，形成了差异化。</p>\n<p>还有麦当劳的薯格。原来麦当劳只卖薯条，后来开发了新产品薯格立刻大卖。其实，薯格就是薯饼嘛，本质还是炸土豆。但消费者会觉得薯格与薯条不同，很愿意尝鲜。</p>\n<h3 id=\"2、包装差异化\"><a href=\"#2、包装差异化\" class=\"headerlink\" title=\"2、包装差异化\"></a>2、包装差异化</h3><p>前些年流行一种牛奶包装，叫爱壳包装，它是塑料袋材质，有一个用气囊做的手柄的设计，方便取用。这个包装刚上市时，打出“不浪费一滴奶”的口号，迅速获得消费者的青睐。</p>\n<p>包装就是与消费者沟通，是用户“感知”到产品的第一步。</p>\n<p>华与华的华杉老师曾说，<strong>产品是为包装服务</strong>。深以为然。这个时代是一个看颜值的时代，不管是人还是商品，一个好的形象和包装已经赢得了他人或消费者的好感。</p>\n<p>同时，包装还是最好的广告位，放在货架上要吸引注意力。比如江小白瓶身文案吸引了大波粉丝关注和收集，戳中了城市奋斗族的心。</p>\n<p>大家关注的可能不再是酒本身，而是通过包装传递出来的价值观和情怀。</p>\n<h3 id=\"3、产品概念差异化\"><a href=\"#3、产品概念差异化\" class=\"headerlink\" title=\"3、产品概念差异化\"></a>3、产品概念差异化</h3><p>《营销想象力》的作者西奥多·莱维特说，<strong>任何东西都能实现差异化</strong>。</p>\n<p>其实最难实现差异化的是饮用水，这种东西的差别你甚至看不到、摸不到，为什么也有依云这样的品牌，可以卖的那么贵？它从产地的稀缺性打造高端精品，同时选择高端渠道触达高端人群，但一般企业做不到，那怎么办呢？</p>\n<p>很多饮用水品牌打出了产品概念的差异化，比如矿泉水，纯净水，富硒水，弱碱水，小分子水，甚至是月子水（专门为产后女性调理饮用），每一种水的概念不同，形成了与众不同。</p>\n<p>同样，饮料行业里有碳酸饮料、果汁、运动功能性饮料、凉茶、苏打水等，每一种都是一个全新的概念，形成了不同的品类。</p>\n<p>最有代表性的就是王老吉和加多宝，开创出一个全新的品类——凉茶。还打出“怕上火喝王老吉”的宣传口号，巧妙的避开了和碳酸软饮与果汁的激烈竞争。</p>\n<p>概念不同，就是创造全新的品类，找一个干净的山头，避免和已有产品发生激烈竞争，这是最好的差异化策略。</p>\n<h3 id=\"4、品牌和功能的差异化\"><a href=\"#4、品牌和功能的差异化\" class=\"headerlink\" title=\"4、品牌和功能的差异化\"></a>4、品牌和功能的差异化</h3><p>宝洁通过多品牌策略，聚焦不同的消费需求，比如在洗发水品类里，有飘柔、潘婷、海飞丝、沙宣、草本精华等不同子品牌，虽然每个子品牌之间也会竞争，但宝洁通过这样的品牌差异化战略确保整体市场份额最高。</p>\n<p>再比如，奶制品企业可以针对不同人群来打造不同功能的奶粉，比如婴幼儿配方奶，孕妇奶粉，中老年奶粉和学生奶粉、运动员奶粉等。</p>\n<p>我们可以从品牌-功能-人群，这样三个维度去综合思考，<strong>本质还是做好市场和用户的细分</strong>。</p>\n<h3 id=\"5、服务差异化\"><a href=\"#5、服务差异化\" class=\"headerlink\" title=\"5、服务差异化\"></a>5、服务差异化</h3><p>我认为本质上产品也可以看做一种“服务”，是通过商品去帮助用户解决问题。比如戴森吸尘器可以减少消费者在打理家务上的时间，它是通过商品提供了一种解决方案。</p>\n<p>如果产品的同质化越来越高，我们还可以挖掘商品在服务上有哪些可以做出差异化的点来。</p>\n<p>熊猫不走是一个蛋糕品牌，它除了做好蛋糕，并送到顾客手里，还会派出可爱的“熊猫人”，帮你庆祝生日。这些产品以外的服务也会成为品牌的差异点。</p>\n<h2 id=\"定价差异化\"><a href=\"#定价差异化\" class=\"headerlink\" title=\"定价差异化\"></a>定价差异化</h2><h3 id=\"6、价格差异化\"><a href=\"#6、价格差异化\" class=\"headerlink\" title=\"6、价格差异化\"></a>6、价格差异化</h3><p>一种是价格本身的不同。我们为了照顾到不同消费人群的需求，在定价上制造阶梯，比如汽车都有豪华型、经济型，同一个车型低配和高配就可以满足不同消费者的需求。</p>\n<p>几乎所有商品都会有不同的价格梯度，有的来自于功能配置的差异，就像华为手机会有4G版、5G版，普通版，和Pro版一样。</p>\n<p>而有的梯度来自于购买的数量，买的越多，单价越低。</p>\n<p>麦德龙超市就是以“量贩”著称，超市的整体布局就像仓库，商品都是大包装，价格很低，满足了那些家庭人口多而且对价格敏感的主妇购物的需求。形成了和家乐福、沃尔玛的差异化竞争。</p>\n<h3 id=\"7、付费方式的差异化\"><a href=\"#7、付费方式的差异化\" class=\"headerlink\" title=\"7、付费方式的差异化\"></a>7、付费方式的差异化</h3><p>花点时间把用户购买鲜花一次性行为，变成了88元/4次的包月行为，提高了复购率。得到电子书从单本收费到包年148元。这样一来，单价下降，消费者更愿意购买。同时，把单次购买变成包月的另一个好处是养成消费者习惯，增加用户使用时长，留住忠诚顾客。</p>\n<p>而优适健身就恰恰相反，面对消费者在买健身年卡上的犹豫和谨慎，他们推出单次服务，一来，有效降低消费者做决策的压力，二来提高了单次健身的客单价。</p>\n<h2 id=\"渠道差异化\"><a href=\"#渠道差异化\" class=\"headerlink\" title=\"渠道差异化\"></a>渠道差异化</h2><h3 id=\"8、分销渠道差异化\"><a href=\"#8、分销渠道差异化\" class=\"headerlink\" title=\"8、分销渠道差异化\"></a>8、分销渠道差异化</h3><p>还说江小白，它主要的分销渠道和传统白酒截然不同，它选择了年轻人喜欢去的小餐馆作为主要的分销渠道。白酒市场需要要考虑消费者的年龄、收入，还要考虑使用的场景。同样都是送礼场景，求人办事和孝敬爸妈的场景不同；同样是请客吃饭，三五好友小聚和孩子满月摆酒的场景也不同。</p>\n<p>江小白就结合自己的用户使用场景做分析，最适合的就是年轻人喜欢去的小餐馆。它和五粮液、天之蓝或者牛栏山的消费群体和消费场景都不同，如果沿用相同的渠道，效果就不会很好。</p>\n<p>而帮宝适则选择妇产科医院作为B端的合作渠道，这是为了从一开始就抓住初为父母的消费者。所以分销渠道极其多样化，目标用户和消费者在哪儿，哪儿就是渠道；消费场景在哪儿，哪儿也是渠道。</p>\n<h3 id=\"9、流量渠道差异化\"><a href=\"#9、流量渠道差异化\" class=\"headerlink\" title=\"9、流量渠道差异化\"></a>9、流量渠道差异化</h3><p>西贝在2013年左右放弃街边店转而进入购物中心（Mall）里开店。当时西贝创始人贾国龙看到一个趋势，大型购物中心快速崛起。而且，人们下馆子从十多个人一桌，变成三五好友小聚。</p>\n<p>西贝迅速把门店开到了购物中心，取消了包房，把100多道菜也砍成33道菜，迎合平日上班和周末逛街购物的食客。正是西贝准确的把握了客流量的变化，在流量上做到了差异化，大获成功。</p>\n<h2 id=\"传播差异化\"><a href=\"#传播差异化\" class=\"headerlink\" title=\"传播差异化\"></a>传播差异化</h2><h3 id=\"10、文化的差异化\"><a href=\"#10、文化的差异化\" class=\"headerlink\" title=\"10、文化的差异化\"></a>10、文化的差异化</h3><p>三只松鼠，一直在强调“主人文化”，三只可爱卖萌的小松鼠获得了人格化，并且以一种讨巧的方式迎合年轻用户。在线上电商全都对消费者以“亲”相称的时代，三只松鼠以宠物的口吻，称呼顾客为“主人”，获得了人格化IP和粉丝的青睐。</p>\n<p>Roseonly又是如何让普通的玫瑰花拥有了与众不同呢？它创造了一种“唯一文化”，一生只爱一个人，实名买玫瑰，这让玫瑰花与爱情、忠诚、唯一紧密结合在一起，脱颖而出。</p>\n<h3 id=\"11、使用方式的差异化\"><a href=\"#11、使用方式的差异化\" class=\"headerlink\" title=\"11、使用方式的差异化\"></a>11、使用方式的差异化</h3><p>大家一定会对“白加黑”这款感冒药特别有印象，当时只有它第一个提出“白天吃白片，不瞌睡；晚上吃黑片，睡得香”。它就巧妙用时间来区分开吃药的方式，并且抓住当时感冒药的痛点，白天吃完犯困。</p>\n<p>类似的还有早餐奶、早餐饼，都是用时间来区分使用方式。有时消费者真的挺“听话”，你让他早上吃，他就真的会只要早上就会想起来吃。</p>\n<p>还有一款药是治疗口腔溃疡的，叫意可贴。当时所有治疗口腔溃疡的药都是喷剂，它做的是片剂，而且是像对待伤口一样，贴一个创可贴的思路。这样新颖的使用方式快速获得患者的喜欢，解决了喷剂药苦的痛点。</p>\n<p>还有教给大家使用动作，成为差异化的品牌，比如农夫果园，“喝前摇一摇”，奥利奥饼干广告里一直有一个可爱调皮的小男孩，教给其他孩子吃奥利奥的方法，“扭一扭、舔一舔、泡一泡”。这些都成为了产品的独特差异。</p>\n<p>小结一下：很多创业者和我咨询，说他们找不到很好的差异点，我说“任何东西都有差异化”，就像每一个人都是独一无二的，即使是双胞胎，也有截然不同的地方。</p>\n<p>关键是找到真正能让用户感知并买单的差异点。这篇文章，我提供了11个可以用到的差异化思路，对于创业者来说，可以收藏作为一个思考清单，经常去想一想你的产品如何才能做得与众不同。</p>\n<p>还是那句话，<strong>与其更好，不如不同</strong>。</p>\n","categories":["business"],"tags":["note"]},{"title":"编程范式游记（3）- 类型系统和泛型的本质","url":"/2016/01/03/mouse/programming-paradigm-travel-3-the-nature-of-the-type-system-and-generics/","content":"<p>前面，我们讨论了从 C 到 C++ 的泛型编程方法，并且初探了一下更为抽象的函数式编程。正如在上一篇文章中所说的，泛型编程的方式并不只有 C++ 这样的方式，我们只是通过这个过程了解一下，底层静态类型语言泛型的原理。这样能够方便我们继续后面的历程。<br><a id=\"more\"></a><br>是的，除了 C++ 那样的泛型，了解其它编程语言你一定会发现，在动态类型语言或是某些有语法糖支持的语言中，那个swap() 或 search() 函数的泛型其实可以很简单地就实现了。</p>\n<p>比如，你甚至可以把swap()函数简单地写成下面这个样子（包括 Go 语言也有这样的语法）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">b, a &#x3D; a, b;</span><br></pre></td></tr></table></figure><br>在上一篇文章后面的 Reduce 函数中，可以看到，在编程世界中，我们需要处理好两件事。</p>\n<ul>\n<li>第一件事是编程语言中的类型问题。</li>\n<li>第二件事是对真实世界中业务代码的抽象、重用和拼装。</li>\n</ul>\n<p>所以，在这篇文章中，我们还是继续深入地讨论上面这两个问题，着重讨论一下编程语言中的类型系统和泛型编程的本质。</p>\n<h2 id=\"类型系统\"><a href=\"#类型系统\" class=\"headerlink\" title=\"类型系统\"></a>类型系统</h2><p>在计算机科学中，类型系统用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。类型可以确认一个值或者一组值具有特定的意义和目的。</p>\n<p>一般来说，编程语言者会有两种类型，一种是内建类型，如 int、float 和 char 等，一种是抽象类型，如 struct、class 和 function 等。抽象类型在程序运行中，可能不表示为值。类型系统在各种语言之间有非常大的不同，也许，最主要的差异存在于编译时期的语法，以及运行时期的操作实现方式。</p>\n<p>编译器可能使用值的静态类型以最优化所需的存储区，并选取对数值运算时的较佳算法。例如，在许多 C 编译器中，“浮点数”数据类型是以 32 比特表示、与 IEEE 754 规格一致的单精度浮点数。因此，在数值运算上，C 应用了浮点数规范（浮点数加法、乘法等）。</p>\n<p>类型的约束程度以及评估方法，影响了语言的类型。更进一步，编程语言可能就类型多态性部分，对每一个类型都对应了一个针对于这个类型的算法运算。类型理论研究类型系统，尽管实际的编程语言类型系统，起源于计算机架构的实际问题、编译器实现，以及语言设计。</p>\n<p>程序语言的类型系统主要提供如下的功能。</p>\n<ul>\n<li><p>程序语言的安全性。使用类型可以让编译器侦测一些代码的错误。例如：可以识别出一个错误无效的表达式。如：“Hello, World” + 3这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。</p>\n</li>\n<li><p>利于编译器的优化。 静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因些，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是 int ，那么编译就知道，这个类型会以 4 个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。</p>\n</li>\n<li><p>代码的可读性。有类型的编程语言，可以让代码更易读和更易维护。代码的语义也更清楚，代码模块的接口（如函数）也更丰富和更清楚。</p>\n</li>\n<li><p>抽象化。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层的字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。</p>\n</li>\n</ul>\n<p>但是，正如前面说的，类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。</p>\n<p>对此，这个世界出现了两类语言，一类是静态类型语言，如 C、C++、Java，一种是动态类型语言，如 Python、PHP、JavaScript 等。</p>\n<p>我们来看一下，一段动态类型语言的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &#x3D; 5;</span><br><span class=\"line\">x &#x3D; &quot;hello&quot;;</span><br></pre></td></tr></table></figure><br>在这个示例中，我们可以看到变量 x 一开始好像是整型，然后又成了字符串型。如果在静态类型的语言中写出这样的代码，那么就会在编译期出错。而在动态类型的语言中，会以类型标记维持程序所有数值的“标记”，并在运算任何数值之前检查标记。所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。</p>\n<p>我们再来看一个示例，对于 JavaScript 这样的动态语言来说可以定义出下面这样的数据结构（一个数组的元素可以是各式各样的类型），这在静态类型的语言中是很难做到的。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a &#x3D; new Array()</span><br><span class=\"line\">a[0] &#x3D; 2017;</span><br><span class=\"line\">a[1] &#x3D; &quot;Hello&quot;;</span><br><span class=\"line\">a[2] &#x3D; &#123;name: &quot;Hao Chen&quot;&#125;;</span><br></pre></td></tr></table></figure><br>注：其实，这并不是一个数组，而是一个 key:value。因为动态语言的类型是动态的，所以，key 和 value 的类型都可以随意。比如，对于 a 这个数据结构，还可以写成：a[&quot;key&quot;] = &quot;value&quot; 这样的方式。</p>\n<p>在弱类型或是动态类型的语言中，下面代码的执行会有不确定的结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &#x3D; 5;</span><br><span class=\"line\">y &#x3D; &quot;37&quot;;</span><br><span class=\"line\">z &#x3D; x + y;</span><br></pre></td></tr></table></figure><br>有的像 Visual Basic 语言会给出的结果是 42：系统将字符串 &quot;37&quot; 转换成数字 37，以匹配运算上的直觉。</p>\n<p>而有的像 JavaScript 将会产生的结果是 &quot;537&quot;：系统将数字 5 转换成字符串 &quot;5&quot; 并把两者串接起来。</p>\n<p>注，像 Python 这样的语言则会产生一个运行时错误。</p>\n<p>但是，我们需要清楚地知道，无论哪种程序语言，都逃避免不了一个特定的类型系统。哪怕是可随意改变变量类型的动态类型的语言，我们在读代码的过程中也需要脑补某个变量在运行时的类型。</p>\n<p>所以，每个语言都需要一个类型检查系统。</p>\n<p>静态类型检查是在编译器进行语义分析时进行的。如果一个语言强制实行类型规则（即通常只允许以不丢失信息为前提的自动类型转换），那么称此处理为强类型，反之称为弱类型。</p>\n<p>动态类型检查系统更多的是在运行时期做动态类型标记和相关检查。所以，动态类型的语言必然要给出一堆诸如：is_array(), is_int(), is_string() 或是 typeof() 这样的运行时类型检查函数。</p>\n<p>总之，“类型”有时候是一个有用的事，有时候又是一件很讨厌的事情。因为类型是对底层内存布局的一个抽象，会让我们的代码要关注于这些非业务逻辑上的东西。而且，我们的代码需要在不同类型的数据间做处理。但是如果程序语言类型检查得过于严格，那么，我们写出来的代码就不能那么随意。所以，对于静态类型的语言也开了些“小后门”：比如，类型转换，还有 C++、Java 运行时期的类型测试。</p>\n<p>这些小后门也会带来相当讨厌的问题，比如下面这个 C 语言的示例。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int x &#x3D; 5;</span><br><span class=\"line\">char y[] &#x3D; &quot;37&quot;;</span><br><span class=\"line\">char* z &#x3D; x + y;</span><br></pre></td></tr></table></figure><br>在上面这个例子中，结果可能和你想的完全不一样。由于 C 语言的底层特性，这个例子中的 z 会指向一个超过 y 地址 5 个字节的内存地址，相当于指向 y 字符串的指针之后的两个空字符处。</p>\n<p>静态类型语言的支持者和动态类型自由形式的支持者，经常发生争执。前者主张，在编译的时候就可以较早发现错误，而且还可增进运行时期的性能。后者主张，使用更加动态的类型系统，分析代码更为简单，减少出错机会，才能更加轻松快速地编写程序。与此相关的是，后者还主张，考虑到在类型推断的编程语言中，通常不需要手动宣告类型，这部分的额外开销也就自动降低了。</p>\n<p>在本系列内容的前两篇文章中，我们用 C/C++ 语言来做泛型编程的示例，似乎动态类型语言能够比较好地规避掉类型导致需要出现多个版本代码的问题。这样可以让我们更好地关注于业务。</p>\n<p>但是，我们需要清楚地明白，任何语言都有类型系统，只是动态类型语言在运行时做类型检查。动态语言的代码复杂度比较低，并可以更容易地关注业务，在某些场景下是对的，但有些情况下却并不见得。</p>\n<p>比如：在 JavaScript 中，我们需要做一个变量转型的函数，可能会是下面这个样子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function ToNumber(x) &#123;</span><br><span class=\"line\">    switch(typeof x) &#123;</span><br><span class=\"line\">        case &quot;number&quot;: return x;</span><br><span class=\"line\">        case &quot;undefined&quot;: return NaN;</span><br><span class=\"line\">        case &quot;boolean&quot;: return x ? 1 : 0;</span><br><span class=\"line\">        case &quot;string&quot;: return Number(x);</span><br><span class=\"line\">        case &quot;object&quot;: return NaN;</span><br><span class=\"line\">        case &quot;function&quot;: return NaN;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我相信，你在动态类型语言的代码中可以看到大量类似 typeof 这样的类型检查代码。是的，这是动态类型带来的另一个问题，就是运行时识别（这个是比较耗性能的）。</p>\n<p>如果你用过一段时间的动态类型语言，一旦代码量比较大了，我们就会发现，代码中出现“类型问题”而引发整个程序出错的情况实在是太多太多了。而且，这样的出错会让整个程序崩溃掉，太恐怖了。这个时候，我们就很希望提前发现这些类型的问题。</p>\n<p>静态语言的支持者会说编译器会帮我们找到这些问题，而动态语言的支持者则认为，静态语言的编译器也无法找到所有的问题，想真正提前找到问题只能通过测试来解决。其实他们都对。</p>\n<h2 id=\"泛型的本质\"><a href=\"#泛型的本质\" class=\"headerlink\" title=\"泛型的本质\"></a>泛型的本质</h2><p>要了解泛型的本质，就需要了解类型的本质。</p>\n<p>类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。</p>\n<p>不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。</p>\n<p>所以，要做到泛型，我们需要做下面的事情。</p>\n<ul>\n<li>标准化掉类型的内存分配、释放和访问。</li>\n<li>标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……</li>\n<li>标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……</li>\n<li>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……</li>\n</ul>\n<p>所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标。</p>\n<ul>\n<li>通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。</li>\n<li>通过重载操作符，可以标准化类型的比较等操作。</li>\n<li>通过 iostream，标准化了类型的输入输出控制。</li>\n<li>通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。</li>\n<li>通过迭代器来标准化数据容器的遍历操作。</li>\n<li>通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。</li>\n<li>通过函数式（函数对象），来标准化对于不同类型的特定操作。</li>\n</ul>\n<p>通过学习 C++，我们可以看到一个比较完整的泛型编程里所涉及的编程范式，这些编程泛式在其它语言中都会或多或少地体现着。比如，JDK 5 引入的泛型类型，就源自 C++ 的模板。</p>\n<p>泛型编程于 1985 年在论文 Generic Programming 中被这样定义：</p>\n<blockquote>\n<p>Generic programming centers around the idea of abstracting from concrete, efficient algorithms to obtain generic algorithms that can be combined with different data representations to produce a wide variety of useful software.</p>\n<p>— Musser, David R.; Stepanov, Alexander A., Generic Programming</p>\n</blockquote>\n<p>我理解其本质就是 —— <strong>屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型</strong>。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。例如，整数运算不可用于字符串；指针的操作不可用于整数上，等等。但是，类型的产生和限制，虽然对底层代码来说是安全的，但是对于更高层次的抽象产生了些负面因素。比如在 C++ 语言里，为了同时满足静态类型和抽象，就导致了模板技术的出现，带来了语言的复杂性。</p>\n<p>我们需要清楚地明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。但是因为，编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。</p>\n<p>所以，不同的语言在设计上都会做相应的取舍。比如：C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。而 C++ 则是两者都想要，导致语言在设计上非常复杂。</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编程范式游记（5）- 修饰器模式","url":"/2016/01/05/mouse/programming-paradigm-travel-5-decorator-mode/","content":"<p>在上一篇文章中，我们领略了函数式编程的趣味和魅力，主要讲了函数式编程的主要技术。还记得有哪些吗？递归、Map、Reduce、Filter 等，并利用 Python 的 Decorator 和 Generator 功能，将多个函数组合成了管道。<br><a id=\"more\"></a><br>此时，你心中可能会有个疑问，这个 decorator 又是怎样工作的呢？这就是本文中要讲述的内容，“Decorator 模式”，又叫“修饰器模式”，或是“装饰器模式”。</p>\n<h3 id=\"Python-的-Decorator\"><a href=\"#Python-的-Decorator\" class=\"headerlink\" title=\"Python 的 Decorator\"></a>Python 的 Decorator</h3><p>Python 的 Decorator 在使用上和 Java 的 Annotation（以及 C# 的 Attribute）很相似，就是在方法名前面加一个 @XXX 注解来为这个方法装饰一些东西。但是，Java/C# 的 Annotation 也很让人望而却步，太过于复杂了。你要玩它，需要先了解一堆 Annotation 的类库文档，感觉几乎就是在学另外一门语言。</p>\n<p>而 Python 使用了一种相对于 Decorator Pattern 和 Annotation 来说非常优雅的方法，这种方法不需要你去掌握什么复杂的 OO 模型或是 Annotation 的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。</p>\n<p>这是我最喜欢的一个模式了，也是一个挺好玩儿的东西，这个模式动用了函数式编程的一个技术——用一个函数来构造另一个函数。</p>\n<p>好了，我们先来点感性认识，看一个 Python 修饰器的 Hello World 代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def hello(fn):</span><br><span class=\"line\">    def wrapper():</span><br><span class=\"line\">        print &quot;hello, %s&quot; % fn.__name__</span><br><span class=\"line\">        fn()</span><br><span class=\"line\">        print &quot;goodbye, %s&quot; % fn.__name__</span><br><span class=\"line\">    return wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">@hello</span><br><span class=\"line\">def Hao():</span><br><span class=\"line\">    print &quot;i am Hao Chen&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">Hao()</span><br></pre></td></tr></table></figure><br>代码的执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ python hello.py</span><br><span class=\"line\">hello, Hao</span><br><span class=\"line\">i am Hao Chen</span><br><span class=\"line\">goodbye, Hao</span><br></pre></td></tr></table></figure><br>你可以看到如下的东西：</p>\n<p>函数 Hao 前面有个 @hello 的“注解”，hello 就是我们前面定义的函数 hello；</p>\n<p>在 hello 函数中，其需要一个 fn 的参数（这就是用来做回调的函数）；</p>\n<p>hello 函数中返回了一个 inner 函数 wrapper，这个 wrapper函数回调了传进来的 fn，并在回调前后加了两条语句。</p>\n<p>对于 Python 的这个 @注解语法糖（syntactic sugar）来说，当你在用某个 @decorator 来修饰某个函数 func 时，如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">@decorator</span><br><span class=\"line\">def func():</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure><br>其解释器会解释成下面这样的语句：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func &#x3D; decorator(func)</span><br></pre></td></tr></table></figure><br>嘿！这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的。但是，我们需要注意，那里还有一个赋值语句，把 decorator 这个函数的返回值赋值回了原来的 func。</p>\n<p>我们再来看一个带参数的玩法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def makeHtmlTag(tag, *args, **kwds):</span><br><span class=\"line\">    def real_decorator(fn):</span><br><span class=\"line\">        css_class &#x3D; &quot; class&#x3D;&#39;&#123;0&#125;&#39;&quot;.format(kwds[&quot;css_class&quot;]) \\</span><br><span class=\"line\">                                     if &quot;css_class&quot; in kwds else &quot;&quot;</span><br><span class=\"line\">        def wrapped(*args, **kwds):</span><br><span class=\"line\">            return &quot;&lt;&quot;+tag+css_class+&quot;&gt;&quot; + fn(*args, **kwds) + &quot;&lt;&#x2F;&quot;+tag+&quot;&gt;&quot;</span><br><span class=\"line\">        return wrapped</span><br><span class=\"line\">    return real_decorator</span><br><span class=\"line\"></span><br><span class=\"line\">@makeHtmlTag(tag&#x3D;&quot;b&quot;, css_class&#x3D;&quot;bold_css&quot;)</span><br><span class=\"line\">@makeHtmlTag(tag&#x3D;&quot;i&quot;, css_class&#x3D;&quot;italic_css&quot;)</span><br><span class=\"line\">def hello():</span><br><span class=\"line\">    return &quot;hello world&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">print hello()</span><br><span class=\"line\"></span><br><span class=\"line\"># 输出：</span><br><span class=\"line\"># &lt;b class&#x3D;&#39;bold_css&#39;&gt;&lt;i class&#x3D;&#39;italic_css&#39;&gt;hello world&lt;&#x2F;i&gt;&lt;&#x2F;b&gt;</span><br></pre></td></tr></table></figure><br>在上面这个例子中，我们可以看到：makeHtmlTag有两个参数。所以，为了让 <code>hello = makeHtmlTag(arg1, arg2)(hello)</code> 成功， makeHtmlTag 必需返回一个 decorator（这就是为什么我们在 makeHtmlTag 中加入了 real_decorator()）。</p>\n<p>这样一来，我们就可以进入到 decorator 的逻辑中去了——decorator 得返回一个 wrapper，wrapper 里回调 hello。看似那个 makeHtmlTag() 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然。</p>\n<p>我们再来看一个为其它函数加缓存的示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from functools import wraps</span><br><span class=\"line\">def memoization(fn):</span><br><span class=\"line\">    cache &#x3D; &#123;&#125;</span><br><span class=\"line\">    miss &#x3D; object()</span><br><span class=\"line\"></span><br><span class=\"line\">    @wraps(fn)</span><br><span class=\"line\">    def wrapper(*args):</span><br><span class=\"line\">        result &#x3D; cache.get(args, miss)</span><br><span class=\"line\">        if result is miss:</span><br><span class=\"line\">            result &#x3D; fn(*args)</span><br><span class=\"line\">            cache[args] &#x3D; result</span><br><span class=\"line\">        return result</span><br><span class=\"line\"></span><br><span class=\"line\">    return wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">@memoization</span><br><span class=\"line\">def fib(n):</span><br><span class=\"line\">    if n &lt; 2:</span><br><span class=\"line\">        return n</span><br><span class=\"line\">    return fib(n - 1) + fib(n - 2)</span><br></pre></td></tr></table></figure><br>上面这个例子中，是一个斐波那契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算 fib(5)，于是其分解成 fib(4) + fib(3)，而 fib(4) 分解成 fib(3) + fib(2)，fib(3) 又分解成fib(2) + fib(1)……你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了至少两次。</p>\n<p>而我们用 decorator，在调用函数前查询一下缓存，如果没有才调用，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。wraps 的作用是保证 fib 的函数名不被 wrapper 所取代。</p>\n<p>除此之外，Python 还支持类方式的 decorator。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class myDecorator(object):</span><br><span class=\"line\">    def __init__(self, fn):</span><br><span class=\"line\">        print &quot;inside myDecorator.__init__()&quot;</span><br><span class=\"line\">        self.fn &#x3D; fn</span><br><span class=\"line\"></span><br><span class=\"line\">    def __call__(self):</span><br><span class=\"line\">        self.fn()</span><br><span class=\"line\">        print &quot;inside myDecorator.__call__()&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@myDecorator</span><br><span class=\"line\">def aFunction():</span><br><span class=\"line\">    print &quot;inside aFunction()&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">print &quot;Finished decorating aFunction()&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">aFunction()</span><br><span class=\"line\"></span><br><span class=\"line\"># 输出：</span><br><span class=\"line\"># inside myDecorator.__init__()</span><br><span class=\"line\"># Finished decorating aFunction()</span><br><span class=\"line\"># inside aFunction()</span><br><span class=\"line\"># inside myDecorator.__call__()</span><br></pre></td></tr></table></figure><br>上面这个示例展示了，用类的方式声明一个 decorator。我们可以看到这个类中有两个成员：</p>\n<p>一个是_<em>init_<em>()，这个方法是在我们给某个函数 decorate 时被调用，所以，需要有一个 fn 的参数，也就是被 decorate 的函数。<br>一个是__call\\</em></em>()，这个方法是在我们调用被 decorate 的函数时被调用的。<br>从上面的输出中，可以看到整个程序的执行顺序。这看上去要比“函数式”的方式更易读一些。</p>\n<p>我们来看一个实际点的例子。下面这个示例展示了通过 URL 的路由来调用相关注册的函数示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MyApp():</span><br><span class=\"line\">    def __init__(self):</span><br><span class=\"line\">        self.func_map &#x3D; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    def register(self, name):</span><br><span class=\"line\">        def func_wrapper(func):</span><br><span class=\"line\">            self.func_map[name] &#x3D; func</span><br><span class=\"line\">            return func</span><br><span class=\"line\">        return func_wrapper</span><br><span class=\"line\"></span><br><span class=\"line\">    def call_method(self, name&#x3D;None):</span><br><span class=\"line\">        func &#x3D; self.func_map.get(name, None)</span><br><span class=\"line\">        if func is None:</span><br><span class=\"line\">            raise Exception(&quot;No function registered against - &quot; + str(name))</span><br><span class=\"line\">        return func()</span><br><span class=\"line\"></span><br><span class=\"line\">app &#x3D; MyApp()</span><br><span class=\"line\"></span><br><span class=\"line\">@app.register(&#39;&#x2F;&#39;)</span><br><span class=\"line\">def main_page_func():</span><br><span class=\"line\">    return &quot;This is the main page.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@app.register(&#39;&#x2F;next_page&#39;)</span><br><span class=\"line\">def next_page_func():</span><br><span class=\"line\">    return &quot;This is the next page.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">print app.call_method(&#39;&#x2F;&#39;)</span><br><span class=\"line\">print app.call_method(&#39;&#x2F;next_page&#39;)</span><br></pre></td></tr></table></figure><br>注意：上面这个示例中 decorator 类不是真正的 decorator，其中也没有<strong>call</strong>()，并且，wrapper 返回了原函数。所以，原函数没有发生任何变化。</p>\n<h3 id=\"Go-语言的-Decorator\"><a href=\"#Go-语言的-Decorator\" class=\"headerlink\" title=\"Go 语言的 Decorator\"></a>Go 语言的 Decorator</h3><p>Python 有语法糖，所以写出来的代码比较酷。但是对于没有修饰器语法糖这类语言，写出来的代码会是怎么样的？我们来看一下 Go 语言的代码。</p>\n<p>还是从一个 Hello World 开始。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;fmt&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">func decorator(f func(s string)) func(s string) &#123;</span><br><span class=\"line\">    return func(s string) &#123;</span><br><span class=\"line\">        fmt.Println(&quot;Started&quot;)</span><br><span class=\"line\">        f(s)</span><br><span class=\"line\">        fmt.Println(&quot;Done&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Hello(s string) &#123;</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    decorator(Hello)(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，我们动用了一个高阶函数 decorator()，在调用的时候，先把 Hello() 函数传进去，然后其返回一个匿名函数。这个匿名函数中除了运行了自己的代码，也调用了被传入的 Hello() 函数。</p>\n<p>这个玩法和 Python 的异曲同工，只不过，Go 并不支持像 Python 那样的 @decorator 语法糖。所以，在调用上有些难看。当然，如果要想让代码容易读一些，你可以这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hello :&#x3D; decorator(Hello)</span><br><span class=\"line\">hello(&quot;Hello&quot;)</span><br></pre></td></tr></table></figure>\n<p>我们再来看一个为函数 log 消耗时间的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type SumFunc func(int64, int64) int64</span><br><span class=\"line\"></span><br><span class=\"line\">func getFunctionName(i interface&#123;&#125;) string &#123;</span><br><span class=\"line\">    return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func timedSumFunc(f SumFunc) SumFunc &#123;</span><br><span class=\"line\">    return func(start, end int64) int64 &#123;</span><br><span class=\"line\">        defer func(t time.Time) &#123;</span><br><span class=\"line\">            fmt.Printf(&quot;--- Time Elapsed (%s): %v ---\\n&quot;,</span><br><span class=\"line\">                getFunctionName(f), time.Since(t))</span><br><span class=\"line\">        &#125;(time.Now())</span><br><span class=\"line\">        return f(start, end)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Sum1(start, end int64) int64 &#123;</span><br><span class=\"line\">    var sum int64</span><br><span class=\"line\">    sum &#x3D; 0</span><br><span class=\"line\">    if start &gt; end &#123;</span><br><span class=\"line\">        start, end &#x3D; end, start</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for i :&#x3D; start; i &lt;&#x3D; end; i++ &#123;</span><br><span class=\"line\">        sum +&#x3D; i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return sum</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func Sum2(start, end int64) int64 &#123;</span><br><span class=\"line\">    if start &gt; end &#123;</span><br><span class=\"line\">        start, end &#x3D; end, start</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (end - start + 1) * (end + start) &#x2F; 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    sum1 :&#x3D; timedSumFunc(Sum1)</span><br><span class=\"line\">    sum2 :&#x3D; timedSumFunc(Sum2)</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Printf(&quot;%d, %d\\n&quot;, sum1(-10000, 10000000), sum2(-10000, 10000000))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>关于上面的代码：</p>\n<p>有两个 Sum 函数，Sum1() 函数就是简单地做个循环，Sum2() 函数动用了数据公式。（注意：start 和 end 有可能有负数的情况。）</p>\n<p>代码中使用了 Go 语言的反射机制来获取函数名。</p>\n<p>修饰器函数是 timedSumFunc()。</p>\n<p>再来看一个 HTTP 路由的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func WithServerHeader(h http.HandlerFunc) http.HandlerFunc &#123;</span><br><span class=\"line\">    return func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        log.Println(&quot;---&gt;WithServerHeader()&quot;)</span><br><span class=\"line\">        w.Header().Set(&quot;Server&quot;, &quot;HelloServer v0.0.1&quot;)</span><br><span class=\"line\">        h(w, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func WithAuthCookie(h http.HandlerFunc) http.HandlerFunc &#123;</span><br><span class=\"line\">    return func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        log.Println(&quot;---&gt;WithAuthCookie()&quot;)</span><br><span class=\"line\">        cookie :&#x3D; &amp;http.Cookie&#123;Name: &quot;Auth&quot;, Value: &quot;Pass&quot;, Path: &quot;&#x2F;&quot;&#125;</span><br><span class=\"line\">        http.SetCookie(w, cookie)</span><br><span class=\"line\">        h(w, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func WithBasicAuth(h http.HandlerFunc) http.HandlerFunc &#123;</span><br><span class=\"line\">    return func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        log.Println(&quot;---&gt;WithBasicAuth()&quot;)</span><br><span class=\"line\">        cookie, err :&#x3D; r.Cookie(&quot;Auth&quot;)</span><br><span class=\"line\">        if err !&#x3D; nil || cookie.Value !&#x3D; &quot;Pass&quot; &#123;</span><br><span class=\"line\">            w.WriteHeader(http.StatusForbidden)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h(w, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func WithDebugLog(h http.HandlerFunc) http.HandlerFunc &#123;</span><br><span class=\"line\">    return func(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">        log.Println(&quot;---&gt;WithDebugLog&quot;)</span><br><span class=\"line\">        r.ParseForm()</span><br><span class=\"line\">        log.Println(r.Form)</span><br><span class=\"line\">        log.Println(&quot;path&quot;, r.URL.Path)</span><br><span class=\"line\">        log.Println(&quot;scheme&quot;, r.URL.Scheme)</span><br><span class=\"line\">        log.Println(r.Form[&quot;url_long&quot;])</span><br><span class=\"line\">        for k, v :&#x3D; range r.Form &#123;</span><br><span class=\"line\">            log.Println(&quot;key:&quot;, k)</span><br><span class=\"line\">            log.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h(w, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func hello(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\">    log.Printf(&quot;Received Request %s from %s\\n&quot;, r.URL.Path, r.RemoteAddr)</span><br><span class=\"line\">    fmt.Fprintf(w, &quot;Hello, World! &quot;+r.URL.Path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码中，我们写了多个函数。有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证 Cookie 的，有打日志的……在使用过程中，我们可以把其嵌套起来使用，在修饰过的函数上继续修饰，这样就可以拼装出更复杂的功能。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    http.HandleFunc(&quot;&#x2F;v1&#x2F;hello&quot;, WithServerHeader(WithAuthCookie(hello)))</span><br><span class=\"line\">    http.HandleFunc(&quot;&#x2F;v2&#x2F;hello&quot;, WithServerHeader(WithBasicAuth(hello)))</span><br><span class=\"line\">    http.HandleFunc(&quot;&#x2F;v3&#x2F;hello&quot;, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))</span><br><span class=\"line\">    err :&#x3D; http.ListenAndServe(&quot;:8080&quot;, nil)</span><br><span class=\"line\">    if err !&#x3D; nil &#123;</span><br><span class=\"line\">        log.Fatal(&quot;ListenAndServe: &quot;, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>当然，如果一层套一层不好看的话，我们可以使用 pipeline 的玩法——我们需要先写一个工具函数——用来遍历并调用各个 decorator：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc</span><br><span class=\"line\"></span><br><span class=\"line\">func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc &#123;</span><br><span class=\"line\">    for i :&#x3D; range decors &#123;</span><br><span class=\"line\">        d :&#x3D; decors[len(decors)-1-i] &#x2F;&#x2F; iterate in reverse</span><br><span class=\"line\">        h &#x3D; d(h)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return h</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后，我们就可以像下面这样使用了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http.HandleFunc(&quot;&#x2F;v4&#x2F;hello&quot;, Handler(hello,</span><br><span class=\"line\">                WithServerHeader, WithBasicAuth, WithDebugLog))</span><br></pre></td></tr></table></figure>\n<p>这样的代码是不是更易读了一些？pipeline 的功能也就出来了。</p>\n<p>不过，对于 Go 的修饰器模式，还有一个小问题——好像无法做到泛型，就像上面那个计算时间的函数一样，其代码耦合了需要被修饰的函数的接口类型，无法做到非常通用。如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。</p>\n<p>因为 Go 语言不像 Python 和 Java，Python 是动态语言，而 Java 有语言虚拟机，所以它们可以干好些比较变态的事，然而 Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 interface{}，还有比较简单的 reflection 机制，在上面做做文章，应该还是可以搞定的。</p>\n<p>废话不说，下面是我用 reflection 机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func Decorator(decoPtr, fn interface&#123;&#125;) (err error) &#123;</span><br><span class=\"line\">    var decoratedFunc, targetFunc reflect.Value</span><br><span class=\"line\"></span><br><span class=\"line\">    decoratedFunc &#x3D; reflect.ValueOf(decoPtr).Elem()</span><br><span class=\"line\">    targetFunc &#x3D; reflect.ValueOf(fn)</span><br><span class=\"line\"></span><br><span class=\"line\">    v :&#x3D; reflect.MakeFunc(targetFunc.Type(),</span><br><span class=\"line\">        func(in []reflect.Value) (out []reflect.Value) &#123;</span><br><span class=\"line\">            fmt.Println(&quot;before&quot;)</span><br><span class=\"line\">            out &#x3D; targetFunc.Call(in)</span><br><span class=\"line\">            fmt.Println(&quot;after&quot;)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    decoratedFunc.Set(v)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码动用了 reflect.MakeFunc() 函数制作出了一个新的函数。其中的 targetFunc.Call(in) 调用了被修饰的函数。关于 Go 语言的反射机制，推荐官方文章——《The Laws of Reflection》，在这里我不多说了。</p>\n<p>上面这个 Decorator() 需要两个参数：</p>\n<p>第一个是出参 decoPtr ，就是完成修饰后的函数。<br>第二个是入参 fn ，就是需要修饰的函数。<br>这样写是不是有些二？的确是的。不过，这是我个人在 Go 语言里所能写出来的最好的代码了。如果你知道更优雅的写法，请你一定告诉我！</p>\n<p>好的，让我们来看一下使用效果。首先，假设我们有两个需要修饰的函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func foo(a, b, c int) int &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;%d, %d, %d \\n&quot;, a, b, c)</span><br><span class=\"line\">    return a + b + c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func bar(a, b string) string &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;%s, %s \\n&quot;, a, b)</span><br><span class=\"line\">    return a + b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后，我们可以这样做：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type MyFoo func(int, int, int) int</span><br><span class=\"line\">var myfoo MyFoo</span><br><span class=\"line\">Decorator(&amp;myfoo, foo)</span><br><span class=\"line\">myfoo(1, 2, 3)</span><br></pre></td></tr></table></figure><br>你会发现，使用 Decorator() 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？谁叫这是有类型的静态编译的语言呢？</p>\n<p>嗯。如果你不想声明函数签名，那么也可以这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mybar :&#x3D; bar</span><br><span class=\"line\">Decorator(&amp;mybar, bar)</span><br><span class=\"line\">mybar(&quot;hello,&quot;, &quot;world!&quot;)</span><br></pre></td></tr></table></figure><br>好吧，看上去不是那么的漂亮，但是 it works。看样子 Go 语言目前本身的特性无法做成像 Java 或 Python 那样，对此，我们只能多求 Go 语言多放糖了！</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>好了，讲了那么多的例子，看了那么多的代码，我估计你可能有点晕，让我们来做个小结吧。</p>\n<p>通过上面 Python 和 Go 修饰器的例子，我们可以看到，所谓的修饰器模式其实是在做下面的几件事。</p>\n<p>表面上看，修饰器模式就是扩展现有的一个函数的功能，让它可以干一些其他的事，或是在现有的函数功能上再附加上一些别的功能。</p>\n<p>除了我们可以感受到函数式编程下的代码扩展能力，我们还能感受到函数的互相和随意拼装带来的好处。</p>\n<p>但是深入一下，我们不难发现，Decorator 这个函数其实是可以修饰几乎所有的函数的。于是，这种可以通用于其它函数的编程方式，可以很容易地将一些非业务功能的、属于控制类型的代码给抽象出来（所谓的控制类型的代码就是像 for-loop，或是打日志，或是函数路由，或是求函数运行时间之类的非业务功能性的代码）。</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编程范式游记（7）- 基于原型的编程范式","url":"/2016/01/07/mouse/programming-paradigm-travel-7-prototype-based/","content":"<p>基于原型（prototype）的编程其实也是面向对象编程的一种方式。没有 class 化的，直接使用对象。又叫，基于实例的编程。其主流的语言就是 JavaScript。与传统的面对象编程的比较如下。<br><a id=\"more\"></a><br>在基于类的编程当中，对象总共有两种类型。类定义了对象的基本布局和函数特性，而接口是“可以使用的”对象，它基于特定类的样式。在此模型中，类表现为行为和结构的集合，对所有接口来说这些类的行为和结构都是相同的。因而，区分规则首先是基于行为和结构，而后才是状态。</p>\n<p>原型编程的主张者经常争论说，基于类的语言提倡使用一个关注分类和类之间关系的开发模型。与此相对，原型编程看起来提倡程序员关注一系列对象实例的行为，而之后才关心如何将这些对象划分到最近的使用方式相似的原型对象，而不是分成类。</p>\n<p>因为如此，很多基于原型的系统提倡运行时原型的修改，而只有极少数基于类的面向对象系统（比如第一个动态面向对象的系统 Smalltalk）允许类在程序运行时被修改。</p>\n<p>在基于类的语言中，一个新的实例通过类构造器和构造器可选的参数来构造，结果实例由类选定的行为和布局创建模型。</p>\n<p>在基于原型的系统中构造对象有两种方法，通过复制已有的对象或者通过扩展空对象创建。很多基于原型的系统提倡运行时原型的修改，而基于类的面向对象系统只有动态语言允许类在运行时被修改（Common Lisp、Dylan、Objective-C、Perl、Python、Ruby 和 Smalltalk）。</p>\n<h3 id=\"JavaScript-的原型概念\"><a href=\"#JavaScript-的原型概念\" class=\"headerlink\" title=\"JavaScript 的原型概念\"></a>JavaScript 的原型概念</h3><p>这里，我们主要以 JavaScript 举例，面向对象里面要有个 Class。但是 JavaScript 觉得不是这样的，它就是要基于原型编程，就不要 Class，就直接在对象上改就行了。基于编程的修改，直接对类型进行修改。</p>\n<p>我们先来看一个示例。</p>\n<p>var foo = {name: &quot;foo&quot;, one: 1, two: 2};</p>\n<p>var bar = {three: 3};<br>每个对象都有一个 _<em>proto_<em> 的属性，这个就是“原型”。对于上面的两个对象，如果我们把 foo 赋值给 bar.__proto\\</em></em>，那就意味着，bar 的原型就成了 foo的。</p>\n<p>bar._<em>proto_</em> = foo; // foo is now the prototype of bar.<br>于是，我们就可以在 bar 里面访问 foo 的属性了。</p>\n<p>// If we try to access foo&#39;s properties from bar<br>// from now on, we&#39;ll succeed.<br>bar.one // Resolves to 1.</p>\n<p>// The child object&#39;s properties are also accessible.<br>bar.three // Resolves to 3.</p>\n<p>// Own properties shadow prototype properties<br>bar.name = &quot;bar&quot;;<br>foo.name; // unaffected, resolves to &quot;foo&quot;<br>bar.name; // Resolves to &quot;bar&quot;<br>需要解释一下 JavaScript 的两个东西，一个是 _<em>proto_</em>，另一个是 prototype，这两个东西很容易混淆。这里说明一下：</p>\n<p>_<em>proto_</em> 主要是安放在一个实际的对象中，用它来产生一个链接，一个原型链连，用于寻找方法名或属性，等等。</p>\n<p>prototype 是用 new 来创建一个对象时构造 _<em>proto_</em> 用的。它是构造函数的一个属性。</p>\n<p>在 JavaScript 中，对象有两种表现形式， 一种是 Object (ES5 关于 Object 的文档)，一种是 Function （ES5 关于 Function 的文档）。</p>\n<p>我们可以简单地认为，_<em>proto_<em> 是所有对象用于链接原型的一个指针，而 prototype 则是 Function 对象的属性，其主要是用来当需要 new 一个对象时让 _<em>proto_</em> 指针所指向的地方。 对于超级对象 Function 而言， Function.__proto\\</em></em> 就是 Function.prototype。</p>\n<p>比如我们有如下的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a &#x3D; &#123;</span><br><span class=\"line\">  x: 10,</span><br><span class=\"line\">  calculate: function (z) &#123;</span><br><span class=\"line\">    return this.x + this.y + z;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var b &#x3D; &#123;</span><br><span class=\"line\">  y: 20,</span><br><span class=\"line\">  __proto__: a</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var c &#x3D; &#123;</span><br><span class=\"line\">  y: 30,</span><br><span class=\"line\">  __proto__: a</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; call the inherited method</span><br><span class=\"line\">b.calculate(30); &#x2F;&#x2F; 60</span><br><span class=\"line\">c.calculate(40); &#x2F;&#x2F; 80</span><br></pre></td></tr></table></figure><br>其中的“原型链”如下所示：</p>\n<p>注意：ES5 中，规定原型继承需要使用 Object.create() 函数。如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var b &#x3D; Object.create(a, &#123;y: &#123;value: 20&#125;&#125;);</span><br><span class=\"line\">var c &#x3D; Object.create(a, &#123;y: &#123;value: 30&#125;&#125;);</span><br><span class=\"line\">好了，我们再来看一段代码：</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 一种构造函数写法</span><br><span class=\"line\">function Foo(y) &#123;</span><br><span class=\"line\">  this.y &#x3D; y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 修改 Foo 的 prototype，加入一个成员变量 x</span><br><span class=\"line\">Foo.prototype.x &#x3D; 10;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 修改 Foo 的 prototype，加入一个成员函数 calculate</span><br><span class=\"line\">Foo.prototype.calculate &#x3D; function (z) &#123;</span><br><span class=\"line\">  return this.x + this.y + z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 现在，我们用 Foo 这个原型来创建 b 和 c</span><br><span class=\"line\">var b &#x3D; new Foo(20);</span><br><span class=\"line\">var c &#x3D; new Foo(30);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 调用原型中的方法，可以得到正确的值</span><br><span class=\"line\">b.calculate(30); &#x2F;&#x2F; 60</span><br><span class=\"line\">c.calculate(40); &#x2F;&#x2F; 80</span><br></pre></td></tr></table></figure><br>那么，在内存中的布局是怎么样的呢？大概是下面这个样子。</p>\n<p>这个图应该可以让你很好地看明白 _<em>proto_</em> 和 prototype 的差别了。</p>\n<p>我们可以测试一下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">b.__proto__ &#x3D;&#x3D;&#x3D; Foo.prototype, &#x2F;&#x2F; true</span><br><span class=\"line\">c.__proto__ &#x3D;&#x3D;&#x3D; Foo.prototype, &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br><span class=\"line\">b.constructor &#x3D;&#x3D;&#x3D; Foo, &#x2F;&#x2F; true</span><br><span class=\"line\">c.constructor &#x3D;&#x3D;&#x3D; Foo, &#x2F;&#x2F; true</span><br><span class=\"line\">Foo.prototype.constructor &#x3D;&#x3D;&#x3D; Foo, &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br><span class=\"line\">b.calculate &#x3D;&#x3D;&#x3D; b.__proto__.calculate, &#x2F;&#x2F; true</span><br><span class=\"line\">b.__proto__.calculate &#x3D;&#x3D;&#x3D; Foo.prototype.calculate &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><br>这里需要说明的是——Foo.prototype 自动创建了一个属性 constructor，这是一个指向函数自己的一个 reference。这样一来，对于实例 b 或 c 来说，就能访问到这个继承的 constructor 了。</p>\n<p>有了这些基本概念，我们就可以讲一下 JavaScript 的面向对象编程了。</p>\n<p>注： 上面示例和图示来源于 JavaScript, The Core 一文。</p>\n<h3 id=\"JavaScript-原型编程的面向对象\"><a href=\"#JavaScript-原型编程的面向对象\" class=\"headerlink\" title=\"JavaScript 原型编程的面向对象\"></a>JavaScript 原型编程的面向对象</h3><p>我们再来重温一下上面讲述的内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person()&#123;&#125;</span><br><span class=\"line\">var p &#x3D; new Person();</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name &#x3D; &quot;Hao Chen&quot;;</span><br><span class=\"line\">Person.prototype.sayHello &#x3D; function()&#123;</span><br><span class=\"line\">    console.log(&quot;Hi, I am &quot; + this.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(p.name); &#x2F;&#x2F; &quot;Hao Chen&quot;</span><br><span class=\"line\">p.sayHello(); &#x2F;&#x2F; &quot;Hi, I am Hao Chen&quot;</span><br></pre></td></tr></table></figure><br>在上面这个例子中：</p>\n<p>我们先生成了一个空的函数对象 Person()；<br>然后将这个空的函数对象 new 出另一个对象，存在 p 中；<br>这时再改变 Person.prototype，让其有一个 name 的属性和一个 sayHello() 的方法；<br>我们发现，另外那个 p 的对象也跟着一起改变了。<br>注意一下，当创建 function Person(){} 时，Person._<em>proto_<em> 指向 Function.prototype;<br>当创建 var p = new Person() 时，p._<em>proto_</em> 指向 Person.prototype;<br>当修改了 Person.prototype 的内容后，p.__proto\\</em></em> 的内容也就被改变了。<br>好了，我们再来看一下“原型编程”中面向对象的编程玩法。</p>\n<p>首先，我们定义一个 Person 类。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Define human class</span><br><span class=\"line\">var Person &#x3D; function (fullName, email) &#123;</span><br><span class=\"line\">  this.fullName &#x3D; fullName;</span><br><span class=\"line\">  this.email &#x3D; email;</span><br><span class=\"line\"></span><br><span class=\"line\">  this.speak &#x3D; function()&#123;</span><br><span class=\"line\">    console.log(&quot;I speak English!&quot;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  this.introduction &#x3D; function()&#123;</span><br><span class=\"line\">    console.log(&quot;Hi, I am &quot; + this.fullName);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面这个对象中，包含了：</p>\n<p>属性： fullName 和 email；<br>方法： speak() 和 introduction()。<br>其实，所谓的方法也是属性。</p>\n<p>然后，我们可以定义一个 Student 对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Define Student class</span><br><span class=\"line\">var Student &#x3D; function(fullName, email, school, courses) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Person.call(this, fullName, email);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Initialize our Student properties</span><br><span class=\"line\">  this.school &#x3D; school;</span><br><span class=\"line\">  this.courses &#x3D; courses;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; override the &quot;introduction&quot; method</span><br><span class=\"line\">  this.introduction&#x3D; function()&#123;</span><br><span class=\"line\">    console.log(&quot;Hi, I am &quot; + this.fullName +</span><br><span class=\"line\">                &quot;. I am a student of &quot; + this.school +</span><br><span class=\"line\">                &quot;, I study &quot;+ this.courses +&quot;.&quot;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Add a &quot;exams&quot; method</span><br><span class=\"line\">  this.takeExams &#x3D; function()&#123;</span><br><span class=\"line\">    console.log(&quot;This is my exams time!&quot;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>在上面的代码中：</p>\n<p>使用了 Person.call(this, fullName, email)，call() 或 apply() 都是为了动态改变 this 所指向的对象的内容而出现的。这里的 this 就是 Student。</p>\n<p>上面的例子中，我们重载了 introduction() 方法，并新增加了一个 takeExams()的方法。</p>\n<p>虽然，我们这样定义了 Student，但是它还没有和 Person 发生继承关系。为了要让它们发生关系，我们就需要修改 Student 的原型。</p>\n<p>我们可以简单粗暴地做赋值：Student._<em>proto_</em> = Person.prototype ，但是，这太粗暴了。</p>\n<p>我们还是使用比较规范的方式：</p>\n<p>先用 Object.create() 来将Person.prototype 和 Student.prototype 关联上。</p>\n<p>然后，修改一下构造函数 Student.prototype.constructor = Student;。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Create a Student.prototype object that inherits</span><br><span class=\"line\">&#x2F;&#x2F; from Person.prototype.</span><br><span class=\"line\">Student.prototype &#x3D; Object.create(Person.prototype);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Set the &quot;constructor&quot; property to refer to Student</span><br><span class=\"line\">Student.prototype.constructor &#x3D; Student;</span><br></pre></td></tr></table></figure><br>这样，我们就可以这样使用了。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var student &#x3D; new Student(&quot;Hao Chen&quot;,</span><br><span class=\"line\">                          &quot;haoel@hotmail.com&quot;,</span><br><span class=\"line\">                          &quot;XYZ University&quot;,</span><br><span class=\"line\">                          &quot;Computer Science&quot;);</span><br><span class=\"line\">student.introduction();   </span><br><span class=\"line\">student.speak();       </span><br><span class=\"line\">student.takeExams();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Check that instanceof works correctly</span><br><span class=\"line\">console.log(student instanceof Person);  &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(student instanceof Student); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><br>上述就是基于原型的面向对象编程的玩法了。</p>\n<p>注：在 ECMAScript 标准的第四版开始寻求使 JavaScript 提供基于类的构造，且 ECMAScript 第六版有提供 &quot;class&quot;(类) 作为原有的原型架构之上的语法糖，提供构建对象与处理继承时的另一种语法。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>我们可以看到，这种玩法就是一种委托的方式。在使用委托的基于原型的语言中，运行时语言可以仅仅通过循着一个序列的指针直到找到匹配这样的方式来定位属性或者寻找正确的数据。所有这些创建行为共享的行为需要的是委托指针。</p>\n<p>不像是基于类的面向对象语言中类和接口的关系，原型和它的分支之间的关系并不要求子对象有相似的内存结构，因为如此，子对象可以继续修改而无需像基于类的系统那样整理结构。还有一个要提到的地方是，不仅仅是数据，方法也能被修改。因为这个原因，大多数基于原型的语言把数据和方法提作“slots”。</p>\n<p>这种在对象里面直接修改的玩法，虽然这个特性可以带来运行时的灵活性，我们可以在运行时修改一个 prototype，给它增加甚至删除属性和方法。但是其带来了执行的不确定性，也有安全性的问题，而代码还变得不可预测，这有点黑科技的味道了。因为这些不像静态类型系统，没有一个不可变的契约对代码的确定性有保证，所以，需要使用者来自己保证。</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编程范式游记（8）- Go 语言的委托模式","url":"/2016/01/08/mouse/programming-paradigm-travel-8-the-entrustment-pattern-of-go-language/","content":"<p>我们再来看 Go 语言这个模式，Go 语言的这个模式挺好玩儿的。声明一个 struct，跟 C 很一样，然后直接把这个 struct 类型放到另一个 struct 里。<br><a id=\"more\"></a></p>\n<h3 id=\"委托的简单示例\"><a href=\"#委托的简单示例\" class=\"headerlink\" title=\"委托的简单示例\"></a>委托的简单示例</h3><p>我们来看几个示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Widget struct &#123;</span><br><span class=\"line\">    X, Y int</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Label struct &#123;</span><br><span class=\"line\">    Widget        &#x2F;&#x2F; Embedding (delegation)</span><br><span class=\"line\">    Text   string &#x2F;&#x2F; Aggregation</span><br><span class=\"line\">    X int         &#x2F;&#x2F; Override</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (label Label) Paint() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; [0xc4200141e0] - Label.Paint(&quot;State&quot;)</span><br><span class=\"line\">    fmt.Printf(&quot;[%p] - Label.Paint(%q)\\n&quot;,</span><br><span class=\"line\">        &amp;label, label.Text)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面，我们声明了一个 Widget，其有 X,Y；然后用它来声明一个 Label，直接把 Widget 委托进去；然后再给 Label 声明并实现了一个 Paint() 方法。<br>于是，我们就可以这样编程了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">label :&#x3D; Label&#123;Widget&#123;10, 10&#125;, &quot;State&quot;, 100&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; X&#x3D;100, Y&#x3D;10, Text&#x3D;State, Widget.X&#x3D;10</span><br><span class=\"line\">fmt.Printf(&quot;X&#x3D;%d, Y&#x3D;%d, Text&#x3D;%s Widget.X&#x3D;%d\\n&quot;,</span><br><span class=\"line\">    label.X, label.Y, label.Text,</span><br><span class=\"line\">    label.Widget.X)</span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\">&#x2F;&#x2F; &#123;Widget:&#123;X:10 Y:10&#125; Text:State X:100&#125;</span><br><span class=\"line\">&#x2F;&#x2F; &#123;&#123;10 10&#125; State 100&#125;</span><br><span class=\"line\">fmt.Printf(&quot;%+v\\n%v\\n&quot;, label, label)</span><br><span class=\"line\"></span><br><span class=\"line\">label.Paint()</span><br></pre></td></tr></table></figure><br>我们可以看到，如果有成员变量重名，则需要手动地解决冲突。</p>\n<p>我们继续扩展代码。</p>\n<p>先来一个 Button：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Button struct &#123;</span><br><span class=\"line\">    Label &#x2F;&#x2F; Embedding (delegation)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewButton(x, y int, text string) Button &#123;</span><br><span class=\"line\">    return Button&#123;Label&#123;Widget&#123;x, y&#125;, text, x&#125;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (button Button) Paint() &#123; &#x2F;&#x2F; Override</span><br><span class=\"line\">    fmt.Printf(&quot;[%p] - Button.Paint(%q)\\n&quot;,</span><br><span class=\"line\">        &amp;button, button.Text)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (button Button) Click() &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[%p] - Button.Click()\\n&quot;, &amp;button)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>再来一个 ListBox：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type ListBox struct &#123;</span><br><span class=\"line\">    Widget          &#x2F;&#x2F; Embedding (delegation)</span><br><span class=\"line\">    Texts  []string &#x2F;&#x2F; Aggregation</span><br><span class=\"line\">    Index  int      &#x2F;&#x2F; Aggregation</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (listBox ListBox) Paint() &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[%p] - ListBox.Paint(%q)\\n&quot;,</span><br><span class=\"line\">        &amp;listBox, listBox.Texts)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func (listBox ListBox) Click() &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;[%p] - ListBox.Click()\\n&quot;, &amp;listBox)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后，声明两个接口用于多态：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Painter interface &#123;</span><br><span class=\"line\">    Paint()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">type Clicker interface &#123;</span><br><span class=\"line\">    Click()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>于是我们就可以这样泛型地使用（注意其中的两个 for 循环）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">button1 :&#x3D; Button&#123;Label&#123;Widget&#123;10, 70&#125;, &quot;OK&quot;, 10&#125;&#125;</span><br><span class=\"line\">button2 :&#x3D; NewButton(50, 70, &quot;Cancel&quot;)</span><br><span class=\"line\">listBox :&#x3D; ListBox&#123;Widget&#123;10, 40&#125;,</span><br><span class=\"line\">    []string&#123;&quot;AL&quot;, &quot;AK&quot;, &quot;AZ&quot;, &quot;AR&quot;&#125;, 0&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\">&#x2F;&#x2F;[0xc4200142d0] - Label.Paint(&quot;State&quot;)</span><br><span class=\"line\">&#x2F;&#x2F;[0xc420014300] - ListBox.Paint([&quot;AL&quot; &quot;AK&quot; &quot;AZ&quot; &quot;AR&quot;])</span><br><span class=\"line\">&#x2F;&#x2F;[0xc420014330] - Button.Paint(&quot;OK&quot;)</span><br><span class=\"line\">&#x2F;&#x2F;[0xc420014360] - Button.Paint(&quot;Cancel&quot;)</span><br><span class=\"line\">for _, painter :&#x3D; range []Painter&#123;label, listBox, button1, button2&#125; &#123;</span><br><span class=\"line\">    painter.Paint()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\">&#x2F;&#x2F;[0xc420014450] - ListBox.Click()</span><br><span class=\"line\">&#x2F;&#x2F;[0xc420014480] - Button.Click()</span><br><span class=\"line\">&#x2F;&#x2F;[0xc4200144b0] - Button.Click()</span><br><span class=\"line\">for _, widget :&#x3D; range []interface&#123;&#125;&#123;label, listBox, button1, button2&#125; &#123;</span><br><span class=\"line\">    if clicker, ok :&#x3D; widget.(Clicker); ok &#123;</span><br><span class=\"line\">        clicker.Click()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"一个-Undo-的委托重构\"><a href=\"#一个-Undo-的委托重构\" class=\"headerlink\" title=\"一个 Undo 的委托重构\"></a>一个 Undo 的委托重构</h3><p>上面这个是 Go 语中的委托和接口多态的编程方式，其实是面向对象和原型编程综合的玩法。这个玩法可不可以玩得更有意思呢？这是可以的。</p>\n<p>首先，我们先声明一个数据容器，其中有 Add()、 Delete() 和 Contains() 方法。还有一个转字符串的方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type IntSet struct &#123;</span><br><span class=\"line\">    data map[int]bool</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewIntSet() IntSet &#123;</span><br><span class=\"line\">    return IntSet&#123;make(map[int]bool)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *IntSet) Add(x int) &#123;</span><br><span class=\"line\">    set.data[x] &#x3D; true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *IntSet) Delete(x int) &#123;</span><br><span class=\"line\">    delete(set.data, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *IntSet) Contains(x int) bool &#123;</span><br><span class=\"line\">    return set.data[x]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *IntSet) String() string &#123; &#x2F;&#x2F; Satisfies fmt.Stringer interface</span><br><span class=\"line\">    if len(set.data) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">        return &quot;&#123;&#125;&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ints :&#x3D; make([]int, 0, len(set.data))</span><br><span class=\"line\">    for i :&#x3D; range set.data &#123;</span><br><span class=\"line\">        ints &#x3D; append(ints, i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort.Ints(ints)</span><br><span class=\"line\">    parts :&#x3D; make([]string, 0, len(ints))</span><br><span class=\"line\">    for _, i :&#x3D; range ints &#123;</span><br><span class=\"line\">        parts &#x3D; append(parts, fmt.Sprint(i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &quot;&#123;&quot; + strings.Join(parts, &quot;,&quot;) + &quot;&#125;&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们如下使用这个数据容器：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ints :&#x3D; NewIntSet()</span><br><span class=\"line\">for _, i :&#x3D; range []int&#123;1, 3, 5, 7&#125; &#123;</span><br><span class=\"line\">    ints.Add(i)</span><br><span class=\"line\">    fmt.Println(ints)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for _, i :&#x3D; range []int&#123;1, 2, 3, 4, 5, 6, 7&#125; &#123;</span><br><span class=\"line\">    fmt.Print(i, ints.Contains(i), &quot; &quot;)</span><br><span class=\"line\">    ints.Delete(i)</span><br><span class=\"line\">    fmt.Println(ints)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个数据容器平淡无奇，我们想给它加一个 Undo 的功能。我们可以这样来：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type UndoableIntSet struct &#123; &#x2F;&#x2F; Poor style</span><br><span class=\"line\">    IntSet    &#x2F;&#x2F; Embedding (delegation)</span><br><span class=\"line\">    functions []func()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewUndoableIntSet() UndoableIntSet &#123;</span><br><span class=\"line\">    return UndoableIntSet&#123;NewIntSet(), nil&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *UndoableIntSet) Add(x int) &#123; &#x2F;&#x2F; Override</span><br><span class=\"line\">    if !set.Contains(x) &#123;</span><br><span class=\"line\">        set.data[x] &#x3D; true</span><br><span class=\"line\">        set.functions &#x3D; append(set.functions, func() &#123; set.Delete(x) &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        set.functions &#x3D; append(set.functions, nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *UndoableIntSet) Delete(x int) &#123; &#x2F;&#x2F; Override</span><br><span class=\"line\">    if set.Contains(x) &#123;</span><br><span class=\"line\">        delete(set.data, x)</span><br><span class=\"line\">        set.functions &#x3D; append(set.functions, func() &#123; set.Add(x) &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        set.functions &#x3D; append(set.functions, nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *UndoableIntSet) Undo() error &#123;</span><br><span class=\"line\">    if len(set.functions) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">        return errors.New(&quot;No functions to undo&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index :&#x3D; len(set.functions) - 1</span><br><span class=\"line\">    if function :&#x3D; set.functions[index]; function !&#x3D; nil &#123;</span><br><span class=\"line\">        function()</span><br><span class=\"line\">        set.functions[index] &#x3D; nil &#x2F;&#x2F; Free closure for garbage collection</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set.functions &#x3D; set.functions[:index]</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>于是就可以这样使用了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ints :&#x3D; NewUndoableIntSet()</span><br><span class=\"line\">for _, i :&#x3D; range []int&#123;1, 3, 5, 7&#125; &#123;</span><br><span class=\"line\">    ints.Add(i)</span><br><span class=\"line\">    fmt.Println(ints)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">for _, i :&#x3D; range []int&#123;1, 2, 3, 4, 5, 6, 7&#125; &#123;</span><br><span class=\"line\">    fmt.Println(i, ints.Contains(i), &quot; &quot;)</span><br><span class=\"line\">    ints.Delete(i)</span><br><span class=\"line\">    fmt.Println(ints)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println()</span><br><span class=\"line\">for &#123;</span><br><span class=\"line\">    if err :&#x3D; ints.Undo(); err !&#x3D; nil &#123;</span><br><span class=\"line\">        break</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(ints)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但是，需要注意的是，我们用了一个新的 UndoableIntSet 几乎重写了所有的 IntSet 和 “写” 相关的方法，这样就可以把操作记录下来，然后 Undo 了。</p>\n<p>但是，可能别的类也需要 Undo 的功能，我是不是要重写所有的需要这个功能的类啊？这样的代码类似，就是因为数据容器不一样，我就要去重写它们，这太二了。</p>\n<p>我们能不能利用前面学到的泛型编程、函数式编程、IoC 等范式来把这个事干得好一些呢？当然是可以的。</p>\n<p>如下所示：</p>\n<p>我们先声明一个 Undo[] 的函数数组（其实是一个栈）。</p>\n<p>并实现一个通用 Add()。其需要一个函数指针，并把这个函数指针存放到 Undo[] 函数数组中。</p>\n<p>在 Undo() 的函数中，我们会遍历Undo[]函数数组，并执行之，执行完后就弹栈。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type Undo []func()</span><br><span class=\"line\"></span><br><span class=\"line\">func (undo *Undo) Add(function func()) &#123;</span><br><span class=\"line\">    *undo &#x3D; append(*undo, function)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (undo *Undo) Undo() error &#123;</span><br><span class=\"line\">    functions :&#x3D; *undo</span><br><span class=\"line\">    if len(functions) &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">        return errors.New(&quot;No functions to undo&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    index :&#x3D; len(functions) - 1</span><br><span class=\"line\">    if function :&#x3D; functions[index]; function !&#x3D; nil &#123;</span><br><span class=\"line\">        function()</span><br><span class=\"line\">        functions[index] &#x3D; nil &#x2F;&#x2F; Free closure for garbage collection</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *undo &#x3D; functions[:index]</span><br><span class=\"line\">    return nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>那么我们的 IntSet 就可以改写成如下的形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">type IntSet struct &#123;</span><br><span class=\"line\">    data map[int]bool</span><br><span class=\"line\">    undo Undo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func NewIntSet() IntSet &#123;</span><br><span class=\"line\">    return IntSet&#123;data: make(map[int]bool)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后在其中的 Add 和 Delete中实现 Undo 操作。</p>\n<p>Add 操作时加入 Delete 操作的 Undo。<br>Delete 操作时加入 Add 操作的 Undo。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (set *IntSet) Add(x int) &#123;</span><br><span class=\"line\">    if !set.Contains(x) &#123;</span><br><span class=\"line\">        set.data[x] &#x3D; true</span><br><span class=\"line\">        set.undo.Add(func() &#123; set.Delete(x) &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        set.undo.Add(nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *IntSet) Delete(x int) &#123;</span><br><span class=\"line\">    if set.Contains(x) &#123;</span><br><span class=\"line\">        delete(set.data, x)</span><br><span class=\"line\">        set.undo.Add(func() &#123; set.Add(x) &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        set.undo.Add(nil)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *IntSet) Undo() error &#123;</span><br><span class=\"line\">    return set.undo.Undo()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (set *IntSet) Contains(x int) bool &#123;</span><br><span class=\"line\">    return set.data[x]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们再次看到，Go 语言的 Undo 接口把 Undo 的流程给抽象出来，而要怎么 Undo 的事交给了业务代码来维护（通过注册一个 Undo 的方法）。这样在 Undo 的时候，就可以回调这个方法来做与业务相关的 Undo 操作了。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>这是不是和最一开始的 C++ 的泛型编程很像？也和 map、reduce、filter 这样的只关心控制流程，不关心业务逻辑的做法很像？而且，一开始用一个 UndoableIntSet 来包装IntSet类，到反过来在IntSet里依赖Undo类，这就是控制反转 IoC。</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编程范式游记（9）- 编程的本质","url":"/2016/01/09/mouse/programming-paradigm-travel-9-the-essence-of-programming/","content":"<p>我们讲了各式各样的不同语言的编程范式，从 C 语言的泛型，讲到 C++ 的泛型，再讲到函数式的 Map/Reduce/Filter，以及 Pipeline 和 Decorator，还有面向对象的多态通过依赖于接口而不是实现的桥接模式、策略模式和代理模式，以及面向对象的 IoC，还有 JavaScript 的原型编程在运行时对对象原型进行修改，以及 Go 语言的委托模式……</p>\n<p>所有的这一切，不知道你是否看出一些端倪，或是其中的一些共性来了？<br><a id=\"more\"></a></p>\n<h3 id=\"两篇论文\"><a href=\"#两篇论文\" class=\"headerlink\" title=\"两篇论文\"></a>两篇论文</h3><p>1976 年，瑞士计算机科学家，Algol W，Modula，Oberon 和 Pascal 语言的设计师 Niklaus Emil Wirth写了一本非常经典的书《Algorithms + Data Structures = Programs》（链接为 1985 年版） ，即算法 + 数据结构 = 程序。</p>\n<p>这本书主要写了算法和数据结构的关系，这本书对计算机科学的影响非常深远，尤其在计算机科学的教育中。</p>\n<p>1979 年，英国逻辑学家和计算机科学家 Robert Kowalski 发表论文 Algorithm = Logic + Control，并且主要开发“逻辑编程”相关的工作。</p>\n<p>Robert Kowalski 是一位逻辑学家和计算机科学家，从 20 世纪 70 年代末到整个 80 年代致力于数据库的研究，并在用计算机证明数学定理等当年的重要应用上颇有建树，尤其是在逻辑、控制和算法等方面提出了革命性的理论，极大地影响了数据库、编程语言，直至今日的人工智能。</p>\n<p>Robert Kowalski 在这篇论文里提到：</p>\n<blockquote>\n<p>An algorithm can be regarded as consisting of a logic component, which specifies the knowledge to be used in solving problems, and a control component, which determines the problem-solving strategies by means of which that knowledge is used. The logic component determines the meaning of the algorithm whereas the control component only affects its efficiency. The efficiency of an algorithm can often be improved by improving the control component without changing the logic of the algorithm. We argue that computer programs would be more often correct and more easily improved and modified if their logic and control aspects were identified and separated in the program text.</p>\n</blockquote>\n<p>翻译过来的意思大概就是：</p>\n<blockquote>\n<p>任何算法都会有两个部分， 一个是 Logic 部分，这是用来解决实际问题的。另一个是 Control 部分，这是用来决定用什么策略来解决问题。Logic 部分是真正意义上的解决问题的算法，而 Control 部分只是影响解决这个问题的效率。程序运行的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护。</p>\n</blockquote>\n<p>注意，最后一句话是重点——<strong>如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护</strong>。</p>\n<h3 id=\"编程的本质\"><a href=\"#编程的本质\" class=\"headerlink\" title=\"编程的本质\"></a>编程的本质</h3><p>两位老先生的两个表达式：</p>\n<blockquote>\n<p>Programs = Algorithms + Data Structures<br>Algorithm = Logic + Control</p>\n</blockquote>\n<p>第一个表达式倾向于数据结构和算法，它是想把这两个拆分，早期都在走这条路。他们认为，如果数据结构设计得好，算法也会变得简单，而且一个好的通用的算法应该可以用在不同的数据结构上。</p>\n<p>第二个表达式则想表达，数据结构不复杂，复杂的是算法，也就是我们的业务逻辑是复杂的。我们的算法由两个逻辑组成，一个是真正的业务逻辑，另外一种是控制逻辑。程序中有两种代码，一种是真正的业务逻辑代码，另一种代码是控制我们程序的代码，叫控制代码，这根本不是业务逻辑，业务逻辑不关心这个事情。</p>\n<p>算法的效率往往可以通过提高控制部分的效率来实现，而无须改变逻辑部分，也就无无须改变算法的意义。举个阶乘的例子： X(n)！= X(n) X(n-1) X(n-2) X(n-3) ... 3 2 1。逻辑部分用来定义阶乘：1） 1 是 0 的阶乘； 2）如果 v 是 x 的阶乘，且 u=v(x+1)，那么 u 是 x+1 的阶乘。</p>\n<p>用这个定义，既可以从上往下地将 x+1 的阶乘缩小为先计算 x 的阶乘，再将结果乘以 1（recursive，递归），也可以由下而上逐个计算一系列阶乘的结果（iteration，遍历）。</p>\n<p>控制部分用来描述如何使用逻辑。最粗略的看法可以认为“控制”是解决问题的策略，而不会改变算法的意义，因为算法的意义是由逻辑决定的。对同一个逻辑，使用不同控制，所得到的算法，本质是等价的，因为它们解决同样的问题，并得到同样的结果。</p>\n<p>因此，我们可以通过逻辑分析，来提高算法的效率，保持它的逻辑，而更好地使用这一逻辑。比如，有时用自上而下的控制替代自下而上，能提高效率。而将自上而下的顺序执行改为并行执行，也会提高效率。</p>\n<p>总之，通过这两个表达式，我们可以得出：</p>\n<blockquote>\n<p>Program = Logic + Control + Data Structure</p>\n</blockquote>\n<p>前面讲了这么多的编程范式，或是程序设计的方法。其实，我们都是在围绕着这三件事来做的。比如：</p>\n<p>就像函数式编程中的 Map/Reduce/Filter，它们都是一种控制。而传给这些控制模块的那个 lambda 表达式才是我们要解决的问题的逻辑，它们共同组成了一个算法。最后，我再把数据放在数据结构里进行处理，最终就成为了我们的程序。</p>\n<p>就像我们 Go 语言的委托模式的那个 Undo 示例一样。Undo 这个事是我们想要解决的问题，是 Logic，但是 Undo 的流程是控制。</p>\n<p>就像我们面向对象中依赖于接口而不是实现一样，接口是对逻辑的抽象，真正的逻辑放在不同的具现类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。</p>\n<p>如果你再仔细地结合我们之前讲的各式各样的编程范式来思考上述这些概念的话，你是否会觉得，所有的语言或编程范式都在解决上面的这些问题。也就下面的这几个事。</p>\n<p>Control 是可以标准化的。比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。</p>\n<p>因为 Control 需要处理数据，所以标准化 Control，需要标准化 Data Structure，我们可以通过泛型编程来解决这个事。</p>\n<p>而 Control 还要处理用户的业务逻辑，即 Logic。所以，我们可以通过标准化接口 / 协议来实现，我们的 Control 模式可以适配于任何的 Logic。</p>\n<p>上述三点，就是编程范式的本质。</p>\n<ul>\n<li><p>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</p>\n</li>\n<li><p>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</p>\n</li>\n<li><p>有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！</p>\n</li>\n</ul>\n<p>我们在写代码当中，就会看到好多这种代码，会把控制逻辑和业务逻辑放在一块。里面有些变量和流程是跟业务相关的，有些是不相关的。业务逻辑决定了程序的复杂度，业务逻辑本身就复杂，你的代码就不可能写得简单。</p>\n<p>Logic，它是程序复杂度的的下限，然后，我们为了控制程序，需要再搞出很多控制代码，于是 Logic+Control 的相互交织成为了最终的程序复杂度。</p>\n<h4 id=\"把逻辑和控制混淆的示例\"><a href=\"#把逻辑和控制混淆的示例\" class=\"headerlink\" title=\"把逻辑和控制混淆的示例\"></a>把逻辑和控制混淆的示例</h4><p>我们来看一个示例，这是我在 leetcode 上做的一道题，这是通配符匹配，给两个字符串匹配。需求如下：</p>\n<p>通配符匹配<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">isMatch(&quot;aa&quot;,&quot;a&quot;) → false</span><br><span class=\"line\">isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</span><br><span class=\"line\">isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</span><br><span class=\"line\">isMatch(&quot;aa&quot;, &quot;*&quot;) → true</span><br><span class=\"line\">isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</span><br><span class=\"line\">isMatch(&quot;ab&quot;, &quot;?*&quot;) → true</span><br><span class=\"line\">isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → false</span><br></pre></td></tr></table></figure><br>现在你再看看我写出来的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bool isMatch(const char *s, const char *p) &#123;</span><br><span class=\"line\">    const char *last_s &#x3D; NULL;</span><br><span class=\"line\">    const char *last_p &#x3D; NULL;</span><br><span class=\"line\"></span><br><span class=\"line\">    while ( *s !&#x3D; &#39;\\0&#39; ) &#123;</span><br><span class=\"line\">        if ( *p &#x3D;&#x3D; &#39;*&#39; ) &#123;</span><br><span class=\"line\">            p++;</span><br><span class=\"line\">            if ( *p &#x3D;&#x3D; &#39;\\0&#39; ) return true;</span><br><span class=\"line\">            last_s &#x3D; s;</span><br><span class=\"line\">            last_p &#x3D; p;</span><br><span class=\"line\">        &#125; else if ( *p &#x3D;&#x3D; &#39;?&#39; || *s &#x3D;&#x3D; *p ) &#123;</span><br><span class=\"line\">            s++;</span><br><span class=\"line\">            p++;</span><br><span class=\"line\">        &#125; else if ( last_s !&#x3D; NULL ） &#123;</span><br><span class=\"line\">            p &#x3D; last_p;</span><br><span class=\"line\">            s &#x3D; ++last_s;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while ( *p &#x3D;&#x3D; &#39;*&#39; ) p++;</span><br><span class=\"line\">    return *p &#x3D;&#x3D; &#39;\\0&#39;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我也不知道我怎么写出来的，好像是为了要通过，我需要关注于性能，你看，上面这段代码有多乱。如果我不写注释你可能都看不懂了。就算我写了注释以后，你敢改吗？你可能连动都不敢动（哈哈）。上面这些代码里面很多都不是业务逻辑，是用来控制程序的逻辑。</p>\n<p>业务逻辑是相对复杂的，但是控制逻辑跟业务逻辑交叉在一块，虽然代码写得不多，但是这个代码已经够复杂了。两三天以后，我回头看，我到底写的什么，我也不懂，为什么会写成这样？我当时脑子是怎么想的？我完全不知道。我现在就是这种感觉。</p>\n<p>那么，怎么把上面那段代码写得更好一些呢？</p>\n<p>首先，我们需要一个比较通用的状态机（NFA，非确定有限自动机，或者 DFA，确定性有限自动机），来维护匹配的开始和结束的状态。这属于 Control。</p>\n<p>如果我们做得好的话，还可以抽像出一个像程序的文法分析一样的东西。这也是 Control。</p>\n<p>然后，我们把匹配 * 和 ? 的算法形成不同的匹配策略。</p>\n<p>这样，我们的代码就会变得漂亮一些了，而且也会快速一些。</p>\n<p>这里有篇正则表达式的高效算法的论文Regular Expression Matching Can Be Simple And Fast，推荐你读一读，里面有相关的实现，我在这里就不多说了。</p>\n<p>这里，想说的程序的本质是 Logic+Control+Data，而其中，Logic 和 Control 是关键。注意，这个和系统架构也有相通的地方，逻辑是你的业务逻辑，逻辑过程的抽象，加上一个由术语表示的数据结构的定义，控制逻辑跟你的业务逻辑是没关系的，你控制它执行。</p>\n<p>控制一个程序流转的方式，即程序执行的方式，并行还是串行，同步还是异步，以及调度不同执行路径或模块，数据之间的存储关系，这些和业务逻辑没有关系。</p>\n<p>如果你看过那些混乱不堪的代码，你会发现其中最大的问题是我们把这 Logic 和 Control 纠缠在一起了，所以会导致代码很混乱，难以维护，Bug 很多。绝大多数程序复杂的原因就是这个问题。就如同下面这幅图中表现的情况一样。</p>\n<p>再来一个简单的示例<br>这里给一个简单的示例。</p>\n<p>下面是一段检查用户表单信息常见的代码，我相信这样的代码你见得多了。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function check_form_x() &#123;</span><br><span class=\"line\">    var name &#x3D; $(&#39;#name&#39;).val();</span><br><span class=\"line\">    if (null &#x3D;&#x3D; name || name.length &lt;&#x3D; 3) &#123;</span><br><span class=\"line\">        return &#123; status : 1, message: &#39;Invalid name&#39; &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var password &#x3D; $(&#39;#password&#39;).val();</span><br><span class=\"line\">    if (null &#x3D;&#x3D; password || password.length &lt;&#x3D; 8) &#123;</span><br><span class=\"line\">        return &#123; status : 2, message: &#39;Invalid password&#39; &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var repeat_password &#x3D; $(&#39;#repeat_password&#39;).val();</span><br><span class=\"line\">    if (repeat_password !&#x3D; password.length) &#123;</span><br><span class=\"line\">        return &#123; status : 3, message: &#39;Password and repeat password mismatch&#39; &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    var email &#x3D; $(&#39;#email&#39;).val();</span><br><span class=\"line\">    if (check_email_format(email)) &#123;</span><br><span class=\"line\">        return &#123; status : 4, message: &#39;Invalid email&#39; &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    return &#123; status : 0, message: &#39;OK&#39; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但其实，我们可以做一个 DSL+ 一个 DSL 的解析器，比如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var meta_create_user &#x3D; &#123;</span><br><span class=\"line\">    form_id : &#39;create_user&#39;,</span><br><span class=\"line\">    fields : [</span><br><span class=\"line\">        &#123; id : &#39;name&#39;, type : &#39;text&#39;, min_length : 3 &#125;,</span><br><span class=\"line\">        &#123; id : &#39;password&#39;, type : &#39;password&#39;, min_length : 8 &#125;,</span><br><span class=\"line\">        &#123; id : &#39;repeat-password&#39;, type : &#39;password&#39;, min_length : 8 &#125;,</span><br><span class=\"line\">        &#123; id : &#39;email&#39;, type : &#39;email&#39; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var r &#x3D; check_form(meta_create_user);</span><br></pre></td></tr></table></figure><br>这样，DSL 的描述是“Logic”，而我们的 check_form 则成了“Control”，代码就非常好看了。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>代码复杂度的原因：</p>\n<ul>\n<li>业务逻辑的复杂度决定了代码的复杂度；</li>\n<li>控制逻辑的复杂度 + 业务逻辑的复杂度 ==&gt; 程序代码的混乱不堪；</li>\n<li><p>绝大多数程序复杂混乱的根本原因：业务逻辑与控制逻辑的耦合。<br>如何分离 control 和 logic 呢？我们可以使用下面的这些技术来解耦。</p>\n</li>\n<li><p>State Machine</p>\n<ul>\n<li>状态定义</li>\n<li>状态变迁条件</li>\n<li>状态的 action</li>\n<li>DSL – Domain Specific Language</li>\n</ul>\n</li>\n<li><p>HTML，SQL，Unix Shell Script，AWK，正则表达式……</p>\n</li>\n<li>编程范式<ul>\n<li>面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC……</li>\n<li>函数式编程：修饰、管道、拼装</li>\n<li>逻辑推导式编程：Prolog</li>\n</ul>\n</li>\n</ul>\n<p>这就是编程的本质：</p>\n<p><strong>Logic 部分才是真正有意义的（What）<br>Control 部分只是影响 Logic 部分的效率（How）</strong></p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"重读《天龙八部》","url":"/2018/11/15/read/tianlongbabu/","content":"<p>《天龙八部》书名出于佛经，包括八种神道怪物，有“世间众生”的意思，寓意象征着大千世界的芸芸众生，背后笼罩着佛法的无边与超脱。全书主旨“无人不冤，有情皆孽”，作品风格宏伟悲壮，是一部写尽人性、悲剧色彩浓厚的史诗巨著。<br><a id=\"more\"></a><br>2018年10月30日，金庸去世。</p>\n<p>从电视剧、小说、高中语文读本中都看过他的作品。我的中学时代，互联网还没有现在这么普及，手机更是谈不上，业余时间大部分是被他的作品占据的。《射雕英雄传》《笑傲江湖》《神雕侠侣》《天龙八部》都是我非常喜爱的故事，其中以《天龙八部》为最爱。先生去世，留下了经典，深感痛惜。又拾起《天龙八部》重温，读出了许多味道。以前只是当作故事来看个热闹，现在有些阅历之后，再看，对人生、对社会、对历史的追寻和探索便可以体会出来。以我的水平不足以写出合格的书评或感悟，所以便去网络上找了一些现成的评论和探究，拣了一些认同的观点，摘录如下：</p>\n<p>《天龙八部》是中国现代作家金庸创作的长篇武侠小说。这部小说从1963年开始创作，历时4年完成。前后共有三版，并在2005年第三版中经历6稿修订。</p>\n<p>《天龙八部》书名出于佛经，包括八种神道怪物，有“世间众生”的意思，寓意象征着大千世界的芸芸众生，背后笼罩着佛法的无边与超脱。全书主旨“无人不冤，有情皆孽”，作品风格宏伟悲壮，是一部写尽人性、悲剧色彩浓厚的史诗巨著。</p>\n<p>小说以宋哲宗时代为背景，通过宋、辽、大理、西夏、吐蕃等王国之间的武林恩怨和民族矛盾，从哲学的高度对人生和社会进行审视和描写，展示了一幅波澜壮阔的生活画卷，其故事之离奇曲折、涉及人物之众多、历史背景之广泛、武侠战役之庞大、想象力之丰富当属“金书”之最。</p>\n<p>作者怀着悲天悯人的创作心态，夸张地描绘了各色人物在命运操纵和欲望支配下的种种心态和情状，刻画了尘世众生的痛苦和悲哀。书中以段誉、乔峰、虚竹三大主角为代表的主要人物，似乎都有一种与生俱来的“命运”的悲剧色彩，他们的一次次奋进和抗争都不可避免的滑向不幸的旋涡。然而金庸不仅仅局限于“命运”给人造成的巨大的灾难与不幸，而是以尖锐的笔触直指人性中的卑劣和肮脏，深刻地揭示了“命运悲剧”的内在成因。同时，他又借助民族纷争的特殊历史时代，积极探询民族文化背景下的悲剧冲突。把《天龙八部》称为北宋时期“罪与罚”，最为恰当不过。</p>\n<p>书中人物离奇，情节的合理性让位于意境和寓意，无不有过人之处，有帝王公卿，有江湖豪客，有长生的术士，有俊雅的少年，有神仙天人般的美女，有匪夷所思的武功，有阴谋，有复仇，有陷害，有误会……天龙八部，人与非人，同聆佛法，从南海到北国，从姑苏到天山，果然是北冥有鲲，化而为鸟，横绝四海。这么恢宏超常的众生，结篇却是发了疯的慕容复在坟园沈浸于帝王的幻想，一群小儿嬉笑着扮演臣民换糖吃。一个明白不过的寓言：红颜转瞬白骨，才能、功业、野心、爱恨如露如电，梦幻泡影。在这个寓言之下，那前面五大卷的热闹同归于一个幻影，悲天悯人，《天龙八部》里奇异的缘法，未必是颠覆英雄主义，但至少有着深刻的悲伤和疑问，亦正是这悲伤和疑问，成全了英雄之所以为英雄。</p>\n<h2 id=\"一、“俄狄浦斯”式的命运捉弄\"><a href=\"#一、“俄狄浦斯”式的命运捉弄\" class=\"headerlink\" title=\"一、“俄狄浦斯”式的命运捉弄\"></a>一、“俄狄浦斯”式的命运捉弄</h2><p>金庸的《天龙八部》和古希腊著名悲剧《俄狄浦斯王》从表面上看并无直接联系，但是，如果对《天龙八部》进行原形分析，就可以透过两部作品的巨大差异看到他们深刻的内在统一性。俄狄浦斯的悲剧是古希腊神话传说中最具有命定色彩的悲剧，俄狄浦斯越是想逃避命中注定的不幸，越是更深地陷入悲剧命运的魔圈。在此，索福克勒斯向人们揭示了这样一个深刻的命题：命运是如此捉弄人，在压倒一切的命运前，人是多么渺小，无力，无法把握自己。以这样一种悲剧意识来反观金庸的《天龙八部》，就会发现作品中的主人公段誉、乔峰、虚竹身上都有俄狄浦斯的身影。他们都在与不幸的命运做抗争，但他们都无法战胜命运，最后和俄狄浦斯一样被一种不可知的神秘力量以玄妙不可解而又不可避免的方式操纵着，走向更深的不幸。金庸似乎和索福克勒斯一样在讲述一个由命运之神造成的古老而又遥远的苦难。</p>\n<p>金庸在《天龙八部》中通过段誉、乔峰、虚竹的命运悲剧充分展示了人和命运的尖锐冲突和命运对人的无情嘲弄，三位主人公都和俄狄浦斯一样在邪恶命运的摆布下遭受了巨大的痛苦和不幸。从某种意义上说，《天龙八部》作为一部人生的悲剧寓言，它反映了现代人对命运的思考和面对命运的不可知的困惑。</p>\n<p>金庸作为一个通俗文学家，自称讲故事的人，他自己说：“我只求把故事讲得生动热闹”。然而，当金庸在他的作品中，特别是在《天龙八部》中表现出俄狄浦斯悲剧的原型，并以无法摆脱的偶然和近乎命定的绝对向现代人昭示生命的悲哀和无望时，《天龙八部》早已远远超出他讲故事的目的。也许金庸在塑造段誉、乔峰、虚竹时并没有想到俄狄浦斯的悲剧，但是当他在作品中对现代人的命运进行思考时，面对异化自身的物质世界，不可避免地要陷入与索福克勒斯同样的困惑和悲观，而当他带着这种情绪寻找悲剧命运的根源时，便自然而然地激活了潜意识里的原型。</p>\n<h2 id=\"二、受困于佛家“贪嗔痴”的悲剧人生\"><a href=\"#二、受困于佛家“贪嗔痴”的悲剧人生\" class=\"headerlink\" title=\"二、受困于佛家“贪嗔痴”的悲剧人生\"></a>二、受困于佛家“贪嗔痴”的悲剧人生</h2><p>金庸写作《天龙八部》，受佛经的影响非常明显，不仅书名直接来源于佛经，书中内容也处处流露着佛家悲天悯人的情怀，有的情节甚至是佛理的直接推衍。作为“神界”原型的“人界”的种种悲欢仇怨，在金庸“显微镜”观察下几乎可称凄厉恐怖。如果以佛家的眼光来看，则更是“朗朗世界到处藏着魍魉和鬼蜮”了。而书中的“怨”和“孽”又紧紧和佛家“三毒”联系在一起。“贪、嗔、痴”是三种普通的人性因素，佛家称之为“三毒”，它成为《天龙八部》人生世界里痛苦不堪的“因”和“缘”，也是书中除命运悲剧外各类悲剧的总根源。</p>\n<p>《天龙八部》的权位之贪，仇恨嗔怒，情欲仇怨这三条悲剧线索，组成了一种独特的关系网。以“贪嗔痴”三者为基础，《天龙八部》最大限度地综合了人世间的一切痛苦，书中所有的人物，无不生活在这样那样的痛苦之中，每个人的一生都带着无可逃避的悲剧枷锁。贪、嗔、痴这三条巨绳织成了一张巨大的、无处不在的网，每一个人都是网中人――而这一张网，正是“人世间”的一种深刻的象征。这样的世界中无人不冤，没有人能逃离这张巨网，所有的行为都造成了一份这样或那样的罪孽。</p>\n<p>《天龙八部》的独特深刻之处在于，它揭示了人生的大悲剧中人人都是“网中人”，而人人又都是“网织者”。小说中段延庆固然是“恶贯满盈”，“无恶不作”，但他并非天性如此。他首先是“受害者”，然后才是“害人者”。同样，萧氏父子，玄慈等人，本算不得什么坏人，但都做了错事与坏事：玄慈杀了乔峰之母，使之家破人亡，萧远山为了报仇而杀了更多的人。至于小说中的段正淳，非但不是什么坏人，而且也没有做什么错事，但他的报应却如此的不堪，以至不死就不能解脱。他给甘宝宝，秦红棉等一大批女性造成的悲剧是无发挽回的。</p>\n<p>所有的一切，似乎都可以用“命运”二字来概括，但《天龙八部》的深刻之处就在，它揭示了这一悲剧“命运”形成的原因，那就在于人的本身。每个人都是这种命运的受害者，而每个人又是这种命运的制造者。每个人的所作所为，所思所欲不一定会报应到自己的头上，但会报应到同类人身上，而同类人所作所为的后果，又会影响到其他“不相干”的人，从而造成这个“非人的世界”，这也正是金庸悲剧观的重要体现。</p>\n<h2 id=\"三、民族纷争下的悲剧冲突\"><a href=\"#三、民族纷争下的悲剧冲突\" class=\"headerlink\" title=\"三、民族纷争下的悲剧冲突\"></a>三、民族纷争下的悲剧冲突</h2><p>值得注意的是，《天龙八部》中金庸展开悲剧并不仅仅局限于个人命运的浮沉，而是将更深邃的目光投向广阔的社会，借北宋时期民族政权并立的特殊历史时代，探询民族文化冲突下的悲剧，因而《天龙八部》中所揭示的社会层面上的悲剧比一般的个人悲剧具有更加震撼人心的艺术力量。</p>\n<p>《天龙八部》故事发生于北宋哲宗绍圣年间，在这一历史时期，大宋，辽国，女真，西夏，大理并立，五个政治集团为了各自的利益展开了错综复杂的政治军事斗争，尤其是实力最强的大宋和大辽，互相仇视和欺压，种种情状，令人不寒而栗。在《天龙八部》中，无论是大宋王朝，还是契丹社会，都一致认为抵御外族是天经地义，理所当然的事情。只有深受身世之苦的萧峰在想：“我们这些人说一样的话，吃一样的饭，又有什么分别？为什么大家好好的都是人，却要强分契丹、大宋、女真、高丽？你到我境内来打草谷，我到你境内去杀人放火？你骂我辽狗，我叫你宋猪？”然而，在那民族纷争的时代，又有谁能听到乔峰那微弱的声音？在盲目的“排外”思想的指导下，宋辽边境的军民不断的对异方烧杀抢掠，而每一次的“打草谷”其实就是一次次民族纷争下悲剧事件的永无止境的延续。</p>\n<p>在创作《天龙八部》时，金庸对民族矛盾及民族国家之间的冲突，有了新的思想认识和新的处理方式，即不再局限于狭隘的“民族主义”和“爱国主义”，而是升华至中华民族的整体利益的考虑，更多的倾向于和平主义和民族的和睦与团结，从而超越了狭隘的民族矛盾，对战争与和平有了崭新的思考。金庸正是持着一视同仁的基调进行创作，因而对各民族之间永无休止的仇杀争斗流露出无比的痛心，也使整部《天龙八部》的民族纷争显示出一种苍凉的悲剧色彩。</p>\n","categories":["read"],"tags":["note"]},{"title":"《小米生态链战地笔记》书摘","url":"/2019/08/30/read/xianmishengtailian/","content":"<p>如果我们一件产品，两件产品，100件产品都是这么做的，最后的结果是什么？改变中国制造业！<br><a id=\"more\"></a></p>\n<h1 id=\"小米生态链战地笔记-生态篇\"><a href=\"#小米生态链战地笔记-生态篇\" class=\"headerlink\" title=\"小米生态链战地笔记-生态篇\"></a>小米生态链战地笔记-生态篇</h1><h2 id=\"抢跑IoT\"><a href=\"#抢跑IoT\" class=\"headerlink\" title=\"抢跑IoT\"></a>抢跑IoT</h2><p>互联网思维的本质其实就是<strong>提升效率</strong>。</p>\n<p>一旦毛利率高，公司就会丧失持续创新的动力。</p>\n<p>如果我们一件产品，两件产品，100件产品都是这么做的，最后的结果是什么？改变中国制造业！</p>\n<p>单点突破做到极致。</p>\n<p>第1个阶段是<strong>互联网</strong>，第2个阶段是<strong>移动互联网</strong>，第三阶段是<strong>物联网</strong>。</p>\n<p>离手机近的，早点干，离手机远的晚点干，离用户群近的早点干，离用户群远的晚点干。</p>\n<p>小米生态链不仅是一家生产产品的公司，还是一个生产公司的公司。</p>\n<p>小米对生态链企业投资，一直都坚持只占小股，一来是保持队伍的独立性和生猛性，二来是因为我们的核心思路在于，用小米成功的模式复制一批智能硬件领域的企业，在这样的一个生态环境里，资本只是建立关系的一个纽带，而价值观方法论的传导才是整个生态系统能够繁衍下去的根本。</p>\n<p>创业公司之所以要和其他的投资机构不停的在原始估值上纠结，讨价还价，其根本还是因为除了钱，创业公司能从投资机构获得的其他支持都非常有限。</p>\n<p>小米生态链的价值观是什么？<strong>一、不赚快钱，二、立志做最好的产品，三、追求产品的高性价比，四、坚信互联网模式是先进的，五、提升效率改造传统行业。</strong></p>\n<p><strong>因为收购之后，被收购方就失去了独立性，变成了大公司的一个部门，于是失去了独立发展的欲望，开始变得平庸无为，被收前是一匹狼，拼命的往前跑，一旦被收购，创业成果被兑现，生活无忧，财务自由，不再是为自己工作，也就没了动力。</strong></p>\n<p>当然小米对生态链公司不仅仅是投资，更重要的是我们从各种维度上帮助生态链公司复制小米模式打造杰出的产品。</p>\n<p>小米生态链投资就是由小米输出做产品的价值观方法论和已有的资源，包括电商平台，营销团队，品牌等等，围绕自己建立起一支航母舰队。</p>\n<h2 id=\"竹林效应\"><a href=\"#竹林效应\" class=\"headerlink\" title=\"竹林效应\"></a>竹林效应</h2><p>小米生态链是投资加孵化的模式。</p>\n<p>小米打了6年的仗，到底得到了什么？<strong>第一，得到了一支队伍，第二，有热度的品牌，第三，用户群，第四，电商平台，第五，供应链能力，第六，资本，第七，信誉，第八，总结了一套怎么做产品的方法论，第九，社会的关注度。</strong></p>\n<p>竹林效应，传统企业的发展，小松树用百年才能成长起来，互联网环境下的企业像竹笋，一夜春雨，就都涨起来了。</p>\n<p>用寻找竹笋的方式做投资。</p>\n<p>用竹林理论做一个泛集团公司。</p>\n<p>近两年，业内开始提出一种新的创业模式，积木式创新, 在创新的过程中，不同要素之间进行如积木般的组合。而我们生态链的模式，更像是共享经济式的创新，每一个企业都有自己的核心和外延，而这些企业之间因为有小米的基因，所有的资源又可以共享，形成一个泛集团公司。</p>\n<p>在生态链企业不断发展壮大的过程中，我们现在也开始考虑生态链公司的退出机制，竹林效应的一大特点就是能够自我完成新陈代谢过程。</p>\n<p>小米生态链企业的保护期已经不是秘密，小米会承诺在2~3年内不投资同品类的企业。但，绝不保护落后。</p>\n<p><strong>保持微妙的竞争。</strong></p>\n<p>我们是在找一群一起战斗的兄弟，而没有义务永远帮助谁。</p>\n<p>雷军在研究了阿里巴巴成功的故事之后，总结出三大要素：<strong>第一，必须选择一个巨大的市场。第二网罗全球的人才，第三融到巨资。</strong> 物联网就是雷军选定的巨大的市场趋势，但是直面攻击，孤军奋战的，肯定没有打赢的机会，于是他们构建了一种非常复杂的模式，180度迂回作战，先做互联网手机用手机的新风景产生的势能，建立生态链，再通过复制小米模式，让专业的团队更高效，更专注的做出更多高品质的硬件产品，与智能手机紧密有致的整合在一起，进而增加小米的安全系数。</p>\n<p>物联网时代的新物种，如今小米生态链作为新物种已经具备了先锋性，竹林强大的根系已然形成，继而又产生了新的势能，复杂性在于这几层关系，第一竹林效应，小米的资源如同竹林强大的根系，而小米生态链上的产品如同一颗颗的春笋。<strong>五角大楼</strong> 和 <strong>特种部队</strong> ，生态链上孵化的企业要参与到每一个细分市场的竞争中去，在每一个战场每打一场战役时都是五角大楼与特种部队相配合，五角大楼在后方提供一切支持，一直有经验的特种部队在前方执行完成整个计划。<strong>航母</strong> 与 <strong>舰队</strong> ，小母小米与生态链企业之间是航母与舰队的关系，其实整个小米舰队不止小米生态链上的77个企业，下面通过各种形式参与投资的企业已达220家，这只庞大的舰队是小米参与物联网竞争的整体阵容，在物联网时代小米舰队是一个新物种。</p>\n<p>做生态更深层次的原因，来自雷军的一个梦想，这是一个务实的理想主义者的梦想，带动一批跟小米有着相同价值观，愿意打造极致产品，充满活力的中国企业一起改变中国制造业，改变中国制造业在全世界人心目中的印象，就像索尼带动日本，三星带动韩国那样，让这一群体真正助力中国制造业的转型升级。</p>\n<h2 id=\"奔跑中的思考\"><a href=\"#奔跑中的思考\" class=\"headerlink\" title=\"奔跑中的思考\"></a>奔跑中的思考</h2><h3 id=\"用军事理论做商业\"><a href=\"#用军事理论做商业\" class=\"headerlink\" title=\"用军事理论做商业\"></a>用军事理论做商业</h3><p>一个时代最先锋的理论一定是军事理论，而不是商业理论，为什么？因为商业的输赢要钱，而军事的输赢则要命。</p>\n<p>奔跑中我们认为有2点很重要，第一大方向选对后一定要保证公布的速度，奔跑本身即可解决问题，要不断的向我学习，通过实践摸索新的理论，将理论运用到实践中。</p>\n<p>让小米和被孵化的企业都能符合互联网七字诀： <strong>专注、极致、口碑，快</strong>。</p>\n<h3 id=\"以小米速度保持先锋势能\"><a href=\"#以小米速度保持先锋势能\" class=\"headerlink\" title=\"以小米速度保持先锋势能\"></a>以小米速度保持先锋势能</h3><p>有速度才能保持先锋性，一旦一家企业具有了先锋性，<strong>一、他可以吸引最顶尖的人才来做出最好的产品，二、他会吸引更多投资人的关注，可以用到大量的资金，三、他会引起更多媒体关注，高曝光度有助于品牌的传播与塑造。</strong></p>\n<p>小米模式的核心是高效率，在每一个环节提高效率并压缩成本，产品本身则追求最优解和高品质，所以每一款产品出来都会在市场上形成强烈的冲击力。</p>\n<h3 id=\"看透本质\"><a href=\"#看透本质\" class=\"headerlink\" title=\"看透本质\"></a>看透本质</h3><p>找到本源逻辑</p>\n<p><strong>效率，效率，还是效率</strong></p>\n<p>去除中间环节，前店后厂</p>\n<p>线下新物种</p>\n<p>保持逆境状态</p>\n<p>思维天花板</p>\n<p>空杯心态</p>\n<p>聪明的人在一起做事分歧很少，因为大家都抓事物的本质，不会在细枝末节上纠缠，聪明人懂得相互信任，团队协同作战，如果不能充分信任，仗是没法打的。</p>\n<p>商战是一场精密的战争，竞争包括 <strong>团队、品牌、产品、供应链、渠道、用户、资本</strong>，社会影响力等多个维度，每一个维度都关系到整场战争的成败。</p>\n<p>小米的售价为什么比很多企业的成本价都低，本质只在于两个字“<strong>效率</strong>”，<strong>效率隐藏于每一个细节当中</strong>，我们通过对每一环节的改造或者创新，把一个企业的效率做到最高。</p>\n<h2 id=\"自动生成的未来\"><a href=\"#自动生成的未来\" class=\"headerlink\" title=\"自动生成的未来\"></a>自动生成的未来</h2><p>谁又能预知未来万物互联时代，商业发展的态势到底是什么样的，没人能够准确判断，所以小米布局生态，让生态自我更新淘汰进化，自然生成未来。</p>\n<p>极少有家庭在装修的时候，就考虑系统性的为自己搭建出一套智能家居系统来，更切合实际的做法，是将一个又一个的白电，实现智能化，让一个又一个智能化的产品逐步走入家庭，把他们通过云端连接起来，或许有一天你会发现突然间家里就实现了智能化，但是这个前提是云、管、端的水到渠成。</p>\n<p>产品型公司值十亿美元，平台型公司值百亿美元，生态型公司值千亿美元。</p>\n<p>在小米的生态链上，初期新生命体分享小米的红利，这就是我们讲的孵化阶段；中期是互相依赖、互相增值，也就是我们讲的互为放大器阶段；最后是不断创造新的价值，通过繁衍和进化，形成新的生命体。</p>\n<h1 id=\"小米生态链战地笔记-产品篇\"><a href=\"#小米生态链战地笔记-产品篇\" class=\"headerlink\" title=\"小米生态链战地笔记-产品篇\"></a>小米生态链战地笔记-产品篇</h1><p>在这个时代，与其在营销上费尽心思，不如把精力用于研究如何解决用户最大的痛点、满足他们最紧迫的需求。只有踏踏实实把产品做好，才有机会迈出成功的第一步。</p>\n<h2 id=\"第一章-做产品，摸准时代的脉搏\"><a href=\"#第一章-做产品，摸准时代的脉搏\" class=\"headerlink\" title=\"第一章 做产品，摸准时代的脉搏\"></a>第一章 做产品，摸准时代的脉搏</h2><p>在过去30年里，中国有3个领域可以赚到百亿以上：第一个领域是<strong>房地产</strong>；第二个领域是<strong>能源</strong>；第三个领域就是<strong>互联网</strong>。在过去的30年里，创业的团队，如果不是进入这3个领域，那么无论你怎样努力，团队如何齐心，赚到百亿以上的机会都很渺茫。</p>\n<p><strong>做小公司靠努力，做大公司靠运气</strong>。</p>\n<h3 id=\"第一节-未来十年是大消费的十年\"><a href=\"#第一节-未来十年是大消费的十年\" class=\"headerlink\" title=\"第一节 未来十年是大消费的十年\"></a>第一节 未来十年是大消费的十年</h3><p>究竟什么样的产品定义才算精准呢？我们认为它包含以下几个方面： <strong>第一，用户群精准； 第二，对用户群需求和人性的把握精准； 第三，功能设定精准； 第四，直指产业级痛点； 第五，品质把握精准； 第六，产品的定价精准； 第七，将企业的商业模式、战略，精妙地寓于产品之中，是最高境界的精准。</strong></p>\n<p>很多人都认为大市场肯定很难做，而小市场则相对好做些。其实并非如此。从人才角度来讲，大众市场由于吸引了各色人等的进入，其实人才的平均水平反而更低，也就是说竞争反而没有想象中的激烈，只要你做得好一点儿，就能脱颖而出。而通常大家认为的小众市场中，聚集了大量的极客和高手，人才的平均水平很高，你要切入这些市场反而难上加难。</p>\n<p>消费者的需求的确是多样化、个性化的，是离散的，对于人性的把握似乎非常难。曾经有一个兄弟来问德哥，说通过做用户调研发现了几百个的用户痛点，不知道怎么做选择。德哥说，其实很简单，<strong>当你用“80%用户的80%需求”这条标准去筛选时，你会发现几百个痛点中能够留下来的就只有少数几个了，一切就变得简单了。</strong></p>\n<p><strong>在大众市场之中，不要回避核心需求。要坚定不移地解决80%用户的80%需求。</strong></p>\n<p>我们选择投资领域，一定要存在不足和痛点。痛点程度越深、出现频次越高，解决这些问题带来的产品势能就会越大。</p>\n<p>高品质产品要么提高效率，要么带来更好的用户体验</p>\n<p>信任问题是个大问题，没有基本的信任，就谈不上客户忠诚度。</p>\n<p>最高境界的精准定义产品，是将企业的商业模式、战略，精妙地寓于产品之中，这就是我们所说的要跳出产品本身来看产品。</p>\n<p>专利是我们长期竞争的武器，短期之内还是要靠市场手段。1999元的零售价格一出，就可以达到独步天下的状态，其他品牌的产品根本无法与我们竞争。我们内部称为“净空”，这种方式使得我们在产品投放的市场中不会受到太多干扰，接下来就可以专心做其他布局。</p>\n","categories":["read"],"tags":["note"]},{"title":"设计模式大白话","url":"/2020/08/05/softwareengineering/design-patterns-in-myself-word/","content":"<p>设计模式是对日常编程方法的总结。它包含了多种优化代码的方式。使用设计模式，可以让代码逻辑更加清晰，更多情况下是在不改变或少改变现有代码的情况下使用。<br>而如果没有足够多的编写代码的经验，没有遇到足够多的问题，对设计模式常常是理解不了的。本篇文章就试着从我自己写代码的一些感受中，用自己的话把设计模式的精髓说出来。</p>\n<a id=\"more\"></a>\n<h2 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h2><h3 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h3><blockquote>\n<p>在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</p>\n</blockquote>\n<p>我们常常会遇到这样的问题：</p>\n<ol>\n<li>需要提供一组相似的类，完成相似的功能</li>\n<li>现有代码中已有一个类，需要添加类似的类，实现不同情况下相似的功能</li>\n</ol>\n<p>需要注意的是，常常遇到的是第二种情况。现有的代码已经在运行，怎样在不对代码大量改动的情况下，实现上述目标？</p>\n<p>答案就是使用工厂方法模式。假如你再创建一个新的类，而使用这个新类完成之前的功能，又要许多配套的代码，这对代码的修改无疑是巨大的。使用工厂方法模式，在实例化类的时候传入条件，根据条件返回对应的对象。而这些对象应该具有相同的接口，因此后面使用这个对象的代码不需要改动，即可完成不同的功能。</p>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><blockquote>\n<p>它能创建一系列相关的对象， 而无需指定其具体类。</p>\n</blockquote>\n<p>直接看上面的解释，不知所云。</p>\n<p>我的理解是抽象工厂是生产工厂的工厂。比如，一个工厂生产各类现代化风格的家具，包含桌子、椅子、沙发等，另一个工厂生产维多利亚风格的家具，也有相同品类的产品，其他工厂则生产其他风格的相同品类的家具。而抽象工厂可以根据条件返回生产不同风格家具的工厂实例，这些工厂实例具有相同的接口，后续使用这个工厂的代码不用修改即可支持生产不同风格家具的功能。</p>\n<p>一个小提醒，每种家具品类需要基于相同接口来实现，每种风格也需要提供相同接口，一个具体的家具品类和一个具体的风格相结合，即可产出一种生产具体风格的家具工厂。</p>\n<h3 id=\"生成器模式\"><a href=\"#生成器模式\" class=\"headerlink\" title=\"生成器模式\"></a>生成器模式</h3><blockquote>\n<p>分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。</p>\n</blockquote>\n<p>在构造一个复杂对象的时候，如果不用生成器模式，我们有两种选择：</p>\n<ol>\n<li>扩展基类，然后创建一系列涵盖所有功能组合的子类。 但最终你将面对相当数量的子类。任何新增的功能都会让这些子类数量增加不少。</li>\n<li>无需生成子类。你可以在基类中创建一个包括所有可能参数的超级构造函数，并用它来控制对象。这种方法确实可以避免生成子类，但它却会使你面对一个庞大的配置对象。</li>\n</ol>\n<p>好了，使用生成器模式，你可以分步骤地按条件定制你需要的对象。这个模式的主要思想是将一个复杂对象的构建过程拆分成一系列可配置的步骤分开进行。</p>\n<p>由于是分别运行各个步骤，你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤，这在创建<strong>对象树</strong>时非常方便。生成器在执行制造步骤时，不能对外发布未完成的产品。这可以避免客户端代码获取到不完整结果对象的情况。</p>\n<h2 id=\"行为模式\"><a href=\"#行为模式\" class=\"headerlink\" title=\"行为模式\"></a>行为模式</h2><h3 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h3><blockquote>\n<p>责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>\n</blockquote>\n<p>责任链模式包含很多执行者，每个执行者是链条中的一环。一个请求按照顺序从每个执行者手中经过，根据执行结果传递给下一个执行者或者直接返回。（KOA框架的洋葱圈模型就是这种模式的运用）</p>\n<h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><blockquote>\n<p>命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>\n</blockquote>\n<p>假如你在开发一款编辑器，用按钮来执行相应的动作。当按钮越来越多，或者需要用菜单完成相同的动作时，代码就会出现杂乱和重复的现象。<strong>优秀的软件设计通常会将关注点进行分离， 而这往往会导致软件的分层。</strong> 命令模式在应对这种情况时，需要创建一个命令类，命令触发者将一个命令请求的所有细节包装成一个命令包进行传递，命令类收到这个命令包后，放入命令队列，再根据命令细节执行相应动作。</p>\n<p>一个很好的现实世界的例子：在市中心逛了很久的街后，你找到了一家不错的餐厅，坐在了临窗的座位上。一名友善的服务员走近你，迅速记下你点的食物，写在一张纸上。服务员来到厨房，把订单贴在墙上。过了一段时间，厨师拿到了订单，他根据订单来准备食物。厨师将做好的食物和订单一起放在托盘上。服务员看到托盘后对订单进行检查，确保所有食物都是你要的，然后将食物放到了你的桌上。</p>\n<p>那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 命令中包含与烹饪这些食物相关的所有信息。 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。</p>\n<h3 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h3><blockquote>\n<p>迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>\n</blockquote>\n<p>这种模式其实就是在某种数据结构上再封装一层，提供提供了通用的访问接口。不管封装对象后面使用的是什么结构或方法，只要每个对象保证响应“下一个”指令时，返回正确的数据即可。</p>\n<h3 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h3><blockquote>\n<p>中介者模式是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p>\n</blockquote>\n<p>一个现实中例子非常好：飞行器驾驶员们在靠近或离开空中管制区域时不会直接相互交流。但他们会与飞机跑道附近，塔台中的空管员通话。如果没有空管员，驾驶员就需要留意机场附近的所有飞机，并与数十位飞行员组成的委员会讨论降落顺序。 那恐怕会让飞机坠毁的统计数据一飞冲天吧。塔台无需管制飞行全程，只需在航站区加强管控即可，因为该区域的决策参与者数量对于飞行员来说实在太多了。</p>\n<p>中介者模式本质就是将复杂关系的管理抽离出来，由一个中介者统一管理。主要用于一些对象相互交错的关系比较复杂的情况。涉及到的对象需要提供一个通用的接口，中介者也可以提供一个通用的接口。所有对象通过通用接口与中介者通信，中介者根据情况调用指定对象进行相应动作。而只要实现了相应接口，其中任何一个对象甚至是中介者都可以进行替换或分别维护。</p>\n<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><blockquote>\n<p>观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>\n</blockquote>\n<p>这种模式也称为“发布-订阅模式”，该模式中含有<strong>发布者</strong>和<strong>订阅者</strong>两种角色，发布者提供了<code>注册</code>、<code>通知</code>、<code>取消注册</code>等动作。订阅者可以向发布者注册，发布者维护一个列表，该列表记录了所有订阅者，在某件事情发生时，发布者会根据订阅列表，逐个通知订阅者。订阅者还可以取消注册。</p>\n<h3 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h3><blockquote>\n<p>状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p>\n</blockquote>\n<p>这种模式的使用常见于以下场景：假如你有一个 文档<code>Document</code>类。 文档可能会处于 <code>草稿Draft</code> 、 ​ <code>审阅中Moderation</code>和 <code>已发布Published</code>三种状态中的一种。 文档的 publish发布方法在不同状态下的行为略有不同：</p>\n<ul>\n<li>处于 <code>草稿</code>状态时， 它会将文档转移到审阅中状态。</li>\n<li>处于 <code>审阅中</code>状态时， 如果当前用户是管理员， 它会公开发布文档。</li>\n<li>处于 <code>已发布</code>状态时， 它不会进行任何操作。</li>\n</ul>\n<p>你当然可以用判断语句解决这个问题。但是如果这种状态或者依赖状态的行为越来越多时，基于判断的语句将难以维护。<strong>状态模式</strong> 建议为对象所有可能的状态各建立一个类，并且将所有状态的行为抽取到这个类中。原始对象被称为<em>上下文</em> ，它并不会自行实现所有行为，而是会保存一个指向当前状态对象的引用，且将所有与状态相关的工作委派给该对象。状态切换时，原始对象指向的状态对象也会切换。</p>\n<p>这种模式的好处就是将每种状态的行为集中管理。添加状态时，再新建一个状态对象即可。添加行为时，需要为所有相应的状态对象添加行为（为避免每添加一个行为需要修改所有的状态对象，可以为状态对象添加一个<code>缺失行为</code>时的方法，在找不到相应行为时执行这个方法）。</p>\n<h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><blockquote>\n<p>策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p>\n</blockquote>\n<p>这种模式比较简单，简单来说就是你要做多个事情，而这些事情中大部分是相同的，只有一部分是不同的，而不同的部分可以根据策略进行切换。这时你就可以把不同的部分抽离出来，但需要遵循相同的接口，在策略切换时直接切换调用不同的方法即可。</p>\n<p>这样在后期修改或添加时，只操作对应的策略方法就可以，而不必修改整个程序。</p>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9yZWZhY3RvcmluZ2d1cnUuY24v\">设计模式<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n","categories":["SoftwareEngineering"],"tags":["SoftwareEngineering"]},{"title":"软件架构入门","url":"/2016/09/08/softwareengineering/software-architecture/","content":"<p>软件架构（software architecture）就是软件的基本结构。合适的架构是软件成功的最重要因素之一。大型软件公司通常有专门的架构师职位（architect），只有资深程序员才可以担任。<br><a id=\"more\"></a></p>\n<p>O&#39;Reilly 出版过一本免费的小册子<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cub3JlaWxseS5jb20vbGlicmFyeS92aWV3L3NvZnR3YXJlLWFyY2hpdGVjdHVyZS1wYXR0ZXJucy85NzgxNDkxOTcxNDM3L3ByZWZhY2UwMS5odG1s\">《Software Architecture Patterns》<i class=\"fa fa-external-link-alt\"></i></span>， 介绍了五种最常见的软件架构，是非常好的入门读物。我读后受益匪浅，下面就是我的笔记。<br><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090301.png\" alt=\"\"></p>\n<h2 id=\"一、分层架构\"><a href=\"#一、分层架构\" class=\"headerlink\" title=\"一、分层架构\"></a>一、分层架构</h2><p>分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。如果你不知道要用什么架构，那就用它。</p>\n<p>这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。</p>\n<p>虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。<br><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090302.png\" alt=\"\"></p>\n<ul>\n<li>表现层（presentation）：用户界面，负责视觉和用户互动</li>\n<li>业务层（business）：实现业务逻辑</li>\n<li>持久层（persistence）：提供数据，SQL 语句就放在这一层</li>\n<li>数据库（database） ：保存数据</li>\n</ul>\n<p>有的软件在逻辑层和持久层之间，加了一个服务层（service），提供不同业务逻辑需要的一些通用接口。</p>\n<p>用户的请求将依次通过这四层的处理，不能跳过其中任何一层。<br><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090303.png\" alt=\"\"></p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>结构简单，容易理解和开发</li>\n<li>不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构</li>\n<li>每一层都可以独立测试，其他层的接口通过模拟解决</li>\n</ul>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时</li>\n<li>部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布</li>\n<li>软件升级时，可能需要整个服务暂停</li>\n<li>扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难</li>\n</ul>\n<h2 id=\"二、事件驱动架构\"><a href=\"#二、事件驱动架构\" class=\"headerlink\" title=\"二、事件驱动架构\"></a>二、事件驱动架构</h2><p>事件（event）是状态发生变化时，软件发出的通知。</p>\n<p>事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。<br><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090304.png\" alt=\"\"></p>\n<ul>\n<li>事件队列（event queue）：接收事件的入口</li>\n<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>\n<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>\n<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>\n</ul>\n<p>对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。</p>\n<p><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090305.png\" alt=\"\"></p>\n<h3 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好</li>\n<li>适用性广，各种类型的项目都可以用</li>\n<li>性能较好，因为事件的异步本质，软件不易产生堵塞</li>\n<li>事件处理器可以独立地加载和卸载，容易部署</li>\n</ul>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂</li>\n<li>难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚</li>\n<li>分布式和异步特性导致这个架构较难测试</li>\n</ul>\n<h2 id=\"三、微核架构\"><a href=\"#三、微核架构\" class=\"headerlink\" title=\"三、微核架构\"></a>三、微核架构</h2><p>微核架构（microkernel architecture）又称为&quot;插件架构&quot;（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。</p>\n<p>内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。<br><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090306.png\" alt=\"\"></p>\n<h3 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可</li>\n<li>功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，</li>\n<li>可定制性高，适应不同的开发需要</li>\n<li>可以渐进式地开发，逐步增加功能</li>\n</ul>\n<h3 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式</li>\n<li>开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制</li>\n</ul>\n<h2 id=\"四、微服务架构\"><a href=\"#四、微服务架构\" class=\"headerlink\" title=\"四、微服务架构\"></a>四、微服务架构</h2><p>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。</p>\n<p>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。<br><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090307.png\" alt=\"\"></p>\n<p>微服务架构分成三种实现模式。</p>\n<ul>\n<li>RESTful API 模式：服务通过 API 提供，云服务就属于这一类</li>\n<li>RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部</li>\n<li>集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群</li>\n</ul>\n<h3 id=\"优点-3\"><a href=\"#优点-3\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>扩展性好，各个服务之间低耦合</li>\n<li>容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元</li>\n<li>容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级</li>\n</ul>\n<h3 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。</li>\n<li>一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。</li>\n<li>分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。</li>\n</ul>\n<h2 id=\"五、云架构\"><a href=\"#五、云架构\" class=\"headerlink\" title=\"五、云架构\"></a>五、云架构</h2><p>云架构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。</p>\n<p>它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。</p>\n<p>这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。</p>\n<ul>\n<li>处理单元：实现业务逻辑</li>\n<li>虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。</li>\n</ul>\n<p><img data-src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016090311.png\" alt=\"\"></p>\n<p>虚拟中间件又包含四个组件。</p>\n<ul>\n<li>消息中间件（Messaging Grid）：管理用户请求和session，当一个请求进来以后，决定分配给哪一个处理单元。</li>\n<li>数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。</li>\n<li>处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元</li>\n<li>部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。</li>\n</ul>\n<h3 id=\"优点-4\"><a href=\"#优点-4\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>高负载，高扩展性</li>\n<li>动态部署</li>\n</ul>\n<h3 id=\"缺点-4\"><a href=\"#缺点-4\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>实现复杂，成本较高</li>\n<li>主要适合网站类应用，不合适大量数据吞吐的大型数据库应用</li>\n<li>较难测试</li>\n</ul>\n<h2 id=\"（完）\"><a href=\"#（完）\" class=\"headerlink\" title=\"（完）\"></a>（完）</h2>","categories":["SoftwareEngineering"],"tags":["SoftwareEngineering","Architecture"]},{"title":"超越免费（上）","url":"/2017/12/17/thinking/google-methodology-20171217/","content":"<p>今天是我们第二季专栏的第四周，在前几周里，我会把这一季四种主题的内容分别刊登一两周，这样你会对全年的内容有真实的感受。<br><a id=\"more\"></a><br>这一周我们会围绕工作方法和商业本质展开。</p>\n<p>免费这件事情在个人电脑出现之后，其实就很难避免了，因为只要有了可以迅速大量“写”信息的设备，比如早期的磁盘机，后来的激光盘读写机，以及再后来的互联网，大众可以不借助第三方盗版厂家，自行获得免费信息、软件、和音视频内容。</p>\n<p>一开始的时候，微软等公司还在中国打击盗版，那时，微软的 CEO 鲍尔默每年要到中国一两次，解决这个问题。</p>\n<p>但是到后来他干脆带有戏谑和苦涩的口吻说，如果你们要盗版，能否盗正版。言外之意，不如问我要正版软件，不要再去市场上找那些感染了病毒的各种盗版了。</p>\n<p>这时，很多 IT 产品和文化创意产品就不可避免地开始免费了。</p>\n<p>到了互联网时代，雅虎的杨致远和费罗首创了免费的互联网服务，并且找到了广告这种商业模式，这才让互联网成为一个开放、免费的工具。</p>\n<p>因此，我在《浪潮之巅》一书中讲，再过几十年大家回顾互联网发展史的时候会发现，<strong>杨致远和费罗英名不朽，因为他们确定了互联网的格局。</strong></p>\n<p>与此同时，一直希望大家来买软件的微软居然用免费的方式在浏览器市场上打败了当时一家独大的网景公司（Netscape），一时之间，免费成了趋势。如果你仔细想想互联网传播的本质，其实它就是起到了一个巨大的复印件的作用。</p>\n<p>免费带来的一个结果是迅速形成垄断。Google，Facebook 和阿里巴巴就是这样的经典样板。至于为什么有些公司通过免费发展起来了，大部分公司采用同样的商业模式，甚至技术水平也不算差，却很快死掉了。从根本上讲，是后者提供的东西没有用。</p>\n<p>我在《见识》一书中介绍 Google 联合创始人拉里∙佩奇的智慧时讲，<strong>提供有用的信息是根本，重点落在“有用”二字上，而不是信息上。</strong></p>\n<p>然而，免费模式在让很多消费者享受到不要钱的服务之后，也让商家的收入大幅减少，甚至让一些国家和地区的经济陷入缓慢发展的阶段。</p>\n<p>今天全球互联网产业的收入不过3800亿美元（2016年），对于阿里巴巴这样的公司，只考虑它收取的费用，不算平台商家的流水。</p>\n<p>你可能会说，3800亿美元是两万多亿人民币呢，不少了。但是这要看和谁比，电信运营商和设备商（包括苹果公司）同期的收入可是高达3.5万亿美元。</p>\n<p>即便是在这3800亿美元中，Google 一家就占了近1000亿，去掉了1/4，接下来的亚马逊、阿里巴巴、Facebook 和腾讯这四家又占掉了1000亿，你如果再把第二梯队的加进去，基本上就没有剩什么了。</p>\n<p>这就是很多互联网公司坚持不了一两年就死掉的根本原因。</p>\n<p>也就是说免费看似给了小公司进入市场的可能性，其实却让小公司根本发展不起来。</p>\n<p>因此，今天还试图打着免费旗号成为下一个 Google 或者阿里巴巴的创业者，就必须反思了。法国人讲，第一个把女人比作鲜花的是天才，第二个是庸才，第三个就是蠢才了。</p>\n<p>回顾过去的一年，你在共享单车市场上，看到的大量是庸才和蠢才，这里面更多地集中在给那些庸才投资的人。</p>\n<p>今天，我们其实到了一个<strong>超越免费</strong>的时代。那么怎么才能超越免费呢？很多人想，既然价格是零都没法做生意，我倒贴钱是否可以。答案是否定的，有些创业者还真这么做了，但是到目前为止还没有成功的。</p>\n<p>从2004到2010年，微软花了大力气试图在搜索上和 Google 竞争，当时它的现金储备比 Google 多好几倍，因此它采用倒贴钱的方式鼓励大家使用它的搜索服务，大约每搜索一次可以获得五美分（三毛钱人民币）的变相奖励（变成积分买东西）。但是那样除了每年烧掉10几亿美元的市场推广费之外，对市场占有率的提升没有帮助。</p>\n<p>这其中的根本原因不在于5美分不足以吸引人，而是人对于将要失去的钱财特别在意，对白得来的东西并不珍惜。关于这一点我在上一季的第350封信《卡尼曼的经济学课：为什么散户总是犯错误》中专门做了阐述。</p>\n<p>因此，<strong>超越免费不是变本加厉地倒贴，而是要找到免费能够成功的逻辑，然后超越那个逻辑。</strong></p>\n<p><strong>免费之所以能够成功，是因为过去一些东西有稀缺性，不得不购买，这时免费就变得特别吸引人。当那些东西不再有稀缺性时，再免费就没有意义了。</strong></p>\n<p>为了加深你的感受，我和你讲两个我身边的例子。</p>\n<p>大约十多年前，我接待约翰∙霍普金斯大学计算机系的系主任参观 Google，他看到那么多免费的饮料和零食，问是否会有员工将它们拿回家，我说一些新员工（无论是校招的，还是社招的）刚来的时候会拿一点，但是用不了一两个月就不再拿了，因为随时想吃喝都能得到，没必要放到自己那里。</p>\n<p>他对我讲，在大学里，只要有一点免费的零食饮料，大家都是一扫而光。我说，那些东西在你那里有稀缺性，在我们这里没有，没有了稀缺性，免费的东西就不再吸引人了。</p>\n<p>第二个例子是德国同事给我讲的东德统一前后的情景。</p>\n<p>过去在东德，香蕉是非常稀缺的水果，因为那里远离热带地区，而东德的贸易又不发达，因此一旦商店里有了香蕉卖，当地居民就抢购回家。</p>\n<p>等到德国统一后，商店里就出现了大量的香蕉，于是居民就将它们一扫而光。</p>\n<p>第二天大家到商店里一看，又上架了许多香蕉，于是再次一扫而光，但是等到第三天，第四天香蕉依然摆满了货架，这时就没有人再抢购了。</p>\n<p>因此，超越免费的第一条是制造一种稀缺性，而这需要产品、服务本身具有一种难以复制的特性。</p>\n<p>最近是苹果新手机上架的季节，美国和中国照例有人排长队购买 iPhone X，这就是稀缺性带来的结果。</p>\n<p>当然，稀缺性的前提是与众不同。同样是苹果公司几个月前推出的 iPhone 8 手机，就没有人要，因为它无论是和自己过去的 iPhone7 相比，还是横向和华为的手机相比，都没有什么特点。</p>\n<p>如果你把市场上各种外观像苹果手机的小品牌仿制品当作廉价的复制，那么苹果 iPhone8 并不比那些复制品更吸引人。相比之下，iPhone X 的特点就明显很多。</p>\n<p><strong>制造稀缺性这一点其实在个人成长和工作中比销售产品用处更大。</strong></p>\n<p>今天不仅是商品过剩的年代，也是人才过剩的时期。</p>\n<p>也就是说，每一个岗位的求职者所拥有的技能，相比它所需要的，是绰绰有余，以至于博士生只能做硕士生的工作，硕士生做本科生的，而一些本科生则找不到工作。</p>\n<p>在美国，情况也是一样。很多学金融、法律和传媒的毕业生，要先免费给华尔街、律师事务所和好莱坞做实习生。</p>\n<p>这等同于货物太多、消费者太宝贵，只好免费提供服务。这和互联网时代很多服务，甚至硬件产品都是免费的还没有人要，道理是相通的。</p>\n<p>在很多行业里，虽然大家干活还是要付钱，但只是辛辛苦苦挣一份糊口钱罢了。要想超越廉价（免费），第一条就是把自己变成一个稀缺的人才。至于怎么做到这一点，我们这一年里会慢慢讲。今天你先记住“<strong>稀缺性</strong>”这三个字。</p>\n<p><strong>超越免费的另外五个有效的办法是在时效性、个性化、可用性（易理解性）、可靠性和数据黏性上下功夫。</strong></p>\n<p>这些我们明后天再讲。</p>\n<p>祝冬安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"超越免费（中）","url":"/2017/12/18/thinking/google-methodology-20171218/","content":"<p>昨天我们讲了今天时代的一个特点，就是免费品特别多，但是这条路似乎已经走到了头。<br><a id=\"more\"></a></p>\n<p>类似地，人也不可避免地成为了免费品或者说廉价的劳动力，即便这样，也未必有人要。</p>\n<p>今天，很多人会和我讲，“我（或者让我的孩子）免费帮你做事情吧”，我说“谢谢了，可是我并没有那么多的事情要别人做啊”。</p>\n<p>在未来，<strong>超越免费</strong>不仅是我们做生意的原则，也是我们做人，自我成长所必须注意的地方。</p>\n<p>接着昨天的话题，今天先聊聊通过时效性来超越免费。</p>\n<p>设想这样一个场景，给你两个观看你所热衷的体育比赛的选择：</p>\n<p>第一个，看实况转播，但是要交50元钱。</p>\n<p>第二个，赛后两天看重播，那时你已经知道结果了。</p>\n<p>在这种情况下，大部分人选择第一种。</p>\n<p>当然你可能会说，不对，如果要交50块钱才能看直播大部分人就不看了。</p>\n<p>并非如此，你看那些人大早上不上班看奥运会开幕式，或者大半夜爬起来看世界杯的，其实都是变相交了钱。</p>\n<p>不上班看转播，其实是以损失自己在职业上的收益为代价的，不睡觉看球，身体的损失可不止50块钱。</p>\n<p>我们算账不仅要算看得见的金钱账，还要算潜在的经济得失，只会算前一种账的人，一辈子不会有什么大出息。</p>\n<p>好了，既然要花钱看直播，而不是几天后在休息的时候看重播，说明直播有重播不可替代的地方，就是它的时效性。</p>\n<p><strong>当复制可以让大家获得免费的东西时，不可复制的东西才能值钱，才能从根本上超越免费，而具有时效性的东西天然具有这个特点。</strong></p>\n<p>在美国，很多人排队去看大片的首映或者前几场，主要是出于时效性的考虑。</p>\n<p>孩子在学校里听同学们谈最近的电影，而自己插不上嘴，是一件颇为丢脸的事情，因此很多中上家庭的老爸会带着孩子看第一天或者第二天的电影。</p>\n<p>我在 Google 时，公司也总是在首映的当天包下影院的一些场次。</p>\n<p>类似地，在头几天排队买苹果手机的人，也是出于时效性的考虑。</p>\n<p>如果说看电影，买手机还多少有点出于面子的考虑，买一些知识产品，先获得者比后获得者多少有一点竞争上的优势。</p>\n<p>在美国，新书上架的次序是：精装本、平价书、电子书。精装本里面的内容并不比后两种更多，但价格却高不少。</p>\n<p>虽然后者的销量更大，但是一本图书大部分利润来自于前者。</p>\n<p>此外，几个月后，各个社区图书馆都会上架，给大家免费借阅。</p>\n<p>也就是说，只要你有耐心等，最终可以获得免费的阅读。</p>\n<p>但是，很多人要及早买，因为及早得知里面的内容后，可以让自己在某些地方变得更主动。<br>类似地，罗辑思维卖书是很成功的，它的做法和美国书商没有什么不同，你如果通过它购买要多付些钱，但是却在时效上赚了便宜。</p>\n<p>这一点看似简单，但是别人还真的很难学，国内几家公司都试图学，都成为画虎类犬，原因我后面会分析。</p>\n<p>对于软件，有些具有时效性，有些则没有。</p>\n<p>比如操作系统就具有时效性，而应用软件相应的时效性就较差。</p>\n<p>90年代初，美国一个投资人给我在清华的课题组和中国电子器件公司（今天中国电子集团的前身）投资将语音识别技术在 PC 机上产品化。</p>\n<p>当时 Windows 刚出来，美国的投资人让我们买十套，当时一套要近千块人民币。</p>\n<p>我们讲花那个冤枉钱干什么，用不了两个月，中关村就有盗版的了。</p>\n<p>那个美国人讲，<strong>一流的公司在微软开发 Windows 时，就已经合作了，他们所有的开发都建立在 Windows 系统之上。二流的公司在微软一推出 Windows 时，赶紧买它，将所有的开发转到 Windows 上。三流的公司才等着盗版系统出来，等开发完产品，市场早就没有了。</strong></p>\n<p>不仅商品和服务有时效性，人的技能也是如此。</p>\n<p>当满大街都是某种技能的培训时，这种技能的时效性早就过去了。</p>\n<p>上个世纪60年代时，只要你会写计算机程序，生活比一个公司老板都不差，但是到今天，这些人被谑称为码农了。</p>\n<p>吴恩达在 MOOC 上开人工智能课程，有15万人听。波内（Dan Boneh）开区块链的课程，有多达100万人听。</p>\n<p>为什么会这么热门，因为很多 IT 从业者知道，这种技能的时效性很强，等到大批年轻的毕业生走出学校时，这种技能的价值就没有了。</p>\n<p>也就是说，想要通过时效性挣钱，就得抓住头几年的时间，这就如同精装书挣钱一样。</p>\n<p>了解了时效性，你可能也体会了终身学习的重要性，因为这样总是可以领先同辈人一步，让自己成为具有时效性的人才，而不是廉价的人。</p>\n<p>超越免费的第三个办法是<strong>个性化</strong>。</p>\n<p><strong>个性化的东西，显然无法复制，无法复制的，自然也就不可能免费。</strong></p>\n<p>怎样做到个性化呢？有的衬衫厂家提供印上个人名字的服务，这种个性化没有意义，不仅可以复制，而且不带来太多的价值，它不可能让衬衫避免价格战。</p>\n<p>类似地，有人将图书上印上消费者的名字，以彰显不同，这对图书的销售恐怕帮助也不会大。</p>\n<p>要买图书的人不会因为书封面印上了名字，就从不购买，变成了购买，反过来，如果想买，也不会在意是否做了个性化的处理。</p>\n<p>你如果注意一下二手书的市场，经常有作者送给某个人的书，不仅作者签了名，还写上了受赠者的名字，但是受赠者还是将书送到旧货站了。</p>\n<p>曾经有一位名人，在二手市场发现某作家送他的书，要价好几百块钱，因为上面有双方的名字，所以特别值钱。</p>\n<p>他实在记不起自己哪次卖给了收破烂的人，因为害怕对方知道了和自己翻脸，只好花几百块钱把当年一块多钱的书买回来。个性化做到这个份上，你恐怕会觉得走样了。</p>\n<p>什么是真正有价值无法复制的个性化呢？</p>\n<p>我们不妨看一个比较极端一点的例子，个性化医疗。</p>\n<p>今天对大部分癌症患者的治疗都是非常个性化的，不是找医生开了药，去药房拿了回去吃就可以了。</p>\n<p>今天的靶向治疗，要先测试患者的基因和肿瘤的基因，看看哪些药物（主要是通过干扰肿瘤生长所需的特定分子来阻止癌细胞增长）对他身上的癌细胞有作用，这其实是非常个性化的事情了，而在治疗期间，还需要根据患者身体变化不断作出调整。</p>\n<p>这种服务显然不可复制。今天我们使用的药物所有人都是一样的，在未来，不同人使用的感冒药可能都和自己的基因有关，这样的药当然不可复制，也就不可能免费了。</p>\n<p>讲回到为什么罗辑思维卖书卖得好，这并非罗胖吆喝一嗓子书就卖掉了，中国名气比他大的人多的是，也没见到谁吆喝一嗓子卖掉多少书。</p>\n<p>罗辑思维最大的特点是个性化做得好。简单地讲就是出版社和网店都不知道谁想读什么书，而罗辑思维经过长期的积累，多少了解了一些。</p>\n<p>事实上，罗辑思维每一本书的销量恐怕到不了它用户数量的5%，但是它大致知道这5%的人在哪里。</p>\n<p>这就等于是在给那些人提供个性化的内容。相比在书上印上自己的名字，内容更适合自己，哪一种情况是真正的个性化，应该是不言而喻的。当然罗辑思维难以复制还有第二个原因，我们明天再讲。</p>\n<p>在个性化方面做得非常好的公司还有特斯拉。</p>\n<p>特斯拉的每一辆车都是个性化的，因为是大家自己配置的，关于这一点我在《见识》第一章介绍众筹经济时有详细介绍。</p>\n<p>相比特斯拉，其它汽车厂家和经销商都是根据未必准确的预测设计生产和备货。</p>\n<p>事实上，即便一个经销商为某款车准备了100种颜色和配置的搭配组合，顾客也未必能遇到自己想要的车，因为对车的选择实在是一件非常个性化的事情。</p>\n<p>更糟糕的是，大部分经销商为了迎合大众的口味，一般只敢进“最保险”的颜色搭配和配置组合，而那些车恰恰失去了个性化，到了年底都要降价出售。</p>\n<p>本田下属的讴歌公司原本也和其它车一样，并没有考虑个性化的需求，结果它极致的超级跑车 NSX 卖得并不好。于是，讴歌公司宣布，从2018年开始，它只做定制的跑车了。</p>\n<p>这也说明在未来，个性化将成为厂家走出免费困境的一条道路。</p>\n<p>随着智能时代的到来，在中低端消费品上，也能够实现个性化需求，那时没有了拷贝，也就不用担心免费了。</p>\n<p>至于如何将服务做到个性化，我们以后再讲。</p>\n<p>最后，我们讲讲人的个性化。</p>\n<p>我一直强调，要做一个有趣的人，这个有趣，就是个性化。每一个人只有成为了有趣的人，有大家所喜欢的个性的人，大家才能喜欢你。</p>\n<p>否则，一个人如果没有特点，从全世界70亿人中随便拎出一个就和他一样，可以替代他，你又怎么可能觉得他重要呢？</p>\n<p>好，今天就先和你聊到这，我们明天继续。</p>\n<p>祝顺利！</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"超越免费（下）","url":"/2017/12/19/thinking/google-methodology-20171219/","content":"<p>今天继续昨天的话题，聊一聊在当下免费商品和服务泛滥，商家挣不到钱，以及消费者无从选择的时代，我们如何立于不败之地。<br><a id=\"more\"></a><br><strong>超越免费的第四个绝招是提供可用性（易理解性）的产品和服务。</strong></p>\n<p>怎样理解可用性呢？我们不妨看这样四个例子。</p>\n<p>第一个例子是罗胖讲的，说他在大学时跑到图书馆，借了很多西方经典名著（非文学类的，比如维特根斯坦，黑格尔的书）回去读。都没有读下去，因为真的读不懂。</p>\n<p>这里面可能有两个原因，一是西方人在几百年前写的东西，时代背景和社会背景和中国完全不同，不好理解，另一个原因是很多学者型译者翻译出来的书也确实没有打算让大众读懂。</p>\n<p>虽然那些书都是免费的，但我估计不会有什么市场，因为根据我的经验，在清华，康德、黑格尔或者休谟的书放在图书馆的架子上几乎没有人碰。</p>\n<p>但是，如果有人把黑格尔的书给你讲懂，而你恰巧也需要了解他的哲学思想，那么你就会愿意掏钱。</p>\n<p>第二个例子是我过去给一些杂志审稿时的经验。</p>\n<p>有些学者的论文真的读不懂，但是依然有价值。于是就有其他学者将那种论文重写一遍，大家都在读那些重写的论文，而不是原文，这一类复述性的论文也经常发表。</p>\n<p>事实上，我自己做论文时要用到匈牙利数学家希斯沙（Csiszár ）的理论，他的论文真的没法读。</p>\n<p>为此我的导师库旦普教授专门开了一门课讲他的几篇论文，而我在写博士论文时花了大约5倍的篇幅将他的论文解释了一遍。</p>\n<p>后来库旦普教授的讲义和我的论文就成了机器学习领域很多入门者的读物，因为好懂。</p>\n<p>第三和第四个例子都是凯文∙凯利（KK）对我讲的。</p>\n<p>他说虽然开源操作系统 Linux 是免费的，但是提供 Linux 操作系统服务的 Red Hat 公司出的手册和教程却要卖1万美元。</p>\n<p>为什么呢？如果你不是系统专家，Linux 免费下载之后你根本装不上，就算装上了，很多设置也是不对的，就算设置对了，很多功能你也不会用。</p>\n<p>此外，凯文∙凯利还讲了一个很有趣的事情。</p>\n<p>在互联网普及之前，电视是最重要的传媒工具，而当时的美国，这个产业被三大电视网，即 NBC，ABC 和 CBS 控制着，那时也没有什么有线电视，因此电视节目大多是免费的，当然电视网靠广告挣钱。</p>\n<p>你以为它们这些近乎垄断的企业是电视行业里最挣钱的公司吗？</p>\n<p>错了，最挣钱的是编写电视收视指南的杂志，它每周出一本32开本的小册子在全美各大超市出售，你看电视之前如果没有这本小册子，根本不知道在上百个电视台中如何选择。</p>\n<p>说到这，你可能清楚了为什么提供可用性的产品和服务值钱，因为东西太多，太复杂，即使白给，你也用不好，而你又不得不用，于是只好向能够帮助你使用好的人付钱了。</p>\n<p>在今天中国的读书市场，你会发现一个有趣的现象，很多图书有盗版的音频版，在网络上很容易找到，但是它们的下载量并不大，因为那些书非常难读。</p>\n<p>而在得到 App 上，解读一本书要4.99元，还有很多人购买。</p>\n<p>在任何时代能够把事情解释清楚不仅是一个有用的本领，而且是一个很赚钱的生意。</p>\n<p>我们知道今天上法庭打官司常常需要律师出面帮忙，因为法律条文虽然可以免费得到，但是把它们说清楚可不容易。所以律师可以每小时几百，上千元地收钱。</p>\n<p><strong>超越免费的第五个绝招是提供可靠而易用的服务。</strong></p>\n<p>免费的东西固然好，但是如果不好用，那么必然有人宁可支付一些钱获得可靠的服务。</p>\n<p>20多年前我刚到美国时，一些即将毕业的学长们会将自己开了多年的 N 手车免费送给学弟学妹们，但是后者未必会要，因为一个三天两头坏的车带来的麻烦比解决的问题多得多。</p>\n<p>因此，大部分学生会选择花3000-5000美元买一辆二手的日本车，因为日本车的可靠性比较好。</p>\n<p>当然我知道今天可能没有人送给你汽车，但是你可以设想一下，如果有人免费送给你一个60寸的电视机，它三天两头坏，半年后你就会烦的，不仅没有用，还占了你家客厅不小的空间。对于那些经常看电视的人来讲，宁可花钱买一个可靠性高的电视。</p>\n<p>对于那些不占空间的免费服务，可能有些人觉得还是可以接受的，其实也不然。</p>\n<p>各国政府部门提供的服务一般都是免费的，其中包括很多公共事务，比如义务教育和公费医疗。</p>\n<p>但是相应的私营服务依然有市场，因为那些免费的服务未必可靠，即使能解决你的问题可能也很麻烦，而付费的服务在交了钱之后，提供的服务则是有保障的。</p>\n<p>在商业上，是否免费的服务一定比付费的服务更有优势呢？</p>\n<p>从短期看，前者对于一些人可能更有吸引力，但是，长期来看，可靠而易用的收费服务远比免费但质量无保障的服务更能锁定顾客。</p>\n<p>这主要是由人的生理特点决定的，人通常能忍受短期的痛苦，但难以长时间接受哪怕轻微的痛苦。</p>\n<p>比如对几乎所有人来讲，100米短跑虽然累，但是都能坚持下来，但是要让一个人跑3000米，很多人就觉得是负担了。</p>\n<p>在美国，几乎所有的服务提供商为了吸引新顾客都会提供一些特殊的优惠，甚至免掉开始几个月的服务费。因此，只要你愿意，可以在几家不同的服务商中换来换去，省去不少钱。</p>\n<p>对于这种现象你可能会想，如果所有顾客都这么做，服务商不是就赚不到钱了？</p>\n<p>事实上，这种担心没有必要，因为绝大部分顾客在换几次以后就会长期使用他喜欢的某一家的服务了。</p>\n<p>这一方面是因为换来换去的边际成本很高，不仅麻烦，而且在切换过程中经常出问题。</p>\n<p>另一方面，各家在一开始吸引新顾客时给的补贴，大致和边际成本相当。最后只要服务可靠很多人就会用下去，不再折腾了。</p>\n<p>这也是为什么第一个进入市场的公司能有巨大的先发优势的原因，也是为什么一些服务上乘的公司最后成为了“现金奶牛”的原因。</p>\n<p>当然，这一切的前提都是可靠，如果不可靠，生意是做一单少一单。</p>\n<p><strong>超越免费的第六个绝招是具有数据黏性的服务</strong>，这也是大数据时代的一个特点。</p>\n<p>在上面我们说到了切换的成本，在互联网和大数据时代，切换的成本有时远比想象的高得多，因为你不能像过去那样简单换一个服务，或者换一个产品就了事了，而是要携带着一大堆数据一起换。</p>\n<p>在使用固定电话的时代，你从中国电信换到中国联通成本是极低的，但是今天你把手机的服务商更换一下，就要考虑很多数据怎么办。</p>\n<p>类似地，过去家里的电话想怎么换就怎么换，即便是10年前，从摩托罗拉的手机换到诺基亚的，你都不用有任何数据方面的担心。</p>\n<p>但是今天你如果想从安卓手机换到苹果手机，就要三思了。</p>\n<p>这些就是由数据的黏性造成的。</p>\n<p>当然数据只是一个概念，在它的背后包含很多东西，包括你的社会关系。</p>\n<p>我在前面讲到要说说为什么得到的商业模式其它付费网站都没法儿模仿。接下来我们就用数据黏性来说说其中的一个重要原因。</p>\n<p>由于每个读者或者听众每天的时间有限，一个平台再大，他能够选择阅读和收听的内容是有限的。</p>\n<p>在全中国，靠版税能养活自己的作家也就是一、二百名，善于做解释性产品的人非常少。这样不论有多少平台，能开出来的节目非常有限。</p>\n<p>得到拿到了一大批善于做解释性产品的人，其它平台就没有了。当然很多人不是这么想的，他们觉得只要我有钱，就可以挖墙脚。</p>\n<p>但是，对于讲师们来讲，他们不可能一走了事，还得带上众多的听众，而听众的作用和数据是相同的，这就构成了一个平台的黏性。</p>\n<p>类似地，听众也不大可能一走了之，因为他们对讲师也有依赖性。</p>\n<p>我的基金在过去的三年里投资了上百家公司，覆盖了各行各业，如果说它们有什么相似的地方，就是大多能够不断积累数据，制造黏性，使得客户不会一夜之间迁移走。</p>\n<p>事实证明，越是善用数据黏性的公司，后来的发展越顺利。而开始靠免费拉用户，甚至花钱买用户的公司，常常后劲不足。如果你要创业，我建议你从一开始就注意数据的黏性。</p>\n<p>最后，总结一下这三天的内容，虽然今天很多商品和服务是免费的，但是我们做事情最终还是能超越免费，让自己获利。</p>\n<p>祝 顺利！</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"粗调和精调：从一道Google面试题谈起","url":"/2018/01/07/thinking/google-methodology-20180107/","content":"<p>做事情需要<strong>工程思维</strong>：很多时候我们先用低成本解决主要问题，然后再想办法把最后5%、10%做好。粗调提高效率，细调提高精度。在开发工作中也是一样，如果不是涉及架构层面的问题，可以先放在一边，集中精力把主要功能做全做好，然后再精雕细琢。工作中常常会忽略这样的做事规律，需要项目负责人从大局上把握。<br><a id=\"more\"></a></p>\n<p>这一周我们从几个顶级公司的面试题入手，谈谈Google、微软和高盛是如何遴选毕业生的，并且回顾一下在硅谷吸纳人才最成功的肖克利半导体的一些做法，从雇主的角度看我们所需要具有的的能力。</p>\n<p>回答这些问题并不需要计算机或者金融专业的知识，因此即使你是学文科的，也不用被这些题目吓着。</p>\n<p>今天先讲Google的一道面试题，它其实是考察候选人的工程思维，题目是这么说的：</p>\n<p>给你两个一模一样的玻璃球。这两个球如果从一定高度掉到地上就会摔碎，当然，如果在这个高度以下往下扔，怎么都不会碎，超过这个高度肯定就一次摔碎了。</p>\n<p>现在已知这个恰巧摔碎的高度范围在1层楼到100层楼之间。如何用最少的试验次数，用这两个玻璃球测试出玻璃球恰好摔碎的楼高。</p>\n<p>为了便于你理解这道题，我不妨讲两个具体的策略。</p>\n<p>第一个策略是从第一层楼开始，一层一层往上试验。 你拿着球跑到第一层，一摔，没有碎，接下来你又跑到第二层去试，也没有摔碎。你一层层试下去，比如说到了第59层摔碎了，那么你就知道它摔碎的高度是59层。这个策略能保证你获得成功，但显然不是很有效。</p>\n<p>第二个策略是预测一下，试一试， 你跑到30层楼一试，没有碎，再跑到80层楼一试，碎了。虽然你把摔碎高度的范围从1-100减小到30-80，但接下来你就犯难了，因为你就剩一个球了，再这样凭感觉做试验，可能两个球都摔碎了，也测不出想知道的高度。</p>\n<p>这道题好的方法是什么呢？两个球，一个用来做粗调，一个用来做精调，具体做法是以下这样的。</p>\n<p>首先拿第一个球到10层楼去试，如果没有摔碎，就去20层楼，每次增加10层楼。如果在某个十层摔碎了，比如60层，就知道摔碎的高度在51-60层之间，接下来从51层开始一层层地试验，这样可以保证不出二十次，一定能试出恰巧摔碎玻璃球的高度。</p>\n<p>数学好的读者朋友可以去证明一下这是从统计的角度讲最优的策略，为了照顾所有的读者，我就不占用时间证明了。</p>\n<p>这道题和计算机技术完全无关，和产品设计或者市场推广似乎也无关，那么为什么Google要考这道题？<strong>其实有两个目的， 一是为了找到聪明人，二是为了判断这个候选人的工程素养。</strong></p>\n<p>世界上顶级的公司在招人时都要强调一个人未来的可塑性，其中的一条就是要足够聪明便于培养，因此都会考一些看似智力题的问题。这个传统在IT行业，特别是在硅谷，源于诺贝尔奖获得者夏克利挑选人的思维方式。</p>\n<p>为什么可塑性比过去的经历重要呢？因为大部分公司招人是做未来的事情，而不是重复过去的事情，尤其是对于大学刚毕业的年轻人，过去在大学几年学的东西，和后来一辈子要不断学习的东西相比，实在少得可怜。</p>\n<p>因此， <strong>如果一个资质平庸、学习能力不强的学生在大学时多学了一点专业知识，比那些聪明好学，少学一两门专业课的人相比，后劲是不足的</strong>。</p>\n<p>不过，如果你今天再应聘这些顶级跨国公司，倒不必太担心被考这样的智力题，这要感谢美国的政治正确。一些左派人士讲，那些智力题有歧视倾向，因为它们让一些族裔的人显得不聪明，而政治正确要强调的是必须承认所有的族裔同等聪明。当然这是题外话。</p>\n<p>那么这道题考的是什么样的工程素养呢？就是今天标题所说的粗调和精调。如果我要问，有一个数字是40.365，比如说天文望远镜的焦距，你怎样达到它？</p>\n<p>一般人按照生活直觉，直奔这个数字去就可以了。但是在工程上，这样简单的一个数字并非抽象的，而是非常具体的。</p>\n<p>如果是天文望远镜的焦距，你是否会用手把握着望远镜的那个圆筒，前后移动，估摸着镜片之间的距离来调整呢？如果这是导弹发射的角度，你自己是否会用个量角器估算导弹和水平线的角度呢？</p>\n<p>显然我们不能这么做，我们必须有一个可以准确达到这个数字的办法，这就是<strong>工程的思维—— 不仅仅要知道目标在哪里，还必须设计一个能够达到目标的道路。</strong></p>\n<p>对于天文望远镜，设计它们的工程师必须设计一个能够转动的旋钮，让它的长度接近40.365这个数字。</p>\n<p>但是接下来的问题来了，如果这个旋钮每转动一圈，调整的幅度太大，要调到小数点后面三位几乎不可能。如果每转动一圈调整的幅度太小，比如每次调整0.001，那么可能要花很长时间才能调到40.365这个数。类似地，调整导弹的角度也是如此。</p>\n<p>那么工程师们是怎么做的呢？就是要设计各种<strong>粗调和精调</strong>的方法。</p>\n<p>在中国学习生物时用过光学显微镜的朋友，可能还会记得在显微镜上有两个旋钮， 第一个是粗调，让你大致看到图像，第二个是精调，能让你看清楚图像。</p>\n<p>如果不用粗调，只用精调，不仅做事的效率会很低，而且可能会因为一开始的范围找得不对，在花了半天时间后没有找到后，最后干脆放弃了尝试。</p>\n<p>我在《硅谷来信》中介绍过今天最先进的手术机器人的精度可以做到0.001毫米，这样精密的仪器里面的电机一开始速度相对比较快，否则一个手术做的时间会长得不得了。</p>\n<p>但是手术刀接近目标距离时，会变得非常慢，但精度会非常高。这样，手术机器人才能同时保证效率和准确性。</p>\n<p>类似地，任何一个机器学习的过程，其实都是不断地调整数学模型参数的过程，直到参数收敛到最佳点。</p>\n<p>每一次调整被称为是一次迭代，调整的幅度被称为迭代的步长。一开始的时候，迭代的步长要比较大，这样能够很快地确定大致范围，效率比较高。</p>\n<p>这就如同测试玻璃球的那个问题中，一开始一次测试10层是一样。但是，如果总是把步长设计得很大，那么最后可能会找不到最佳的参数，因为要么走过头了，要么没有走到。因此，机器学习到最后需要缩小步长，进行精调，以保证最后收敛到最佳点。</p>\n<p>世界上每年有很多机器学习方面的论文，都是围绕提高学习效率展开的，而其中的核心其实就是怎样用最少次迭代，完成模型的训练。当然，任何好的机器学习算法都不是事先人为设定步长，而是在学习的过程中，自动找到合适的步长。</p>\n<p>这种粗调和精调结合的工程设计方式，并不限于“调节”这个范围，而且用于了很多工程产品的设计。</p>\n<p>比如本田最新的超级跑车NSX有四个发动机。一个传统的汽油发动机提供主要动力，这相当于是粗调。一个电动发动机提供在起跑一瞬间快速的加速，这相当于精调。</p>\n<p>一辆汽车如果发动机功率太小，加速会比较慢，如果功率太大，在平时巡航的时候会太费油。因此混合动力的汽车就通过粗调和精调解决了这个矛盾，这也是为什么它比较省油的原因。</p>\n<p>至于NSX为什么还有第三、第四个发动机，那是分别安装在两个前轮上的，主要是给它转向时提供动力，这两个很小的发动机甚至可以让轮子一个加速，一个减速，以减小拐弯半径，做大家在电影里看到的特技转弯的动作。当然这个功能用得更少了，属于进一步的精调。</p>\n<p>能否通过一个发动机达到同样的目的呢？不是不可以，有一些极致的超级跑车就是这么做的，比如后轮可以拐弯，但是这样的工程极为复杂，成本比四个发动机要高得多。</p>\n<p>粗调和精调的思维方式其实在生活中也有应用。很多时候我们先用低成本解决主要问题，然后再想办法把最后5%、10%做好。关于这一点是留给大家的思考题。另外，关于这道题我还留了一个尾巴，我们明天讨论。</p>\n<p>从Google面试的这道看似和计算机技术无关的智力题，你是否体会到它对好的工程师的要求了呢？</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"发明背后的逻辑——飞行","url":"/2018/01/14/thinking/google-methodology-20180114/","content":"<p>发明是一个艰难的过程，常常是经过一代人或几代人的不懈努力才能达成。因此，我们不能只记住最后发明飞机的人，还应纪念那些默默无闻的先驱。从这个故事中认识到：模仿无罪，找准方向，勇于认错，等待时机。<br><a id=\"more\"></a></p>\n<p>这周我和你讲发明背后的逻辑第一讲，有关飞行和潜海的发明。透过众多改变人类生活重要的发明，我们可以学习到很多做事情的方法。</p>\n<p>在我们祖先的眼里，世界上的动物应该有三类，天上飞的、地上跑的和水中游的，当然他们并不知道蝙蝠和海豚，和地上跑的野兽其实都是同一类，关于分类我以后会在讲基因时讲到。</p>\n<p>地上跑的动物和我们祖先的交往最多，我们的祖先要么驯化它们，要么猎食它们，总归有办法对付。但是对于天上飞的和水里游的，只有向往的份儿了。因此，飞行和潜海是人类长期的梦想，今天先讲讲飞行。</p>\n<p>人类实现飞行的梦想其实一直在平行地尝试两条道路，一条路是把一个东西送上天，或者说发射上天，另一条路是像鸟一样自己飞行。今天我先来讲人类在第二条道路上的探索历程，并总结五个知识点。</p>\n<p>在东西方的野史中，都有关于飞人、鸟人和机械鸟的记载。虽然彼此远隔万里，但是描述都差不多，就是给人安上翅膀这么简单。而在这方面真正拿出图纸的发明家是达∙芬奇，他发明了一种机械鸟。</p>\n<p>今天我们都知道这种模仿鸟飞的想法不靠谱，但是 人类在认知新事物时，常常会走这样一条道路：<strong>首先就是对周围事物进行观测，然后模仿。</strong></p>\n<p>有些时候模仿能导致重大发明，比如雷达，比如鲨鱼皮游泳衣，但大部分时候模仿毫无意义，飞行这件事情便是如此。后来对于这一派的发明家，有一个专门的称呼——鸟飞派，意思是说，你要想飞，就学学鸟的做法。</p>\n<p>模仿鸟是人类几千年飞行梦过程中走的一条大弯路，但是研究鸟飞行的原理，对后来造出飞机还是有帮助的。到了文艺复兴时期，人们才开始理性研究飞行。达·芬奇在科学地研究了鸟类的飞行之后写了《论鸟的飞行》一书，它在后来被看成是航空科学的开山之作。</p>\n<p>到了17世纪，意大利的科学家博雷利（Giovanni Alfonso Borelli）从生物力学的角度研究了动物肌肉、骨骼和飞行的关系，他指出人类没有鸟类那样轻质的骨架、发达的胸肌和光滑的流线型身体，因此人类肌肉的力量不足以像鸟类那样振动翅膀飞行。</p>\n<p>根据博雷利的计算，一个体重60公斤的人，至少得具备1.8米宽的胸腔才能支持扇动翅膀所需要的肌肉。博雷利将他的这个研究成果写成了《鸟类的飞行》一书。博雷利的结论宣告了人类各种模仿鸟类的飞行努力都不可能成功。</p>\n<p><strong>在人类的认识过程中常常有这样一个现象，即便从理论上证明了一件事情不可能，但是在此之后依然有人试图改变一些条件，作否定理论极限的尝试。</strong> 比如我们知道在能量守恒定律和热力学第二定律已经被提出一个半世纪的今天，依然有人相信水变油，相信永动机。</p>\n<p>我在前面讲了从数学出发，可以证明今天的人工智能不能产生所谓的超智能，但是我敢肯定接下来的20年，依然会有人往这个方向努力。为什么会这样呢？因为我们人对自己的直觉，或者说对自己从很窄小的认知中得到的常识是如此地喜爱，以至于过分相信它们的功效。</p>\n<p>在飞行的问题上也是如此，不过有趣的是，最后一个试图发明像鸟一样的飞行工具的人并非没有知识的门外汉，恰恰是后来开创了空气动力学的乔治·凯利（Sir George Cayley）爵士，这多少有点讽刺意味。</p>\n<p>但是凯利爵士的过人之处在于 <strong>当他意识到错误之后，不会为了维护自己的颜面而坚持错误</strong> ，这是很多人做不到的， 这也是凯利爵士成为了航空学之父，而迷信水变油的人被称为民间科学家的原因。</p>\n<p>凯利爵士在试图模仿鸟类设计振翼的飞机失败了之后，仔细研究了鸟类翅膀的形状结构，提出了一个开创性的理论——鸟的翅膀不只是提供动力，还提供升力，而这个升力来自于空气在不同形状的翼面流过时产生的压力不同。搞清楚这件事情之后，凯利提出了通过固定机翼（而非振翼）提供飞行升力的想法，从此之后人类在飞机发展上都是沿着这个思路往前走的。</p>\n<p>有了理论之后，凯利在他接下来的时间里将全部精力和财富都用于实现他的理论了，这时凯利已经70多岁了。1849年，凯利制造了一架三翼滑翔机，让一名10岁的小孩坐着它从山顶滑下（动力来自于人用绳子牵引），实现了人类历史上第一次载人滑翔飞行。</p>\n<p>四年后，即1853年，凯利又制造了可以操控的滑翔机，这次他成功地让一位成年人（他的马车夫）实现了飞行。这次飞行的具体时长和距离没有明确记载，但是可能过程有点凶险，以至于这位马车夫随后辞职不干了。</p>\n<p>关于这架滑翔机的设计和当时的一些飞行纪录，凯利写成了论文《改良型1853年有舵滑翔机》，并且送到了当时世界上唯一的航空学会——法国航空学会。</p>\n<p>1971年，英国飞行员史泼劳中校，按照凯利留下的笔记仿制了当年的滑翔机，并获得成功，证明了118年前凯利的记载是真实的。</p>\n<p>要让飞机自行飞行而不是滑翔，除了解决升力的问题，还要解决动力和可操纵性这两个难题，凯利认识到了第二个问题，但是没有认识到第三个问题。</p>\n<p>由于当时没有轻质量的发动机，因此1857年，已经82岁高龄的凯利不得不自己研制轻质量的发动机。但是当时只有蒸汽机，没有内燃机，因此，虽然凯利在自己所剩无多的时日里夜以继日地工作，但终无所成。</p>\n<p>所幸的是，凯利对自己的研究工作都有详细的记述，特别是留下了《论空中航行》的论文，成为了航空学的经典。在这篇论文中，凯利明确指出升力的机理与推力机理应该分开，人类飞行器不应该单纯模仿鸟类的飞行动作进行飞行，而应该用不同装置分别实现升力和动力。</p>\n<p>这为飞机的发明指出了正确的道路。后来莱特兄弟讲，没有凯利的理论，就没有他们的成功。明天我就讲莱特兄弟的工作。</p>\n<p>讲了人类在早期飞行上的努力之后，我把它精炼为这样五个知识点：</p>\n<ol>\n<li><strong>人总是觉得越得不到的越值钱。</strong> 因此越是重大的、轰动性的发明，越是承载了人类长时间的梦想，比如飞行、登月，以及今天还没有实现的治愈癌症和长生不老。因此，从这个角度讲，如果一个人有条件，他可以在考虑做点什么有益的事情时，不妨把目标定得高远一些。</li>\n<li><strong>很多人质疑中国走模仿的道路，但其实模仿是人类学习的第一步， 这本身没有什么可耻的，真正可耻的是走不出模仿，永远模仿 。</strong> 这就如同把老师讲的例题抄一遍不可耻，但总是抄同学的作业就可耻了一样。从模仿到发明的飞跃，关键的转折点在于认识清楚鸟类飞行现象背后的原理。<br>为什么我们说科技在创新中很重要，因为没有技术就搞不清楚原理，就走不出模仿。这个道理对人也是适用的。我每次给国内各种团体讲《硅谷之谜》时说，千万不要模仿硅谷，搞清楚它内部运营的机制就可以了。</li>\n<li><strong>很多违背理论的行为，源于我们感性的想法和做法， 有些时候会引导人们前赴后继，一代代地尝试着失败。</strong> 比如说在股市上试图通过各种赌徒式的行为长期挣钱的想法，就是被不断地从理论和实践上证明错误，却有一代代的人不断尝试，不断失败。这里面根本的原因是我们直觉的理解力其实受限于我们生活的小圈子。</li>\n<li><strong>要勇于承认错误，这样才不至于在错误的道路上滑得太远。</strong></li>\n<li><strong>成功的发明要等到风云汇聚，各种条件都成熟，</strong> 这一点我明天还会讲。</li>\n</ol>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"莱特兄弟成功的关键——不打无准备之仗","url":"/2018/01/15/thinking/google-methodology-20180115/","content":"<p>做事情要遵循一套科学的方法。首先要明确边界，其次有科学的方法，再次，不得不说，运气确实很重要。<br><a id=\"more\"></a></p>\n<p>我们昨天讲到凯利爵士至死都没有能实现自带动力飞行的梦想，因为当时的条件不具备。后来莱特兄弟实现了凯利爵士的梦想，不过在他们之前，还有一个德国的航空业先驱特别值得一提，他叫奥托·李林塔尔(Otto Lilienthal)，今天柏林的李林塔尔机场就是以他的名字命名的。</p>\n<p>李林塔尔对飞行最大的贡献在于他发明了能够重复完成滑翔飞行的滑翔机，这比以前凯利爵士进行的几次带有偶然性的飞行是一个巨大的进步。在凯利和李林塔尔之间，还有很多飞行家进行了滑翔机的试验，但都以失败告终。</p>\n<p><strong>世界上任何一个有意义的发明，都需要能够重复性地获得成功，不能时灵时不灵。</strong> 直到他于1896年意外丧生为止，李林塔尔使用他所设计的滑翔机进行了2000多次的滑翔飞行。</p>\n<p>不过在其它方面李林塔尔运气不太好，他还改进了蒸汽机，但是我们今天都能想得出来，蒸汽机因为气压不可能很高，不可能为飞机提供动力（事实上由于他过早死于飞机失事，因此没有能够开始这一项试验）。</p>\n<p>此外，他没有意识到平衡控制对飞机的重要性——李林塔尔一直像鸟一样，是靠身体来平衡飞机的。这样的飞机即使有了后来的内燃机驱动，能造出来，其实也不实用，因为人在上面几乎不能自由移动。</p>\n<p>李林塔尔在1896年的一次试飞中从空中摔落，并于翌日去世了，临终前他讲，“<strong>少许牺牲是必须的！</strong>”而他则成为了一个牺牲的人。李林塔尔为后世留下了大量的试飞实验记录，这些对后来莱特兄弟的工作有很大的帮助。</p>\n<p>在李林塔尔去世后不久，美国发明家莱特兄弟，即奥维尔·莱特(Orville Wright)和威尔伯·莱特(Wilbur Wright)实现了凯利和李林塔尔的遗愿——自带动力的载人飞行。</p>\n<p>奥维尔·莱特在1912年讲，他们的成功完全要感谢凯利这位英国绅士在100年前写下的重于空气的飞行器的理论。他说到，“乔治·凯利爵士所知道的有关航空原理可以说前无古人、后无来者，直到19世纪末叶，他所出版的作品毫无错误，实在是科学史上最伟大的文献”。</p>\n<p>而他的兄弟威尔伯·莱特也说，“我们设计飞机的时候，完全是采用凯利爵士提出的非常精确的计算方法进行设计计算的”。值得一提的是，莱特兄弟也验证了李林塔尔发表的实验记录，他们发现这位德国先驱在计算机翼升力时犯了一些错误，以至于高估了机翼的升力。</p>\n<p>莱特兄弟可以讲是研制飞机的先驱中最幸运的两个人，用我的话说，就是命好。而这个命首先是大时代给予的。<strong>莱特兄弟出生得足够早，以至于飞机还没有被发明，当然，他们出生得也足够晚，以至于凯利的理论和奥托的内燃机都已经为他们准备好了。<br>更幸运的是，原本比他们起步更早，更有希望实现自带动力滑翔飞行的李林塔尔不幸去世，让他们兄弟二人才有可能成为发明飞机的人。</strong></p>\n<p>直到今天，依然有很多德国人认为是李林塔尔而不是莱特兄弟最先发明了飞机，当然全世界不这么看。不过，李林塔尔的工作倒是对莱特兄弟非常有启发，而他的事迹也激励着这两位美国年轻人努力工作。</p>\n<p>公平地讲，发明飞机的荣誉确实应该给予莱特兄弟，这不仅是因为他们让人类第一架自带动力、固定机翼的飞机飞上了天，而且解决了飞机的动力和控制问题，更有意义的是，他们发明了一整套进行设计和改进飞机的方法。</p>\n<p>我在前面讲到，飞机的发明最关键的技术分别是 解决 <strong>升力、动力和控制</strong> 这三个难题。其中升力问题被凯利解决了。至于动力问题，可以说是被发明内燃机的奥托解决的，也可以说是被莱特兄弟解决的，因为是他们二人将内燃机装上飞机的。</p>\n<p>不过，公平地讲，那个时代任何的人都会想到这一点。值得一提的是，过去一直得不到解决的控制问题，是莱特兄弟解决的。在他们之前，包括李林塔尔等人都试图靠飞行员用身体的姿势控制飞机的平衡和飞行的方向，这就如同鸟一样，但对人来讲这其实是很难做到的。</p>\n<p>莱特兄弟从控制风筝的方法中得到启发，发明了飞机控制机翼的操作杆。这是思维方式的一个飞跃，标志着人类在飞行控制问题上的思维摆脱了原先的模仿，而进入到从原理出发进行发明的阶段。</p>\n<p>如果说自己试飞了两千次的李林塔尔是“猛匠”，那么莱特兄弟则是巧匠。他们兄弟二人打造了一个风洞，进行了大量的试验，不断地提高机翼升力。兄弟二人为了改进机翼尝试了200多种翼形，进行了上千次的风洞试验，而不是试飞。</p>\n<p>此外，他们对于如何控制飞机平衡、俯仰和转弯等航空操纵也进行了大量的试验，因此当他们设计的第一架飞机升空时，就已经很好地找到了保持横侧稳定的方法，并且基本上解决了飞机的操纵性和稳定性的问题。</p>\n<p>莱特兄弟非常注重飞机设计在理论上的正确性。他们二人虽然是自学成才，但是系统学习了空气动力学，有着扎实的理论基础，而且做事情非常严谨。</p>\n<p>这兄弟二人后来发现了李林塔尔在计算升力时有误（多算了60%的升力），并且进行了修正，之后又通过实验进行了验证。这是他们能够成功而李林塔尔失败的重要原因。</p>\n<p>莱特兄弟生性谨慎，他们不做足试验是不肯试飞的，而且即使试飞，也要先进行无人驾驶的试飞。 为了试验飞机的转向控制，莱特兄弟在1902年进行了700-1000次的滑翔试验。</p>\n<p>他们制作的滑翔机在安装了可控尾舵后，进行了上百次表现良好的，结果可重复的试验，最长的一次持续滑翔了26秒，飞过了189.7米（622.5英尺）的距离。</p>\n<p>这一年的10月8日，莱特兄弟算是彻底实现了真正的飞行转向控制，这是飞行史上一个重要的里程碑。 此后，他们才将精力集中到制作自带动力的飞机上。</p>\n<p>1903年12月17日，莱特兄弟在美国西海岸小鹰镇成功试飞了自行研制的“飞行者一号”，从此人类进入了飞机的时代。</p>\n<p>就在莱特兄弟发明飞机的前后，世界各国的发明家们都在加速研制飞机，但是全世界却对他们成功的试验颇为怀疑，因为当时他们的证据只是摄影师拍下的照片。</p>\n<p>直到1908年，兄弟二人先后在欧洲和美国当众进行了好几次成功的飞行试验，全世界对他们的质疑才变成了崇拜。1909年，美国总统塔夫脱邀请莱特兄弟到白宫做客并给他们授了勋。</p>\n<p>接下来我们总结一下今天的知识点：</p>\n<ol>\n<li><strong>试验和测试非常重要， 而这一点是很多人（特别是中国工匠）所忽视的。</strong> 人的天性是喜欢做新的东西，匆匆忙忙就使用，而不喜欢反复测试。<br>事实上，即便在莱特兄弟之后，世界上依然有很多研制飞机的人对风洞试验和各种测试不那么重视，以至于觉得自己做好了就上天去试，最后导致悲剧的发生。因此可以说，在方法和认知上，莱特兄弟是高人一筹的。我们说不打无准备的仗，就是这个道理。<br>今天不仅是做飞机这种上天的东西需要反复试验、测试，做好任何事情都是如此。对比Google和中国顶级的IT企业， 前者对测试是极为看重的，任何代码不做到几乎100%的测试覆盖率，是不能开始系统调试的，而不经过仔细的调试和小范围用户测试，是不能上线的。<br>相比之下，后者看重开发的速度，而不重视测试。从莱特兄弟的经验可以看出， 宁可多试验，多测试，也不要莽撞地把产品推出去冒险。</li>\n<li><strong>成功最重要的是靠走出模仿。</strong> 从飞机控制这件事看，莱特兄弟的过人之处在于了解了控制的原理后，发明了专门的控制机械，而不是模仿鸟。</li>\n<li><strong>我们不能不承认，命运和运气的作用。</strong> 从莱特兄弟成功的过程可以看出时机的重要性，太早的话很多条件不具备，太晚则失去了先机。<br>我在第一季《硅谷来信》中讲成功的产品是“第三眼美女”，就是这个道理，因为那时条件成熟了。我们做事情，如果想成功率比较高，常常要等到第三波浪潮。</li>\n<li>还要再次强调一下“第三眼美女”的理论，这是我在“硅谷来信”的《第009封信 | VR技术与第三眼美女》中提出的，也就是说， <strong>重大的发明需要经历两波甚至更多的失败，才能获得最后的成果，而发明的功劳总是给予最后一个发明家。</strong><br>至于为什么，算是今天的思考题，我在周五会解答。如果没有耐心，没有情怀，指望什么事一开始就很快获得成功，常常会让你失望的。</li>\n</ol>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"为什么飞机不能飞得更快？","url":"/2018/01/16/thinking/google-methodology-20180116/","content":"<p>为什么飞机的速度在过去的半个多世纪里没有进一步提高？通常给出的原因有四个，这里面有些原因是真的，有些则是完全可以解决的，只是大家硬要找一些原因。<br><a id=\"more\"></a></p>\n<p>我在前两天通过飞机发明的过程，介绍了它被发明背后的逻辑，特别强调测试的重要性。</p>\n<p>在莱特兄弟发明飞机的一个多世纪里，飞行技术有了长足的进步。不过，如果把从1903年至今的这114年作一个划分，那么1969年是一个分界点，这一年波音747首飞成功。从这往前是67年，往后是48年，时间上相差不多。</p>\n<p>1969年之前的第一个阶段，是飞行技术高速发展的阶段，后一阶段没有什么本质变化，今天商业飞机的飞行时速依然没有超过波音747。我们今天依然在使用波音747，虽然空客A380更大，波音787更舒服，但是波音747这个1969年的产品依然是最快的民航飞机。</p>\n<p>在追求高性能的军用飞机方面，60年代末的侦察机SR-71和轰炸机XB-70（女武神）已经超过了3倍的音速，比今天的战斗机要快得多。事实上不仅飞机如此，轮船、火车和汽车，经历了一段时间快速发展后，都呈现出停滞的趋势。</p>\n<p>很多人也因此觉得，当半导体行业按照摩尔定律划定的速度快速发展了半个多世纪后，也会陷入飞机和其他交通工具发展停滞的厄运。</p>\n<p>为什么飞机的速度在过去的半个多世纪里没有进一步提高？通常给出的原因有四个，这里面有些原因是真的，有些则是完全可以解决的，只是大家硬要找一些原因，我们先看看这些“已知”的原因。</p>\n<h3 id=\"第一个是突破音障困难。\"><a href=\"#第一个是突破音障困难。\" class=\"headerlink\" title=\"第一个是突破音障困难。\"></a>第一个是突破音障困难。</h3><p>莱特兄弟的第一架自带动力、成功试飞的飞机时速慢得和自行车差不多（一分钟飞了260米），每小时15公里，但是早期飞机的进步速度非常快。</p>\n<p>到了1916年波音公司推出第一代飞机时，时速已经达到每小时100公里以上了。到二战时，英国的喷气式飞机Gloster Meteor的时速已经达到900公里／小时，接近音速了。</p>\n<p>但是，在此之后，人们发现飞机的飞行速度几乎难以进一步提高了，不仅飞行的阻力剧增，而且难以操控，经常会动不动就栽跟头。因此人们曾以为声速是飞机速度不可逾越的障碍，因此提出了音障的概念。</p>\n<p>开始的时候工程师们还以为是动力不足，但是等到了1944年，约翰·霍普金斯大学研究出能够达到超音速飞行的喷气式发动机后，飞机依然没有能突破音障。</p>\n<p>为什么会产生音障呢？因为当飞机飞到声波的速度时，飞机产生的声波开始在物体前面堆积，形成干扰飞机飞行的“波浪”，会严重干扰飞机的飞行。因此，这不是简单地增加发动机功率就可以实现的。</p>\n<p>怎样突破音障呢？ 工程师们在一系列尝试失败后，决定回到问题的原点，重新研究空气动力学。 当时美国和前苏联的飞机工程师都在和空气动力学家密切合作，试图率先研制出超音速飞机。所谓回到原点，就是像当初莱特兄弟那样，从头开始试验飞机的形状和气动特征。</p>\n<p>经过进行了一系列试验，两国的工程师都发现，原先飞机的外形根本不适合做超音速飞行，要想做超音速飞行，机翼和整个飞机都要“非常薄”，因此如果你看图片会发现，今天的超音速飞机（比如战斗机）比亚音速的民航客机都要“薄”很多。</p>\n<p>当然，如果只采用现有的研究方法，还是难以进一步突破，因此在研究超音速飞机的过程中，美苏双方的工程师都发明了一些新的试验方法。</p>\n<p>比如前苏联茹科夫斯基中央空气流体力学研究院的奥斯托斯拉夫斯基，就把很多火箭推动的模型小飞机先用大飞机带到高空，然后通过火箭点火加速，让模型飞机的速度超过音速后，进行试验和测量。这样工作的成本可想而知。</p>\n<p>在重新认识飞行的原理后，美、苏两国先后研制出超音速飞机。1946年，美国的X－1飞机达到了1.3倍的音速，很快前苏联也赶了上来。到了60年代，两国都可以制造出3倍音速以上的飞机了，至此第一个困难算是解决了。</p>\n<h3 id=\"第二个制造超音速飞机的困难在于成本。\"><a href=\"#第二个制造超音速飞机的困难在于成本。\" class=\"headerlink\" title=\"第二个制造超音速飞机的困难在于成本。\"></a>第二个制造超音速飞机的困难在于成本。</h3><p>我们知道军用飞机可以不计成本地生产和使用，但是民用飞机不行。世界上成功运营了近三十年的协和式超音速客机，从伦敦（或者巴黎）飞到纽约的单程票价高达6000-7000美元，而一般飞机头等舱的票价不过是这个价钱的一半。</p>\n<h3 id=\"第三个问题出在乘坐不舒服。\"><a href=\"#第三个问题出在乘坐不舒服。\" class=\"headerlink\" title=\"第三个问题出在乘坐不舒服。\"></a>第三个问题出在乘坐不舒服。</h3><p>协和式飞机虽然将横跨大西洋的时间从六个小时缩短到三个小时，但是飞机坐得并不让人感到舒服。里面只有经济舱大小的座位，而且非常吵。</p>\n<p>根据我一位坐过协和式飞机的同事讲，它唯一的好处就是在两万多米的高空能看到其他任何地方都看不到的“宇宙的景色”，而在其他方面，你还不如坐一个普通飞机的经济舱。我问他最大的问题是什么，他说首先是所谓的爆音（Sonic Boom），即吓人的噪音。</p>\n<p>如果按照今天对噪音污染的标准，协和式飞机飞行时无论是在地面上，还是在机舱里都是不合格的。除了噪音大，飞机在冲破音障时，人坐在里面并不舒服，当然，在超过音速，把声音甩到后面之后，这个问题不再会困扰乘客。</p>\n<h3 id=\"第四个问题是所谓机场的架构和运行方式不支持提速。\"><a href=\"#第四个问题是所谓机场的架构和运行方式不支持提速。\" class=\"headerlink\" title=\"第四个问题是所谓机场的架构和运行方式不支持提速。\"></a>第四个问题是所谓机场的架构和运行方式不支持提速。</h3><p>因为如果飞机的速度提高一倍，机场的管理会出现混乱。</p>\n<p>那么上面的原因哪些是真实的呢？</p>\n<p>第一个原因，也就是技术上的难度是肯定存在的。不过它在上个世纪50至60年代已经得到了解决，因此不能算。</p>\n<p>第二个原因，即昂贵的运营成本，这确实是一个原因。但如果再仔细看一下，其成本增加的最大部分是燃油——运送一个乘客，燃油的消耗是今天波音747或者777的7倍左右。</p>\n<p>但是这个问题本身可能是一个伪命题，因为全世界石油价格浮动范围很大，从2000年前后每桶原油不到10美元，到2008年一度高达150美元，再到现在回到50多美元，航空公司通过调整票价，从来没有因为耗油太多无法经营，更何况协和式飞机的票价是同样大小舱位的近十倍，而且当时不缺乘客。</p>\n<p>协和式飞机计划之所以长期亏损，是因为体量太小，运营的边际成本极高，另外它基本上是三家“国企”（英航、法航、协和公司）在运作，效率也很低。</p>\n<p>第三个问题倒真是一个问题，因为乘客花这么多钱是为了舒服的，而不是为了受罪的。在协和飞机运营的20多年里，大部分乘客只是为了体验一次超音速飞机的目的乘坐它，而不是因为它比普通客机好到哪儿去。</p>\n<p>第四个问题也是一个伪命题。如果航空公司飞机的时速从现在的0.85马赫提高到2马赫以上，这个过程会是渐进的，不会一夜之间所有的飞机都提速，然后导致所有机场的运作都要重新规划。实际上，大部分机场的航班计划都是不断调整的，每增加一条航线或者一些季节性的航班，机场的计划都要调整。</p>\n<p>实际上，火车的提速所带来的管理变化，要远比飞机提速大得多，既然前者能做到，后者没有理由做不到，只是想做和不想做的问题。</p>\n<p>在上述原因中，只有人不舒服是一个大问题，其他问题只要形成市场规模，自然会有人考虑如何改进技术，是可以将它们慢慢解决的。但现实情况是那些问题并没有解决，必然有更深层的原因，这些我明天再谈。</p>\n<p>咱们来总结一下今天的知识点：</p>\n<ol>\n<li><strong>在人类试图突破音障这件事情上，解决问题不是靠沿着原来的方向努力，而是回到了原点，重新考虑飞机的空气动力学问题。</strong><br>很多时候，我们考虑问题的维度不够多，比如飞机速度上不去，通常大家只会考虑动力问题。<br>今天很多人收入不高，想到的只是简单地加班，延长工作时间，做更多的事情，没有从更高的层次想问题。<br>此外，面对新问题，简单套用当年莱特兄弟的做法还不够，工程师们还要创造出一系列新的试验方法。<br>我把这个创新和超越的过程概括成三步， “回到原点重新思考，重复过去成功的工作方法，根据新问题适当增加新方法”。 这应该可以用于各行各业。</li>\n<li><strong>任何让人花钱找罪受的产品都很难赢利， 这也是今天VR没有真正形成市场的重要原因。</strong> 今天哪怕再好的VR眼镜，都很难做到使用半小时以上头不晕。</li>\n<li><strong>在商业上，不仅要关心一个东西好不好，还要问一下贵不贵。</strong><br>明天我会进一步分析没有超音速客机的原因，并且以马斯克为特斯拉公司设计的产品线为例，说明从高端往低端占领市场的策略。</li>\n</ol>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"风险投资如何帮助创业公司成长并获利","url":"/2018/02/21/thinking/google-methodology-20180221/","content":"<p>我们昨天讲了风险投资基金融资的过程和行政的管理，今天我们来看一个例子，说明风险投资基金是如何帮助一个创业公司成长，并且是如何获利的。<br><a id=\"more\"></a><br>假定领英公司的工程师山姆和雅虎公司的工程师强尼发明了一种大数据工具，两人私下里开发出了产品原型，找了几家企业试用效果还不错，于是花钱申请了专利，然后就准备办公司了。这两个人事先说好各自的股权相等。他们开始的时候找了几个投资人，但是都没有能说服对方投资，后来找到了雅虎的早期员工杰瑞。杰瑞从雅虎退休后开始做最早期的风险投资，也被称为<strong>天使投资</strong>，结果看中了这两个人和他们的技术，决定给他们投资。接下来他们遇到了第一个问题，<strong>山姆和强尼到目前为止的工作到底值多少钱</strong>？</p>\n<p>山姆和强尼认为值800万美元，而杰瑞认为只值300万美元，最后经过讨论，双方达成下面的认同：</p>\n<ol>\n<li><p>杰瑞认定山姆和强尼的工作值450万美元，并且同意投资50万美元，占股权的10%。这样投资后，这个项目值500万美元。</p>\n</li>\n<li><p>如果山姆和强尼在下一次融资时，投资人认定的估值不到500万美元，那么到时候要按实际的估值，计算杰瑞的50万美元所占的股份。</p>\n</li>\n<li><p>保留10%的股权给将来的员工、重要的管理层成员和顾问。</p>\n</li>\n</ol>\n<p>这样融资后，三个人占股比例如下，其中有10%预留给了今后加入进来的员工。</p>\n<p><img data-src=\"/images/google-methodology-20180221/1.png\" alt=\"\"></p>\n<p>通常这样的一轮投资被称为天使轮投资。</p>\n<p>接下来12个月后，山姆和强尼的钱也花完了，他们的产品做得不错，还雇用了两个人，于是他们决定进行新的一轮融资。这时他们觉得公司值2000万美元了，希望融资500万美元，占到股权的20%。</p>\n<p>经过和几家风险投资基金接触，最后巨杉资本决定给他们投资。经过商议，公司在新的一轮融资前值1600万美元，巨杉资本出资400万美元，占股权的20%，同时它要求在董事会中占一席。</p>\n<p>当然，<strong>这样一来， 山姆、强尼和杰瑞三个人的占股比例都被缩小了，这被称为股权稀释</strong>，但是他们的股票潜在的价值增加了。为了简单起见，我们假定这时公司有2000万股股票，正好一美元一股。下表是融资后，三个人和巨杉资本所占的股权、股票价值，以及对比上一轮估值的增益。这一轮融资我们姑且称它为A轮融资。在投资前的估值称为Pre-Money估值，在投资后的估值，即Pre-Money的估值加上投入的资金，被称为Post-Money。</p>\n<p><img data-src=\"/images/google-methodology-20180221/2.png\" alt=\"\"></p>\n<p>又过了一年，这400万美元投资又花完了，不过公司现在的产品卖得不错，而且拿下了两个大客户，年收入500万美元，虽然还不能盈利，但是让人感到很有希望。如果不融资，山姆等人就要花很多精力在销售上，而且在进人的时候要非常保守谨慎，这样产品开发的速度就慢了，而且占领市场的速度也会比较慢。</p>\n<p>于是经过和巨杉资本以及杰瑞商量后，山姆等人决定再融资1000万美元，融资前估值是9000万美元。</p>\n<p>这一次，山姆等人的运气不是太好，因为整体经济形势放缓，投资人比较谨慎，很多都不愿意投资，最后白石风投同意按照投资前6000万美元的估值，投资900万美元。</p>\n<p>当然，白石风投还有一个附加条件，因为接下来该公司要将工作重点从技术开发转向市场推广，而山姆和强尼两个创始人都是有技术背景的，市场资源不多。因此，白石公司要求该公司引入一个有市场推广经验的职业经理人来做CEO，山姆等人也答应了。</p>\n<p>为了让这个未来的CEO有归属感，大家同意增发一些股票给新来的CEO，同时为了鼓励包括创始人山姆和强尼在内的全体员工努力工作，再增发一些受限制的股份，作为奖金分四年奖励给大家，当然得到这些股份的前提是每一个人完成了自己的KPI。</p>\n<p>为了简单起见，我们假定这时公司的股票一股拆成了三股，拆分后价格依然是一美元，给未来CEO和奖励大家的股票各自为300万股。这样，在这一轮融资（假定为B轮）之后，大家的占股和股票价值如下：</p>\n<p><img data-src=\"/images/google-methodology-20180221/3.png\" alt=\"\"></p>\n<p>此外，大家再记住一个数字， <strong>该公司到此为止发行了7500万股的股票</strong>。</p>\n<p>假如山姆和强尼等人的公司办得顺利，未来CEO也找到了，公司从此销售业绩上升，不再需要投资也能运营和扩张了。又经过了几年，有了不错的利润，于是挂牌上市了，上市的承销商给他们的估值是3亿美元。</p>\n<p>这样，大家的股票在市场上就可以出售了。按照上市的价格，山姆和强尼的股票大约值6000万美元，杰瑞的值1500万美元，他作为风险投资人，获得了30倍的回报。类似地，巨杉资本和白石风投分别获得了10倍左右和3倍左右的回报，大家皆大欢喜。</p>\n<p>但是，有些时候，事情没有这么美满。山姆和强尼的公司可能会遇到发展瓶颈，抑或赶上经济下行周期，长期无法盈利，当然也就不用说上市了。</p>\n<p>这时大家就有两个选择，一个是撑下去，这样可能还需要再融一次资金，当然大家的股权也会被相应稀释。不过，融完资以后的情况其实大家谁也吃不准。第二个选择是看看是否有企业愿意收购他们，或许有人对他们的技术感兴趣，或许有人对他们已经签下来的几个大客户感兴趣，抑或是对两个创始人或者团队感兴趣，总之他们还有一些价值，于是决定收购他们。我们讲一个理想的情况，假如Facebook公司最后愿意以8000万美元的价格收购他们，这时问题来了，钱该怎么分呢？</p>\n<p>显然，<strong>一个简单的法子是，之前发行7500万股的股票，每一股算下来是1.07美元</strong>。作为创始人的山姆和强尼当然希望这样分钱，这样他们每个人可以拿到2000万美元左右。但是作为投资人的白石风投当然不愿意，因为他们折腾了那么多年，最后只获得7%的收益。</p>\n<p>上述情况在风险投资时其实经常发生，因此白石风投当初在投资时，会要求在被收购时，至少要保证一定的利润，比如50%。当然，巨杉资本和杰瑞可能也会要求按照前一轮融资的价格加上50%。这样一来，最后一轮进来的白石风投可以拿回1350万美元，巨杉资本和杰瑞也会相应地多拿些钱。而创始人和员工分的钱，就会少一些。</p>\n<p>在我举的这个例子中，风险投资的股权占比并不算高，因此创始人即使少拿点，还是有利可图的。但是， <strong>在很多实际的案例中，因为融资次数太多，或者其他原因，风险投资占比非常高，这时即使达成收购，创始人可能也挣不到多少钱</strong>。</p>\n<p>当然，还有比这个更坏的情况。山姆和强尼办的公司可能一直在亏损，而且也没有人愿意收购，作为投资人的白石风投、巨杉资本和杰瑞当然不能眼看着投资一天天萎缩不管，他们会要求破产清算。</p>\n<p>至于怎么清算，就看一开始的协议了。我们假定公司最后资产有500万美元，这包括知识产权，而对IT公司来讲，值钱的也就是那些知识产权。那么白石风投、巨杉资本和杰瑞按照各自的占股比例即900:1200:480来分这500万，最后他们分别得到180万、240万和80万。而山姆和强尼作为创始人，则分不到一分钱，不过他们也算是过了把创业的瘾，而他们找来的雇员，只好再去找工作了。</p>\n<p>上面这样的例子在硅谷，也在中国，每天都在发生。那么上述三种可能性分别有多大呢？</p>\n<p><strong>在硅谷，获得融资的公司，大约有1%的可能性上市</strong>，大家不要觉得1%小，这已经是全世界最高的上市比例了。如果公司上市，早期的投资回报能有多少倍呢？平均大约是50倍，这样的回报常常被称为“本垒打”。 </p>\n<p><strong>第二种情况，也就是被并购，在硅谷的概率大约是20%</strong>， 这个比例还是很高的，被并购后，投资人一般不会赔钱，创始人是否能赚到钱，赚多少，就看并购的价格了。</p>\n<p>剩下来接近八成的情况都是失败。在中国，失败率要远比硅谷高得多。因此，<strong>创业是一个高风险的差事</strong>。</p>\n<p>从今天讲述的风险投资过程，我们可以得到这样四点启示和结论：</p>\n<ol>\n<li><p>对于没有上市的公司，不管估值多高，创始人的财富都不过停留在纸上，只有钱落袋为安之后才是自己的。</p>\n</li>\n<li><p>总的来讲，投资人和创始人的利益是一致的，除非到了关门清算的时候。</p>\n</li>\n<li><p>投资人的股份在清算时有优先权，也被称为优先股。至于怎么清算，就看投资时的协议了。不过总的来讲，最早期的投资人常常能拿回大部分投资，甚至有利可图，后期的可能会亏损。中国一些公司甚至出现过上了市，上市的价格依然比最后一轮融资的价格低，也就是说最后的投资人都亏损了。</p>\n</li>\n<li><p>一个公司最终要靠盈利来获得财富，靠烧投资人钱，早晚有一天资金链会断裂，当初纸面上有多少财富，最后都是水中月，镜中花。</p>\n</li>\n</ol>\n<p>希望这些内容对你有所启发。</p>\n<p>最后请你思考这样一个问题，如果办公司，应该从风险投资那里多拿一些钱，还是尽可能地少拿钱，给出你的理由。</p>\n<p>祝近安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"计算机领域大人物：Google大脑的发明人杰夫·迪恩","url":"/2018/04/04/thinking/google-methodology-20180404/","content":"<p>从2016年开始，人工智能成为在全球最热门的技术话题和投资方向，而这在很大程度上是因为Google AlphaGo的出色表现。我今天要向你介绍的是AlphaGo的背后，Google深度学习算法、Google大脑的发明人<strong>杰夫∙迪恩</strong>。<br><a id=\"more\"></a><br>在Google内部，如果你要问最牛的工程师是谁，大家会告诉你是迪恩和他长期的搭档盖莫沃特（Sanjay Ghemawat），当然由于后者不善言辞，知道迪恩的人更多。另外，如果要问Google收入最高的工程师是谁，也是迪恩。他的收入比大部分VP要高很多。最后，<strong>如果你要问作为一个软件工程师能走多远，要是你能像迪恩和盖莫沃特那样编写程序一辈子，就可以当上美国工程院院士，这两位工程师都是院士。</strong></p>\n<p>当然，迪恩之所以牛，不在于上面这些光环，而在于他和盖莫沃特一起开创了云计算时代。<br>Google内部最明显的特征就是数据量特别大，<strong>迪恩在Google解决的第一个问题就是如何有效地解决大量数据的存储</strong>。在过去，每一个文件体量都不大，因此都是单独存储的。但是到了Google的时代，互联网上的数据量剧增。在2000年左右，全世界网页的数量已经接近一个亿。将一亿个网页逐一单独存取，效率非常低下。于是，从2001年开始，迪恩和盖莫沃特开始设计一种巨大的文件系统，能够存储过去成千上万，甚至上百万、上亿个小文件。当然，这样大的文件肯定不是一台计算机服务器能够存储下的，为此，迪恩等人发明了一种方法，让一个大文件能够分布地存储到成百上千台服务器中。这种文件系统被称为GFS（Google File System），意思是谷歌的文件系统。</p>\n<p>迪恩对云计算的第二个贡献，是发明了一种并行处理的工具，这就是今天被业界熟知的MapReduce技术。MapReduce的原理其实并不复杂，就是计算机科学中的分治算法（Divide and Conquer）。打个比方，就是分化敌人，然后各个消灭。</p>\n<p>我们在前面第058封信中讲，计算机科学的精髓在于自顶向下的递归，MapReduce的做法也是如此，它先在最顶层将一个大任务分解为成百上千，甚至上万个小任务，然后将每一个小的任务分配到一个服务器上。最后，再将每一个服务器上的结果综合起来，得到原来大任务的最后结果。第一个自顶向下分解的过程被称为Map，第二个自底向上合并的过程被称为Reduce，这也是MapReduce这个名词的由来。</p>\n<p>有了GFS，Google很容易高效率地将整个互联网和更多的信息存储下来，MapReduce的出现，则让计算的成本大大降低。从技术上讲，两者的实质都是用大量廉价的服务器取代一台超级计算机。前者的价格不到后者的1/5，这让Google的运营成本比微软和雅虎低得多。</p>\n<p>回顾我们在之前第036封信中对比巴贝奇和楚泽的工作时讲到过，前者是做一个非常复杂的计算机，而后者是用简单的模块搭建能实现非常复杂功能的机器。迪恩的思路显然属于后者。十几年前，太阳公司的CEO麦克尼利嘲笑Google这种廉价的服务器集群是“3M胶带纸粘起来的”。但是就是这些“3M胶带纸粘起来的”廉价服务器让生产高大上服务器的太阳公司关了门。<br>当计算机所要完成的任务变得越来越大之后，分散到各个服务器中的子任务是很难同时完成的，这样当一部分子任务先完成了，而另一部分还在运行时，整个并行计算系统就要等待最后一个子任务完成，效率会顿时下降。另一方面，调度特别是协调那么多子任务，也是一件非常困难的事情，这会让系统管理员和工程师苦不堪言。2004年之后，随着Google服务器数量剧增，这个问题就开始凸显。</p>\n<p>这时以迪恩为首的全球系统架构团队设计了高度自动化的计算机集群管理软件，在Google内它被称为Borg，这个词源于一部科幻电影里一台无所不能的计算机。Borg可以在全世界Google的数据中心内，自动寻找和分配可用的服务器，完成一项巨大的任务。它管理资源的效率和优化程度，远远高于系统工程师。有了这个工具，Google实现了云计算的闭环，2006年8月，Google当时的CEO施密特博士正式提出了云计算的概念。</p>\n<p>通常我们认为，Google之所以在竞争中占有优势，主要是技术好，产品质量高。其实，更重要的原因是运营成本低，而且因果关系链是靠低运营成本导致高技术。这是Google当时的CEO施密特的结论。</p>\n<p>那么运营成本和技术背后的关系又是什么样的呢？施密特讲，我们的运营成本只有微软和雅虎的几分之一，一次搜索服务只有$0.x分钱（非常抱歉这个具体数据我没办法公开给你）。我们可以增加服务器的数量，将成本提高，在每次搜索时进行很多能够进一步提高质量的，耗费时间的复杂的运算，而我们的竞争对手是无论如何提供不出这样高质量的服务的。而如果他们向用户提供这样的服务，高成本会让他们严重亏损。</p>\n<p>为了更便于你理解施密特的策略，我不妨打一个更通俗的比方。<strong>比如说一部手机里面的处理器的成本是50美元，其他成本是200美元，这样做一部手机的成本是250美元，可以卖到300美元，于是300美元就成了大部分手机的市场价。但是有一家公司做同样性能的处理器的成本只要5美元，虽然它可以将手机成本做成205美元，通过价格取胜，但这是山寨者的逻辑。Google的逻辑是，采用10个处理器（总价也是50美元），实现其他厂家根本没有条件完成的功能。这是施密特的逻辑。当然在其背后，帮助公司实现超低成本的是迪恩等人。</strong></p>\n<p>在云计算之后，迪恩又发明了能够实时处理海量结构化数据的工具BigTable，它是今天云计算中所有实时日志处理的工具。这些工作确立了他在世界计算机系统领域的权威地位，并让他和盖莫沃特一同当选为美国工程院院士。</p>\n<p>作为主修一个计算机系统的专家，迪恩在大学里并没有学过机器学习、机器翻译，更不懂得下围棋，但是这并不妨碍他了解这些领域的技术需求，并利用计算机系统领域的专长设计出适合做机器翻译、机器学习和下围棋的计算机工具，这个工具就是Google大脑。当然，它的另一种称呼“Google深度学习”更为业界所知。</p>\n<p>迪恩在Google工作了近20年，成就其实只有个位数（我数了数大约六件），但是每一项成就都足以改变世界。迪恩不是学者型的研究人员，因此不会像学术界的计算机科学家那样注重发表论文。不过，他偶尔会和同事一起发表一些论文，而那些偶尔发表的论文每一篇都会引起轰动。迪恩每一篇论文的引用数都有几千次，最高的近三万次。几千次引用是一个什么样的概念呢？世界上大部分论文扣除自己的引用，引用数都在10左右，能上百就是优秀论文了，中国大部分院士成名的论文的引用数通常只有两三百，以发表论文质量高著称的施一公，论文引用数能上千。从这里你就可以看出迪恩的成果的影响力了。</p>\n<p>那么为什么迪恩能做到如此大的成就呢？我把他的过人之处归结为五点：</p>\n<ol>\n<li><strong>对计算机科学的深刻理解</strong>。回顾我们前面提到的计算机科学的特点，你会发现迪恩做事一直围绕着计算机科学的那些本质——<code>模块化</code>、<code>平行处理</code>、<code>分治</code>，等等。一个人在计算机领域能走多久，取决于他的理解有多深。</li>\n<li><strong>专注</strong>。迪恩始终是一个计算机工程师，而且20多年来一直专注于计算机系统，他从来没有做什么跨界的事情。作为Google最早的工程师之一，迪恩有很多次机会转成高管，但他从来没有那么做，而是一直专注于技术本身。</li>\n<li><strong>善用优势</strong>。迪恩所做的工作的原理，其实大家都懂，但是能够做得有规模，有水平就不容易了。他懂得利用Google内部的优势，就是具有近乎无限的计算机资源和数据资源，通过量变达到质变。</li>\n<li><strong>合作取代颠覆</strong>。迪恩的很多成就具有颠覆性，但是他很少提颠覆这类的词。他的成果大多是合作的结果。他主导开发的GFS文件系统，原本是为了Google的网页下载和索引团队的需求搭建的。当时从事Google索引工作的朱会灿博士是他的GFS的第一个用户。他的并行计算工具MapReduce是为了广告优化开发的，Google大脑是为了Google的机器翻译和语音识别等项目开发的。他不是凭空创造概念的人，但是他为了解决实际问题做的项目，后来反而成了新概念。</li>\n<li><strong>少做事情</strong>。无论是迪恩做的工程项目，还是写的论文，数量都不多。但是大部分计算机系的教授一辈子的贡献抵不上他的一个项目，一辈子论文的引用数，抵不上他的任何一篇论文。很多人觉得多了就是好，少了就不好。其实再多的芝麻也难以抵得上一个西瓜。<br>希望迪恩的经验对你有所启发。</li>\n</ol>\n<p>最后邀请你思考一下：Google用“一堆胶带纸粘起来”的服务器集群，和SpaceX绑在一起的火箭集群有相似之处，能否就这种方法谈谈你的看法？</p>\n<p>祝春祺</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"大学前应该读完的书","url":"/2018/06/14/thinking/google-methodology-20180614/","content":"<p>在昨天写给你的来信中，向你推荐了一些美国中小学生的书单。今天把我在《硅谷来信》中列的中学生书单分享给你。<br><a id=\"more\"></a></p>\n<p>即使你不是这个年龄阶段的人，也希望它们对你能够有所启发，没有读过的书，现在拿起来读一读也无妨。<br>希望你可以把这份书单分享给你的学生朋友和他们的家长。</p>\n<h3 id=\"一、文学类\"><a href=\"#一、文学类\" class=\"headerlink\" title=\"一、文学类\"></a>一、文学类</h3><ol>\n<li>金庸和琼瑶的书各一本，随便读什么，长篇的比短篇的好。<br>金庸和琼瑶的书算不上经典，但是对于了解中国人的情感还是很有帮助的，关键是那些书情节都很吸引人，读起来很省劲。很多人不喜欢阅读是因为读不下去。这些书虽然通俗易懂，但是文笔非常好，可以作为写作的范文。<br>很多人觉得读了这些通俗的小说不够高雅，要知道，简∙奥斯丁甚至莎士比亚的书在他们的年代都是通俗读物。当通俗小说流传下来了，几百年后如果还有人读，就是经典。</li>\n<li>鲁迅的短篇小说集<strong>《呐喊》</strong> 。要了解中国，必须读这本小薄册子。</li>\n<li><strong>《红楼梦》</strong>。</li>\n<li>雨果<strong>《悲惨世界》</strong> ，它告诉我们什么叫做人性，并且教会我们爱比恨更有力量。</li>\n<li>罗曼∙罗兰<strong>《贝多芬传》</strong> ，很薄的一本书，告诉我们什么是英雄，怎样才能成为英雄。</li>\n<li>乔治·奥威尔<strong>《1984》</strong> ，这是著名的左翼进步记者奥威尔在经历了西班牙内战后，反思人类的行为，写下的政治寓言式小说。几十年后，很多现象居然在他的书中已经讲到了。它告诉人们什么是自由。</li>\n<li>歌德<strong>《少年维特的烦恼》</strong> ，进入大学后，几乎每个人都会遇到维特式的烦恼。</li>\n<li>贾平凹的小说，随便看上一两本，最近10年比较好的是<strong>《秦腔》</strong> 和<strong>《古炉》</strong> 。虽然莫言得了诺贝尔文学奖，但是我个人觉得贾平凹的小说写得更好。贾平凹对社会观察的视角非常独特，写作的切入点与众不同，而他对人物内心的情绪的描写非常细致准确。总的来讲，贾平凹的作品里面没有华丽的辞藻，甚至没有什么金句格言，但是他时不时地在文字之间流露出的“偶然”的感悟，不乏哲理，让人回味。</li>\n<li>夏洛蒂·勃朗特<strong>《简·爱》</strong> ，女生尤其应该读读，思考一下应该成为什么样的人。</li>\n<li>司汤达<strong>《红与黑》</strong> ，法国大革命后的祁同伟的故事（祁同伟是电视连续剧《人民的名义》中的一位出身贫苦，但是后来为了往上爬和捞取私利而不择手段的人）。它讲述了一个逆袭的屌丝的阴谋与爱情的故事。思想性和文笔在众多法国名著中也是翘楚。</li>\n<li>简∙奥斯丁<strong>《傲慢与偏见》</strong> ，可以帮你了解一下优雅的贵族爱情。</li>\n<li>莎士比亚<strong>《哈姆雷特》</strong> ，读完这篇名剧，可以真正理解什么叫做“戏剧化”。另外也推荐<strong>《罗密欧与朱丽叶》</strong> ，如果有时间的话。</li>\n<li>富兰克林<strong>《富兰克林自传》</strong> ，这本建议你读英文原文（并不长），可以练习一下英语。我一直是把富兰克林当作我的精神导师看待的，以后我还会用三封信的篇幅介绍他对我的影响。这本小册子，则是我最早了解这位美国国父的入口。我在前面第99封信《我为什么倡导保守主义》中也简要地介绍了富兰克林，有兴趣的朋友可以回过头来读一下那封信。</li>\n<li>木心<strong>《文学回忆录》</strong> ，这是陈丹青在大学听木心讲课时做的笔记，里面透出木心对中外文学的深度思考。</li>\n<li><strong>《古文观止》</strong></li>\n<li><strong>《唐诗三百首》</strong> ，要了解中国文化和语言，要从这两本书入手。至少将来找男女朋友也用得上。如果你是一个理工男，这两本书还特别有用，因为总不能和女友谈编程或者机械原理吧，一句“曾经沧海难为水，除却巫山不是云，取次花丛懒回顾，半缘修道半缘君”，比学霸们的考试成绩更能打动人。<br>如果想装得老成点，几句《春夜宴桃李园序》（李白作）里的 “浮生若梦，为欢几何？”，“阳春召我以烟景，大块假我以文章”，说出来也会让人感慨，当然更重要的是你可以通过它们理解李白等人的心境。</li>\n<li>菲茨杰拉德<strong>《伟大的盖茨比》</strong> ，这本书文笔极其优美，如果能读英文原文，推荐阅读。但是故事性一般，因此如果读中译本，就算了。</li>\n<li>钱钟书<strong>《围城》</strong> ，这是钱钟书先生的代表作，深入刻画了中国知识分子的生活百态和个性，全书诙谐幽默，可读性很强，里面的内容已经在今天人们的谈话中不知不觉地被引用，没有读过的话，在大学交流都成问题。</li>\n</ol>\n<h3 id=\"二、历史类\"><a href=\"#二、历史类\" class=\"headerlink\" title=\"二、历史类\"></a>二、历史类</h3><ol>\n<li>傅高义<strong>《邓小平时代》</strong> 。傅高义（Ezra Feivel Vogel）其实是一位美国人，虽然名字像是中国人。他是哈佛大学教授，中国问题专家。要了解中国过去几十年的改革开放，可以从这本书着手。这本书并不是邓小平传，而是对中国惊险崎岖的改革开放之路来龙去脉的描述，读懂这段历史，就能体会我们这些“仍然生活在邓小平时代”的人的现在和未来。</li>\n<li>基辛格<strong>《论中国》</strong> 。作为促成中美关系正常化的基辛格博士，看待中国比我们自己看得还清楚。几年前他在Google讲，自己到中国多达60次之多，见到过从毛泽东开始的中国历届最高领导人。另外，如果有能力，最好读一下英文原版书，因为里面的内容多得多。</li>\n<li>房龙，任何房龙的书都值得读，他是一个能把历史写出趣味的人，如果只读一本，就读<strong>《人类的故事》</strong> 吧。</li>\n<li>茨威格<strong>《人类的群星闪耀时》</strong> 。我的<strong>《文明之光》</strong> 一书就是受他的启发，他通过写历史片段描写了一群历史上的伟人和改变世界的重大事件。另外书的译者舒昌善先生有着和茨威格类似的境遇，因此他的翻译很忠实于原意。</li>\n</ol>\n<h3 id=\"三、哲学类\"><a href=\"#三、哲学类\" class=\"headerlink\" title=\"三、哲学类\"></a>三、哲学类</h3><ol>\n<li>培根<strong>《培根随笔》</strong> ，这其实是他的散文集，文笔极其优美，而且充满哲理和智慧。培根也被美国国父杰斐逊认为是对他影响最大的三个英国作家之一，另外两个是洛克和牛顿。</li>\n<li>罗素<strong>《西方哲学史》</strong> ，这是一本能够系统了解哲学的好书。</li>\n<li>叔本华<strong>《人生智慧录》</strong> ，叔本华是在哲学上提出“意志”这个概念的哲学家，他的观点比较悲观，但是这本书却写得很好，能够帮助我们理解生活中很多困境的根源。</li>\n</ol>\n<h3 id=\"四、思维类\"><a href=\"#四、思维类\" class=\"headerlink\" title=\"四、思维类\"></a>四、思维类</h3><ol>\n<li>万维钢<strong>《万万没想到》</strong> ，可以帮你换一种思维方式——理工科的思维方式。对于文科生来讲尤其需要。</li>\n</ol>\n<h3 id=\"五、科学类\"><a href=\"#五、科学类\" class=\"headerlink\" title=\"五、科学类\"></a>五、科学类</h3><ol>\n<li>霍金<strong>《时间简史》</strong> ，物理学大师最畅销的科普读物，介绍了我们宇宙的来龙去脉，可读性很强。</li>\n<li>伽莫夫<strong>《从一到无穷大》</strong> ，这是对我本人一生产生了重大影响的科普读物，我是通过它认识数学和物理学的，也是通过它理解科学的思维方式的。它的内容没什么新鲜的，大家在中学都学了，关键是沿着这位物理学大师的思路，学会一种科学的思维方法。</li>\n<li>温伯格<strong>《给世界的答案》</strong> ，诺贝尔奖获得者写的科学史，他从科学的诞生，写到了中世纪和近代的发展，最后讲到最近十几年的前沿科技成就。这本书的好处是容易阅读（但它并不是一本内容全面的科技史读物），对于十几岁的人来讲，容易阅读非常重要。第二点就是他将科学的思想贯穿到故事中了，因此通过这本书可以培养一些科学的素养。</li>\n</ol>\n<h3 id=\"六、经济类\"><a href=\"#六、经济类\" class=\"headerlink\" title=\"六、经济类\"></a>六、经济类</h3><ol>\n<li>戈登<strong>《伟大的博弈：华尔街金融帝国的崛起》</strong> ，这是一本介绍华尔街历史和世界金融史最权威的和可读性最强的书。<br>译者祁斌是我清华的学弟，在美国留过学，英语很好，虽然是理工科出身，拿的也是物理学博士，但后来在高盛长期任职，对金融非常精通。回国后在证监会和中国投资责任有限公司担任领导职务。这本书也成为了中国金融界领导的必读书。为了方便国内读者阅读，他在每一章前面加了很长的背景知识介绍，这是一般翻译书所没有的。</li>\n</ol>\n<p>上面这些书是推荐给中学生的，挑选的标准是我认为他们读完之后在大学能够进步比较快，而且我在挑选时，尽量不选太难懂的。<br>其实还有很多好书，甚至更好的书，它们或者不急于在上大学前读完，或者需要一些背景知识，比如<strong>《史记》《神曲》《领袖们》《漫步华尔街》</strong> 等，因此都没有列入。<br>欢迎你把这张书单分享给适龄的学生朋友和他们的家长。<br>祝读书愉快</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"通信中使用最多的算法——维特比算法","url":"/2018/08/13/thinking/google-methodology-20180813/","content":"<p>今天和明天我们说一个传奇的算法、它背后那个传奇的人，以及那个传奇的人背后传奇的公司。<br><a id=\"more\"></a><br>我们要谈的这个人叫做安德鲁·维特比（Andrew Viterbi），你可能没有听说过他，因为通信行业之外的人知道他的并不多。不过你在媒体上应该经常看到对他所创建的高通公司（Qualcomm）的报道。</p>\n<p>另外，通信行业的科技人员，如果不知道这个名字，要么赶快恶补一下通信技术的常识，要么就不用在这个行业混了，因为今天通信中使用最广泛的算法维特比算法（Viterbi Algorithm）就是他发明，并以他的名字命名的。</p>\n<p>今天我们就先说说这个算法，这是我见到的最精妙的算法之一。<strong>它把现代数字通信中的解码复杂度降低了万亿倍，甚至更多</strong>。没有这个算法，你今天的手机打不了电话，你的计算机的硬盘无法工作。当然，什么语音识别，机器翻译等等，也无法完成了。</p>\n<p>言归正传，下面我们就讲讲让作为科学家的维特比得以成名的这个算法。为了便于你理解算法，我还是用一个你比较熟悉的例子来解释，而不是维特比最初解决的通信问题。</p>\n<p>经过我多次对语音识别的解释，你对此相对比较熟悉了，我们今天就从这里入手讲。</p>\n<p>语音识别基本上分为三步，<strong>第一步是对声波进行信号处理，得到一些语音特征；第二步是通过语音特征，识别出相应的音节；第三步是根据音节，合成出完整的语句</strong>。我们今天就讲从第二步到第三步的过程。为了简化问题，我们假定第一步和第二步都是完美的，也就是说识别出的音节是100%正确的。当然在现实的各种识别系统中，能做到70%的单个音节识别率就非常好了。事实上我们人的识别率也就是这个水平，我们人之所以能够听清楚完整的句子，完全靠的是对上下文的理解，而非音节识别得准。</p>\n<p>在汉语中，即使知道了读音，也就是我们小学学的拼音，要找到准确的对应的汉字还有一些困难，因为汉语中平均一个读音对应十几个汉字，即使你的四声读音非常准，耳朵也听得非常准（南方人其实常常做不到这一点），<strong>一个标上了四声声调的读音也对应了六个国标汉字</strong>。如果考虑到朱镕基的&quot;镕&quot;字还不在国标里面，对应的汉字数量就更多了。我在写给你的第113封信中讲，汉语是一个二义性或者说歧义性非常强的语言，一个表现就在一音多字上。</p>\n<p><strong>一音多字这个问题，在语音识别上会产生指数爆炸的灾难性后果</strong>。比如一个音对应6个字，从理论上讲，两个音的组合就可能对应36个字的组合，一个长度只有十个字的短句子，10个拼音所对应的全部汉字串，能组合出6的十次方，也就是6000万种可能性。如果句子更长，组合数还会快速增长。</p>\n<p>当然，可能有人会说考虑到一些字会组成常用的词，那么情况并不会这么糟糕。这种考虑在语音识别中的确是需要的，通过这种精简，可以大大减少排列组合的数量。但是，即使每一两个拼音，只对应少数几个单字词或者双字词，当句子稍微长一点，组合数量还是大得惊人。我们假定在考虑了组词之后每个拼音平均对应两个字，10个音节（拼音）可能的组合只有一千多种，比6000万种好了很多，但是，如果一句话的长度到了20个音节，可能的组合数量又达到了百万种。语音识别其实是一个任务，就是需要在这上百万的候选中找到最合理、最可能的语句。</p>\n<p>上述问题在通信中也会遇到，是一个标准的解码问题，那么怎么解决这个问题呢？将一百万种可能性一一评估显然不是一个好办法。对此维特比想到了一个特别妙的解码办法。为了比较清楚地说明问题，我把一句话的拼音和相应的汉字，做一个编号，按照下面的方式放到一张表中。</p>\n<p>假如一个句子有20个音节，每个音节可能对应6个字，那么我们就用一个长为20，深度为6的网格将每个可能的字填入其中。</p>\n<p>由于一个句子的音节按顺序从头到尾构成一个时间序列，因此，为了便于描述，我们用t表示音节的时间次序，将第一个音节标记为时间t＝1，最后一个音节标记为时间t＝20。</p>\n<p>接下来，我们把每一个音节可以对应的汉字填入到相应的那一列的六个网格中，并且从1到6挨个标记。比如第一个音节对应的字，编号就是从W11，W12，到W16，第二个拼音对应的字，编号为W21，W22，到W26。编号中第一个数字是时间t，后一个数字是某个拼音所对应的六个候选汉字的序号。因此，到了最后一个拼音，即t＝20，相应的字就是W201，W202，到W206。在下面的表格中，我填入了第一个音和第六个音的情况。</p>\n<p>所谓的解码就是在这样的网格中，找一条从t＝1到t＝20的路径，路径中经过的点，就是方格中的一个个字，比如W13，W24，到W201，等等。下图给出了一条路径。当然，对于一个20个音节的句子，这样的路径有三千六百万亿条。<strong>解码的过程就是找到一条最合理的路径的过程，我们把它称为寻找最佳路径</strong>。</p>\n<p><img data-src=\"/images/google-methodology-20180813/1.png\" alt=\"\"></p>\n<p>对于这样路径密密麻麻的网格，维特比注意到这样一个现象：<strong>不论有多少条路径，最佳的那一条路径在某个特定时刻，只有六种可能</strong>。比如在t＝6（也就是第六个音节）的时刻，必须经过W61，W62，W63......W66，这六个字中的一个。这样一来在第六个音节之前不论有多少条路径，真正有可能是最佳路径的候选路径，只可能有六条候选。</p>\n<p>接下来，进入到第七个音节，由于这个音节也对应了6个汉字，和前面六条路径组合出6x6=36种可能性。但是，由于在第七个音节处，最佳的路径也只可能有六种（和t＝6的情况一样）。因此，我们只需要对第七个音节的六个候选，W71，W72，W73......W76，每个候选保留一个最佳路径即可，这样一共也是六条。</p>\n<p>以此类推，在每个时刻，我们只需要保留六条路径，将这个步骤一直走到t＝20最后的时刻。如果对于上述内容你一时难以理解，也没有关系，只要记住，<strong>在任何时刻，只要保留六条路径就好</strong>。</p>\n<p>这种算法是维特比最早发明的，因此被称为维特比算法。对于20个音节，每个音节有6个候选字这种情况，<strong>维特比算法将复杂度从6的20次方，即3600万亿，减少到6x6x20=720次，足足减少了20万亿倍</strong>。即使考虑到采用了合理的组词，将每个拼音的候选字限制在两个，那么<strong>维特比算法也可以将复杂度从1百万次计算，减少到2x2x20=80次，减少了10000倍</strong>。</p>\n<p>当然，当年维特比要解决的并不是汉语中一音多字的问题，而是通信传输中的纠错解码问题。在数字通信中，0可能在传输中被误传输成了1，1可能变成了0，在解码时，即使看到了1，也要考虑它有一个很小的可能性是0被传输错了产生的，这样一来，一个长度为N的信息串，就会有2的N次方种可能性。</p>\n<p>听说过印度国际象棋故事的朋友一定清楚当N很大时，这个数字有多大。对于这样的解码，就要用到维特比上面的算法了。维特比算法从本质上讲，是把一种指数复杂度的问题，变成了线性的复杂度。这可能是所有的计算机算法中复杂度下降最大的改进。今天，<strong>除了语音识别、机器翻译、拼音转汉字、汉语的分词等用到了维特比算法，各种语言的拼写纠错，基因的测序，通信的解码都要用到它</strong>。</p>\n<p>维特比是在上个世纪60年代发明了这个快速算法，并且凭借它，奠定了自己在数字通信中不可替代的地位。但是，维特比并不满足于停留在算法本身，而是努力将它推广出去。</p>\n<p>为此，维特比做了两件事：<strong>首先，他放弃了这个算法的专利</strong>，这使得该算法得以在整个通信领域普及；第二，他和雅各布博士一起在1968年创办了林卡比特（Linkabit） 公司，<strong>将这个算法做成芯片，卖给其他通信公司</strong>，这样他也就保证了自己的经济收益。到这一步维特比已经比一般的科学家走得远很多了，但是，这仅仅是维特比辉煌人生的第一步。</p>\n<p>作为企业家的维特比有什么过人之处，我们明天再讲。</p>\n<blockquote>\n<p>思考题：维特比算法是一个很了不起的算法。通常人们为了推广自己的成果选择将技术公开，但是维特比又通过直接做芯片的方式挣钱维持了自己的利益，这对你有什么启发？</p>\n</blockquote>\n<p>祝近安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"Facebook和Google之争的本质是什么？","url":"/2018/08/22/thinking/google-methodology-20180822/","content":"<p>我们这周介绍了Facebook的成败得失，今天讲一个很多人感兴趣却常常困惑的话题，两个不同的公司彼此竞争，其焦点会是什么，本质是怎么一回事？了解了它们，也就了解了我们这个时代商业和技术的本质。我们就用Facebook和Google的竞争来说明。<br><a id=\"more\"></a></p>\n<p>我在之前的很多封来信中说过，几乎所有公司的创始人和管理者都必须明白，<strong>公司要想发展，就要提供给用户所需要的产品或服务，而不能靠烧钱获得用户</strong>。因此好的创始人总是挖空心思研究用户到底需要什么。当然他们可能会猜对，然后就获得成功，否则一定是失败，这就是尽人事，听天命。</p>\n<p>然而Facebook完全不同，它超越了这个层次，进入到一个更高的层次，只是为大众提供一个平台，用帕克的话讲，Facebook其实不必知道用户想在Facebook上做什么，只需要让用户感到酷。至于在这个平台上用户需要什么，他们自己去开发。这样，Facebook就不用承担任何产品决策错误的风险，而是一门心思专注于把这个平台做酷、做好。</p>\n<p>到2010年，为Facebook提供服务的各种软件技术人员多达上百万，他们在短短的几年里，为Facebook提供了55万种大大小小的服务，使得Facebook成为世界上人数最多、成长最快的虚拟世界，而这个虚拟世界又和互联网用户的真实世界相对应。随着云计算的兴起，在互联网上使用软件逐渐成为一种趋势，用软盘和光盘安装软件，或者下载安装软件逐渐成为了过去时。<strong>在这样的背景下，谁拥有了一个给大家发布软件的平台，谁就拥有了IT时代的主导权</strong>。关于这一点我在8月3日《为什么苹果能值1万亿》中分析过。相比之前的社交网络，Facebook了不起的地方在于超越了社交本身，把它变成像操作系统一样大家离不开的IT平台。</p>\n<p>那么为什么是Facebook，而不是之前的社交网络做到了这一点呢？简单地讲，它具有两个其他社交网站不具备的优势。</p>\n<p>首先，Facebook早期核心的用户群体是大学生，特别是一群对技术敏感的大学生，虽然他们来到这个网站的目的是交友，但是他们有兴趣分享自己创造的内容，包括自己开发的小程序。相比之下，无论是社交网络的先驱Friendster，还是互联网2.0时代的社交网络MySpace和Google旗下的Orkut，用户的层次都太低端，不可能开发和分享应用程序。事实上，在Facebook平台上开发程序的大部分都是大学生，此外就是创业公司的人。</p>\n<p>其次，Facebook早期为了共享信息，允许朋友之间共享账号，甚至共享密码，这引起了巨大的信息安全隐患，但是另一方面，也让Facebook因此开发出一套为第三方服务提供登录的技术。在互联网上，账户管理并非一件容易的事情，它需要很强的信息安全水平，否则账户很容易被攻破，一般小公司其实没有这种技术能力自己管理那么多用户账户。现在，Facebook提供了一种简单而相对安全的登录和账户管理方法给那些小网站使用，于是诸多小网站便开始通过Facebook的账户为用户提供服务，比如Zynga这样的游戏公司。这种方式，后来被很多大公司，包括很多电商接受，它们也将用户登录交给了Facebook管理。而再往后，腾讯、新浪等公司也学习了这种做法。今天，通过微信登录、微博登录或者QQ登录，最初的思想都来源于Facebook。</p>\n<p>掌握了用户的登录权限，就掌握了大量的用户，而且能了解他们在网上的行为，这是Google、雅虎和微软等各大互联网公司都害怕的。Google在Facebook诞生的早期还觉得它的用户都是大学生，等他们毕业后就会离开Facebook。但是，由于Facebook的用户一旦使用了它作为进入各种需登录网站的入口，对它的依赖就非常强，所以他们虽然毕业了，依然在使用Facebook，因此，Google在意识到这一点之后，就开始发展Orkut之外的社交网络，以免用户都被Facebook抢走。</p>\n<p>从2009年起，Google开始把Facebook作为最危险的竞争对手对待，并且试图在对方的地盘上竞争。事实证明，Google不仅在对人与人通信的理解上不如对方，而且在法律的边界打擦边球的勇气也远不如对方，因此直到2012年，Google在这方面的努力都是失败的。</p>\n<p>在这中间，Google推出了一款非常成功的基于移动互联网的社交工具Google Buzz，它不仅无缝对接Google自己的常用服务，包括Gmail、YouTube和地图等，而且还把当时最流行的第三方社交工具，比如分享图片和视频的Flickr、分享消息的推特等等，都集成进去了。它也像Facebook一样可以通过Google的账号登录那些服务，而且它是一款移动终端优先的社交工具，这个理念在当时领先于Facebook。但是Google Buzz只运营了一年多的时间就下架了，因为它带来太多对个人隐私的担忧。</p>\n<p>事实上，这些担忧，比如使用者的位置，一部分社会关系网络，和今天移动互联网泄露出的个人隐私（包括出卖给第三方）相比不值一提。Google对外界的评论总是过于介意，而在它十岁之后，聚集了越来越多的站在制高点的批评者，而不是愿意承担责任的实干家。</p>\n<p>Google每上线一个服务，都要事先考虑社会上各种潜在的负面意见，以至于大部分和社交网络相关的项目都胎死腹中。而Facebook则更具有锐气，它会直接拿市场来检验自己的产品，反馈好就保留，不好就终止。在这样的环境下，Google很快终止了Buzz服务，而后来Facebook的移动版本则包含了几乎所有Buzz中受欢迎的功能。</p>\n<p>到2011年，拉里∙佩奇终于意识到Google的基因和文化是无法开发出受欢迎的社交网络产品的，于是力排众议，支持来自微软的维克∙冈多特拉（Vic Gundotra）另起炉灶，用比Facebook更极端的方式向Facebook开战。</p>\n<p>根据我和冈多特拉的几次接触，有两点非常深刻的体会。首先是他的执行力和为达目的不择手段的工作热情非常难能可贵，其次他的工作作风和Google的文化格格不入。2012年我准备离开腾讯回美国时，冈多特拉和尤斯塔斯都向我伸出橄榄枝，但是在和他们几次交流以后，我在佩服冈多特拉之余，还是觉得他太不Google了，于是决定回到尤斯塔斯的麾下。冈多特拉的优点让他在短时间里开发出Google＋这一款还算有意义的社交产品，但他的做事风格让他和其他高管格格不入，并于2014年离开了Google。</p>\n<p>Google＋是Google在社交网络上应对Facebook的最后一次努力，这一次依然以失败告终，虽然败相不算太难看，因为它在大约一年多的时间里遏制了Facebook不可阻挡的发展势头。<strong>这一年多的时间非常宝贵，让Google得以建立起基于安卓手机操作系统的应用软件生态链，从而抵消了Facebook作为唯一的互联网软件平台的可能性</strong>。今天，Google安卓App商店中的应用程序要比Facebook上的多得多，两家公司终于可以在各自的市场上挣自己的钱了。</p>\n<p><strong>成功遏制了Facebook发展势头的另一家互联网公司是亚马逊，它通过自己的云计算平台给企业级的用户提供第三方的软件服务</strong>。正如我们在前面介绍云计算时所讲，进入到本世纪第二个十年之后，通过云计算提供企业级的软件和服务成为一种不可阻挡的趋势，而世界软件和IT服务市场的规模在今天依然比互联网大很多。因此，亚马逊在抢到了这一块市场之后，实际上就抢到了最值钱的用户。相比Facebook以量取胜，亚马逊是以质取胜。<br>概括来讲，<strong>在个人电脑时代，微软的操作系统几乎是唯一能够发布软件的平台，因此它统治整个IT行业十多年。在此之后，在互联网的时代，出现了三个可以发布软件的平台，即以Google和苹果为代表的移动互联网平台，以Facebook社交网络为代表的互联网2.0平台，以及以亚马逊云计算为代表的企业级平台</strong>。这四家公司和上一代霸主微软一道，构成了统治今天IT行业的五个巨头，在很长的时间里，它们是全世界市值最高的五家公司。</p>\n<p>上述公司能够占领行业制高点，而又很难侵入对方的地盘，在很大程度上是由它们的基因决定的。</p>\n<p>Facebook和Google之争，从本质上反映出两种整合信息方式的区别。Google是一家信息处理公司，擅长于用算法处理信息，这让它在搜索以及后来人工智能领域执牛耳。</p>\n<p>Facebook是一家通信公司，善于理解人们沟通中的需求，因此它实际上是靠人的关系整理信息。Facebook里的点赞功能（Like）和跟随功能，实际上是用户意见的反映，以及用户对那些他们认为可信赖的人的追随。信息既可以通过算法选取，通过算法过滤，也可以通过用户投票选取，通过那些我们信得过的人推荐而过滤。很多时候算法不能解决问题，社交网络的作用就体现出来了。</p>\n<p>类似地，中国的百度是一个信息处理公司，腾讯是一个通信公司，双方都想侵入对方的领地，但是都没有相应的基因。于是楚河汉界就这么划定了。</p>\n<p>亚马逊和Facebook之争，从本质上讲，反映出两种商业模式的区别，即优先企业级客户和优先个人用户。按照中国IT行业的俗语，就是2B和2C之争。亚马逊从一开始就为商家提供服务，有所谓2B的基因，而Facebook一开始就为个人服务，有2C的基因。最终大家找到了各自的边界。近年来虽然这些公司之间的竞争依然存在，但是基本上都是在自己的地盘上发展。<br>总结一下今天的内容：</p>\n<ol>\n<li>商业最高的境界是像太史公在《货殖列传》中说的，“<strong>善者因之，其次顺之</strong>”，关于这些内容大家可以阅读我的《见识》一书。Facebook就做到了“因之”。</li>\n<li>每家优秀的公司都必须有明确的基因，守住自己的基本盘。今天世界上市值最大的五家公司都是如此。同理，优秀的人也需要具有特有的绝活。</li>\n<li>今天我们很多业务，本质上都是围绕着整理和处理信息展开的，把握住一条，就把握了时代产业的脉络。</li>\n</ol>\n<p>明天是加餐，我会给你一些惊喜！</p>\n<p>祝近安</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"我们面临的世界和我们的对策（下）","url":"/2018/12/11/thinking/google-methodology-20181211/","content":"<p>这一讲我接着昨天的话题，谈谈在当下和未来我们该怎么办。我还是沿用上一讲的顺序编号。<br><a id=\"more\"></a></p>\n<h3 id=\"五、善用摩尔定律。\"><a href=\"#五、善用摩尔定律。\" class=\"headerlink\" title=\"五、善用摩尔定律。\"></a>五、善用摩尔定律。</h3><p>在考虑怎么办之前我们自然需要先看清楚信息时代的规律，理解我们这个时代各种现象的成因。</p>\n<p>要说信息时代的规律性，大家最熟悉的莫过于<strong>摩尔定律</strong>了。因为它已经被大家所熟知，因此我在两年的专栏中都没有专门去讲它。不过它实在太重要，我们今天想要生活好，就必须利用它。</p>\n<p>摩尔定律对于大家的好处很容易理解，每过一段时间，我们就能用到更便宜、更好的产品了，这是人类有史以来最爽的事情，因为在此之前大家总是抱怨东西涨价。</p>\n<p>但是从另一个角度讲，厂家就悲催了，因为如果它生产和制造同样的东西，18个月后收入就降了一半。这种从反面看摩尔定律的表述方式是Google前CEO施密特博士提出来的，因此也就叫反摩尔定律。</p>\n<p>反摩尔定律让IT行业变成了青春饭，因为大部分从业者只有两个结局——要么你的进步速度比摩尔定律更快，这样你会很累，很难干到老。要么干几年后赶不上同行的进度，不得不离开。不论是哪一种，都是青春饭。</p>\n<p><strong>至于怎么破局，我在一个周末的问答中回答了这个问题，简单讲，就是能力的增长要快过年纪的增长。</strong> 在IT行业中，对于制作硬件的公司，摩尔定律的负面效果更明显，因为它让利润率变得越来越薄，直到企业关门。</p>\n<p>施密特到Google之前是著名的计算机工作站和服务器公司太阳微系统公司的CTO，看到太阳公司的业绩一年不如一年，感叹人再有办法也拗不过规律，才讲出了反摩尔定律。</p>\n<p>但是对个人来讲，从事硬件的个人反而不容易被淘汰，因为经验在这个行业里很重要。相比之下，单纯从事软件工作的人，很容易被淘汰。</p>\n<p>由于反摩尔定律的影响，我们投资时对于那些硬件制造的企业都非常谨慎，因为它们即使成功了，好日子也没有几年。这两年智能设备、IoT都很热门，我虽然看好它们的前景，但是几乎没有投资制造智能设备硬件的公司，也没有投资IoT设备的公司，因为受摩尔定律的影响，它们的利润会越来越薄。</p>\n<p>但是，也有人利用摩尔定律，让自己的利润不断增加，小米公司就是一个很好的例子。小米从一开始推出手机时，就让手机的绝对价格便宜得不可思议，因为把那些元器件的价钱加起来就发现它毫无利润可言。</p>\n<p>但是小米居然生存了下来，而且毛利率还不算太低。它是怎么做到的呢？有人说是靠卖配件，其实配件的利润虽然厚，但是因为种类太多太杂，难以形成手机那样的规模效应。如果手机本身赔很多钱，后来的增值服务和配件再挣钱也不补上手机的窟窿。</p>\n<p><strong>小米低价格销售的秘诀其实在于反向使用了摩尔定律。</strong> 它推出手机时采用预订的策略，你看到的价格是今天的价格，你对比手机的配置也是按照今天市场上的手机去对比的。但是它交货常常是半年之后，这中间有时间差，半年后由于摩尔定律的作用，那时元器件的价格其实已经不是你今天看到的了。</p>\n<p>因此，你觉得你赚了，是以今天的性价比衡量的，而你半年后拿到同样性价比的东西，其实那时再仔细算算，性价比就没有那么诱人了。类似地，今天大多数台湾硬件厂家都要靠这种方式挣钱生存。这就是善用信息时代规律的正面案例。</p>\n<p><strong>对于一个时代不可改变的规律，有的人看到的是困难，有的人看到的是机会，规律还是那个规律，怎样使用就是每一个人自己的事情了。</strong> 我们的课程是告诉大家这些规律，给大家一些好的例子作参考。</p>\n<h3 id=\"六、安迪－比尔定律。\"><a href=\"#六、安迪－比尔定律。\" class=\"headerlink\" title=\"六、安迪－比尔定律。\"></a>六、安迪－比尔定律。</h3><p>今天的人每一两年就要换一部手机，这倒不完全是为了赶时髦，炫酷，而是因为一两年后你的手机就慢得用不了了。但是你们家的固定电话没这个问题，冰箱、汽车也没有这个问题。为什么单单手机（和之前的电脑）有这个问题？</p>\n<p>原因很简单，因为不断更新的软件越来越慢，吃掉了你的手机硬件性能的提升。这在IT产业中，被称为安迪－比尔定律。</p>\n<p>安迪是英特尔公司原CEO安迪·格鲁夫，比尔就是大家熟知的微软公司创始人比尔·盖茨。安迪－比尔定律原来的表述是“<strong>安迪所给你的，比尔将它们拿走</strong>”。也就是说，英特尔等公司按照摩尔定律提升的硬件性能，都被以微软为代表的软件公司消耗掉了，使得你不得不去买新的硬件。</p>\n<p>从2007年iPhone第一代诞生至今，iPhone已经有了10代，今天iPhone X系列（包括XS等）的速度大约是当年iPhone的100倍，正好平均18个月翻一番。但是，你使用各种App，感觉速度还是和以前差不多。而且，过去一个App就占用几百K空间，今天它们动不动就要几十兆字节。</p>\n<p>如果你还保留着最早的iPhone，你会发现今天的什么软件它都运行不了。这种现象，不是今天才有，在PC时代就是如此。乍一看像是微软等公司在和大家作对。实际上，只有通过这种方式才能维系整个IT产业的不断扩大。这是安迪－比尔定律带来的第一个结果。</p>\n<p>安迪－比尔定律的第二个结果就是创造出一个紧耦合的IT生态系统。首先，软件开发商（比如Google、腾讯、美图秀秀）吃掉硬件提升带来的全部好处，迫使用户更新硬件，让当年惠普、戴尔、联想等PC公司受益，以及华为、小米、三星等手机公司获益。</p>\n<p>然后，这些PC整机厂商和手机公司再向英特尔、高通、三星、东芝这样的半导体公司订购新的芯片，同时向LG、三星、京东方等外设厂商购买新的外设。在这中间，各家的利润先后得到相应的提升，股票也随之增长。</p>\n<p>如果新的软件开发的速度跟不上，不仅它们的业绩不好，而且要影响大家购买新的硬件的欲望，进而影响到元器件设备厂商。这样，整个IT行业的生态系统就形成了。</p>\n<p>在这个生态系统中有一个例外，就是苹果公司，因为它的软硬件是自己一起做。这样的好处是当它的产品比较受欢迎时，它的利润率很高。但是当它遇到问题时，整个行业没有什么企业愿意帮助它，因为它不是产业链中必不可少的一环。关于这一点我在之前的来信和《浪潮之巅》一书中都详细分析过。</p>\n<p>安迪－比尔定律的第三个结果就是软件企业在IT行业中的重要性越来越高，硬件企业相对下降。在PC的时代，软件企业利润率高，但是硬件企业产值高，如果你从公司的市值来看，彼此不相上下。</p>\n<p>今天，软件企业无论是产值还是利润都远高于硬件企业。很多人总是要计算iPhone手机元器件的成本，来证明它是一家暴利企业。实际上只有过去的硬件企业才用元器件成本计算毛利率呢，苹果根本没有把自己定位成硬件厂商，而更多地是把自己定位成软件企业。</p>\n<p>在过去的十多年里，你经常会看到软件企业并购硬件企业的案例，比如Google收购摩托罗拉，微软收购诺基亚的手机部门。更早以前，软件公司是不做这样的收购的，因为硬件公司很高的产值，很低的利润会让软件公司的报表非常难看。今天，由于软件公司的营业额很高，因此不担心硬件公司的低利润会影响到它整体的利润率。</p>\n<p><strong>从整个行业来看，越往后软件越重要</strong>。因此，你如果是IT的从业人员，一定要记住这一条。如果你是其它行业的从业者，要注意未来无形资产比有形资产更重要。</p>\n<h3 id=\"七、李嘉图定律。\"><a href=\"#七、李嘉图定律。\" class=\"headerlink\" title=\"七、李嘉图定律。\"></a>七、李嘉图定律。</h3><p>这个定律我在第201封来信中专门讲了，罗老师在罗胖精选中也推荐过，这里就不再赘述了。我只简单地强调一下在未来，李嘉图定律所描绘的优质资源产生巨大溢价的现象会越来越明显，它们和普通资源的价差会越来越大。因此，在未来世界的行动指南应该是这样的——<strong>尽可能获取最优质的资源，同时让自己成为最优质的资源。</strong></p>\n<p><strong>IT时代的这些规律，都不是人为设定的，因此也不是人能够改变的，与其试图逃避它们，不如想想如何利用它们。</strong></p>\n<p>明天我要讲讲如何获得可重复性的成功，这方面的内容我不仅在过去的一年里经常讲到，而且我明年还要讲。</p>\n<p>祝 岁末愉快</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"如何不靠运气致富","url":"/2020/06/02/thinking/how-to-get-rich-without-luck/","content":"<p>原作者：Naval Ravikant<br>翻译&amp;注释：和菜头<br>不要以为这是鸡汤...如果你是一个有阅历的人，会读出其背后的内涵。<br><a id=\"more\"></a><br>Seek wealth, not money or status. Wealth is having assets that earn while you sleep. Money is how we transfer time and wealth. Status is your place in the social hierarchy.</p>\n<p>去寻求财富，而非金钱或地位。财富就是你拥有资产，而资产在你睡觉的时候都还在为你赚钱；金钱是我们转换时间和财富的工具；身份是你在社会等级体系里所处的位置。</p>\n<hr>\n<p>Understand that ethical wealth creation is possible. If you secretly despise wealth, it will elude you.</p>\n<p>要明白一件事：一个人完全可以不靠坑蒙拐骗站着赚取财富。如果你在暗中鄙视财富，那么财富也会躲着你。</p>\n<hr>\n<p>Ignore people playing status games. They gain status by attacking people playing wealth creation games.</p>\n<p>别去理会那些热衷于玩身份游戏的人，他们通过攻击那些创造财富的人以获得自己的身份。</p>\n<hr>\n<p>You’re not going to get rich renting out your time. You must own equity — a piece of a business — to gain your financial freedom.</p>\n<p>你不会通过出租自己的时间而变得富有。你必须拥有产权，也就是生意的一部分，以此才能赢得个人财务自由。</p>\n<hr>\n<p>You will get rich by giving society what it wants but does not yet know how to get. At scale.</p>\n<p>提供社会大众想要但是他们还不知道如何获取的东西，你就会因此而致富。但有一点：你必须规模化地供应社会。</p>\n<hr>\n<p>Pick an industry where you can play long term games with long term people.</p>\n<p>选择一个你可以长期从事的产业，寻找一批可以一起长期共事的人。</p>\n<hr>\n<p>The Internet has massively broadened the possible space of careers. Most people haven’t figured this out yet.</p>\n<p>互联网极大拓展了一个人职业生涯的可能性。绝大多数人对此毫无认知。</p>\n<hr>\n<p>Play iterated games. All the returns in life, whether in wealth, relationships, or knowledge, come from compound interest.</p>\n<p>玩就玩复利游戏。无论是财富，人际关系或者是知识，所有你人生里获得的回报，都来自复利。</p>\n<hr>\n<p>Pick business partners with high intelligence, energy, and, above all, integrity.</p>\n<p>在选择商业合作伙伴的时候，选择那些高智商、精力旺盛的家伙，但在这一切之上，他应该是个正直诚实的人。</p>\n<hr>\n<p>Don’t partner with cynics and pessimists. Their beliefs are self-fulfilling.</p>\n<p>不要和愤世嫉俗者和悲观主义者合作，因为他们会任由坏事发生，以此证明他们的负面看法是正确的。</p>\n<hr>\n<p>Learn to sell. Learn to build. If you can do both, you will be unstoppable.</p>\n<p>学会如何销售，学会如何创建。如果你同时能做到这两件事，你的成功将无可阻挡。</p>\n<hr>\n<p>Arm yourself with specific knowledge, accountability, and leverage.</p>\n<p>用独到知识，责任感和杠杆武装自己。</p>\n<hr>\n<p>Specific knowledge is knowledge that you cannot be trained for. If society can train you, it can train someone else, and replace you.</p>\n<p>独到知识是那种不可以通过培训而获得的知识。这是因为，如果这种知识可以经由培训而得，那么其他人同样也可以，并且以此取代你。</p>\n<hr>\n<p>Specific knowledge is found by pursuing your genuine curiosity and passion rather than whatever is hot right now.</p>\n<p>在真正的好奇心和热情驱使你前进的路上，你更有可能获得独到知识，而不是在追逐潮流热点的闻风起舞脚步里。</p>\n<hr>\n<p>Building specific knowledge will feel like play to you but will look like work to others.</p>\n<p>创建独到知识的过程对于你就像是在玩，而对于别人则像是工作。</p>\n<hr>\n<p>When specific knowledge is taught, it’s through apprenticeships, not schools.</p>\n<p>不能通过学校教育教会一个人独到知识，它只能通过学徒制口传身教。</p>\n<hr>\n<p>Specific knowledge is often highly technical or creative. It cannot be outsourced or automated.</p>\n<p>独到知识通常极富技术性和创造性，因此它不能被外包或自动实现。</p>\n<hr>\n<p>Embrace accountability, and take business risks under your own name. Society will reward you with responsibility, equity, and leverage.</p>\n<p>拥抱责任感，押上自己的声誉以承担商业风险。社会也会以责任，产权和杠杆作为回报。</p>\n<hr>\n<p>The most accountable people have singular, public, and risky brands: Oprah, Trump, Kanye, Elon.</p>\n<p>最具责任感的人都具有独一无二的、世人皆知的、敢于冒险的个性特征，如奥普拉、川普、坎耶、埃隆。</p>\n<hr>\n<p>“Give me a lever long enough, and a place to stand, and I will move the earth.” — Archimedes</p>\n<p>只要给我一根足够长的杠杆，一处可以立足的地方，我就能撬起地球。——阿基米德</p>\n<hr>\n<p>Fortunes require leverage. Business leverage comes from capital, people, and products with no marginal cost of replication (code and media).</p>\n<p>财富增长需要使用杠杆。商业杠杆有三个来源：1、资本；2、人力；3、复制起来边际成本为零的产品（如：代码和媒体）。</p>\n<hr>\n<p>Capital means money. To raise money, apply your specific knowledge, with accountability, and show resulting good judgment.</p>\n<p>资本的意思就是钱。想要融资，那就运用你的独到知识，配合你责任感，展示出你良好的判断力。</p>\n<hr>\n<p>Labor means people working for you. It’s the oldest and most fought-over form of leverage. Labor leverage will impress your parents, but don’t waste your life chasing it.</p>\n<p>人力指的就是为你干活的人，它是最古老也是争夺最激烈的杠杆。人力杠杆会让你父母因为你手下有许多人为你工作而感到骄傲，但你不要浪费生命去追求这一点。</p>\n<hr>\n<p>Capital and labor are permissioned leverage. Everyone is chasing capital, but someone has to give it to you. Everyone is trying to lead, but someone has to follow you.</p>\n<p>资本和劳动力是需要征得许可才能使用的杠杆。每个人都在追逐资本，但总得有个什么人给你才行；每个人都想要领导其它人，但总得有什么人愿意跟着你才行。</p>\n<hr>\n<p>Code and media are permissionless leverage. They’re the leverage behind the newly rich. You can create software and media that works for you while you sleep.</p>\n<p>代码和媒体是无需要许可即可使用的杠杆。它们是新贵人群背后的杠杆，你可以通过自己创建的软件和媒体，在睡觉时仍然为你干活。</p>\n<hr>\n<p>An army of robots is freely available — it’s just packed in data centers for heat and space efficiency. Use it.</p>\n<p>一支机器人军团已经集结待命，只是为了节约空间和热效能，它们被打包放进数据中心。去用吧。</p>\n<hr>\n<p>If you can’t code, write books and blogs, record videos and podcasts.</p>\n<p>如果你不会编程，那你还可以写书和博客，或者做视频或者音频节目。</p>\n<hr>\n<p>Leverage is a force multiplier for your judgement.</p>\n<p>杠杆能够成倍地放大你的判断力（所产生的效能）。</p>\n<hr>\n<p>Judgement requires experience, but can be built faster by learning foundational skills.</p>\n<p>判断力需要经验，但它可以通过学习基本技能的方法更快速地建立起来。</p>\n<hr>\n<p>There is no skill called “business.” Avoid business magazines and business classes.</p>\n<p>并不存在一种叫做“商业”的能力。尽量避开商业杂志和商业课程。</p>\n<hr>\n<p>Study microeconomics, game theory, psychology, persuasion, ethics, mathematics, and computers.</p>\n<p>去学习微观经济学、博弈论、心理学、说服术、伦理学、数学和计算机科学。</p>\n<hr>\n<p>Reading is faster than listening. Doing is faster than watching.</p>\n<p>读比听快，做比看快。</p>\n<hr>\n<p>You should be too busy to “do coffee,” while still keeping an uncluttered calendar.</p>\n<p>你应该忙得没有社交的时间才对，与此同时你应该始终保证日程安排井井有条。</p>\n<hr>\n<p>Set and enforce an aspirational personal hourly rate. If fixing a problem will save less than your hourly rate, ignore it. If outsourcing a task will cost less than your hourly rate, outsource it.</p>\n<p>你应该为自己设定一个有抱负的个人时薪数，并且坚持执行。如果解决一个问题所能节省下来的成本低于你的个人时薪，那就忽略这个问题好了；如果一项任务的外包成本低于你的个人时薪，就把它外包出去。</p>\n<hr>\n<p>Work as hard as you can. Even though who you work with and what you work on are more important than how hard you work.</p>\n<p>尽管你跟谁一起工作、做什么工作，要远比你的努力程度更加重要。但还是要倾尽全力去工作。</p>\n<hr>\n<p>Become the best in the world at what you do. Keep redefining what you do until this is true.</p>\n<p>你所做的事情，要努力做到世界最好。不断重新定义你在做什么，直到真的做到世界最好。</p>\n<hr>\n<p>There are no get rich quick schemes. That’s just someone else getting rich off you.</p>\n<p>这个世界上并没有快速赚钱致富的方法，如果你想要找寻这种方法，那它只会让别人从你身上赚钱致富。</p>\n<hr>\n<p>Apply specific knowledge, with leverage, and eventually you will get what you deserve.</p>\n<p>运用你的独到知识，配合上杠杆，最终你会得到你应该得到的东西。</p>\n<hr>\n<p>When you’re finally wealthy, you’ll realize that it wasn’t what you were seeking in the first place. But that’s for another day.</p>\n<p>终有一天当你变得富有，你会发现那一切并不是你最开始想要的东西。但是那就是另外一回事了。</p>\n<hr>\n<p>注释：</p>\n<p>1、财富就是你睡着觉，你的资产也在为你继续赚钱。这是一个越来越被广泛接受的定义。Naval Ravikant是硅谷狂热的数字货币支持者，所以，他的话另有所指。从前后文来看，他所谓的资产并不等于是传统意义上的房产、股票、收藏，而是偏向于他反复提及的：软件和媒体。</p>\n<p>2、出租时间概念，许多人理解为打工，认为打工就是出租自己的时间以换取金钱。其实并非如此，Naval所指的出租时间概念，指的是一个人的财富增长，是否直接关系到他的时间。一个小卖部的老板，他并不为谁打工，但是他的财富增长需要他长时间守在店里，因此，他依然是出租时间换钱。但一个淘宝点卡店老板则不同，他的点卡销售是全自动的，不需要24小时守着，而且也不需要只做这一样生意。这就是Naval所谓互联网拓宽了个人职业生涯的一个例子。</p>\n<p>3、equity我翻译为产权，不是一个很好的翻法。但是Naval前文提到assets，很明显，作为投资人他非常清楚地知道这两个字眼之间的区别。equity无论是翻译为股票、权益或者是资产，原文说“ You must own equity — a piece of a business — to gain your financial freedom.”，这是和出租时间概念做对应的。出租时间的人，在商业链条里作为生产资料出现，不拥有任何产权，也就无法通过商业行为获利，所以，我这里勉强翻译为产权。</p>\n<p>4、specific knowledge我翻译为独到知识，没有翻译为特定知识、专业知识或者是特殊知识。原因是在我的理解中，specific knowledge不是书本知识，也不是学校教授的知识，更不可能在网上免费获取。一方面，它只能提供自己实践来获取；另一方面，它只能通过前人口耳相传。这种知识是做成一件事情的关键，属于知识体系中不共的那一部分。所以，我翻译为独到知识。</p>\n<p>5、“Give me a lever long enough, and a place to stand, and I will move the earth.” — Archimedes 这话不像是阿基米德说的。更像是一次抬杠的结果：</p>\n<p>“给我一个支点，我就能撬起地球！”</p>\n<p>“那么，您站在哪儿呢？”</p>\n<p>“好吧，给我一个支点，再给我一个站立的地方，我就能撬起地球。”</p>\n<p>“那么，您用空气就能撬起地球了？”</p>\n<p>“好吧，给我一根足够长的杠杆，一处可以立足的地方，我就可以翘起地球！”</p>\n<p>“那么，阿基米德先生，支点又不需要了吗？”</p>\n<p>“滚！”</p>\n<p>6、accountability我本想翻译为“靠谱程度”，想想还是算了。</p>\n<p>7、号称是“四十条语录”，但是我就找见了39条。</p>\n<p>8、结合上下文看，Leverage一词始终翻译为“杠杆”其实也不大对头。Naval一再强调代码、博客、播客、视频节目，我觉得Leverage在他那里，有些时候应该相当于是个人影响力的代名词，或者可以简单理解为放大器。</p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"我为什么买理想","url":"/2023/04/17/thinking/lixiang/","content":"<p>从泡泡网，到汽车之家，再到理想汽车，创业难度越来越大。李想有着极强的成功欲望，再加上极强的学习能力，和做出用户喜欢的产品的热情。所以创业成功率很高。<br><a id=\"more\"></a><br>买股票就是买公司，买公司就是买公司未来现金流的折现。公司未来现金流取决于商业模式和企业文化的好坏。</p>\n<h3 id=\"第一部分，李想和他塑造的企业文化\"><a href=\"#第一部分，李想和他塑造的企业文化\" class=\"headerlink\" title=\"第一部分，李想和他塑造的企业文化\"></a>第一部分，李想和他塑造的企业文化</h3><p>从泡泡网，到汽车之家，再到理想汽车，创业难度越来越大。李想有着极强的成功欲望，再加上极强的学习能力，和做出用户喜欢的产品的热情。所以创业成功率很高。</p>\n<h4 id=\"学习能力\"><a href=\"#学习能力\" class=\"headerlink\" title=\"学习能力\"></a>学习能力</h4><p>深入研究很多公司。举几个例子：</p>\n<ul>\n<li>理想 L9 发布时，理想的产品总监张晓接受采访时谈到，他们会看苹果和特斯拉从成立以来每年做了哪些事，为什么做这些事，主要分析为什么在那个时间做这些事，来提升认知。</li>\n<li>懂的避开比亚迪和特斯拉的优势领域，直到 2024 才会进入 20-30w 市场。真正研究过比亚迪和特斯拉才知道这两个公司在成本控制上的能力。</li>\n<li>全方位学习苹果，从品牌广告、到发布会、到产品定义、到企业文化，全方位学习，很深的影响了理想的决策。</li>\n</ul>\n<p>和苹果相似的决策有：</p>\n<ul>\n<li>把以前普通用户够不着的技术，靠规模化卖一个普通用户够得着的价格。比如理想把百万豪华车才有的空气悬架、高端音响、电吸门、座椅通风加热按摩，做成标配。苹果把触摸屏、faceid、touchid 做成了普通人都可以用。</li>\n<li>靠增加产品力来提升销量，而不是靠降价。比拼体验，而不是比拼成本。销量=产品力/价格。苹果和理想提升销量靠提升产品力，特斯拉靠降低价格。</li>\n<li>爆款产品策略。iPhone 每年只做一款手机。理想 one 时候只有一款车，L 系列本质也是一款车，类似 iPhone、iPhone Pro、iPhone Max，虽然有多款，但大部分零部件都是复用的<br>企业文化相似，只做一流的产品。苹果不出低配手机，是因为苹果的企业文化是只想做最好的产品。理想也一样，不会出凑合的产品的，必须核心用户群最好的产品</li>\n</ul>\n<h4 id=\"产品能力\"><a href=\"#产品能力\" class=\"headerlink\" title=\"产品能力\"></a>产品能力</h4><p>产品经理对企业至关重要。好的产品经理能让企业资源聚焦，降低内耗提升效率，提升团队战斗的士气。</p>\n<p>依靠李想对用户痛点的理解，理想做出了大电池增程、六座、副驾驶屏幕等一系列的创新。也奠定了理想 one 和 L 系列成功的基础。依靠这些成功产品的经验，总结成一套成熟的方法论，强化认知，进一步提升做下一款产品的胜率。理想几乎做到每款产品都是爆款。</p>\n<p><strong>做产品首先是明确用户群。理想品牌成立之初就很明确要做家庭用户。</strong></p>\n<p>明确用户群后，就持续发现用户的真实需求和痛点，聚焦在用户使用体验上，持续做出用户喜欢的产品和功能。也因此塑造了理想公司的企业文化。</p>\n<p>通过反复传导企业文化，让入职的每个员工都知道理想在给谁做产品，怎么做产品。极大地降低了沟通成本和内耗，提升了做出好产品的概率。</p>\n<h3 id=\"第二部分，理想公司的竞争优势和护城河\"><a href=\"#第二部分，理想公司的竞争优势和护城河\" class=\"headerlink\" title=\"第二部分，理想公司的竞争优势和护城河\"></a>第二部分，理想公司的竞争优势和护城河</h3><h4 id=\"理想的竞争优势有哪些？\"><a href=\"#理想的竞争优势有哪些？\" class=\"headerlink\" title=\"理想的竞争优势有哪些？\"></a>理想的竞争优势有哪些？</h4><p>分别看下市面上的主要玩家</p>\n<p><strong>比亚迪</strong>，核心能力是电池自研和混动技术带来的成本优势。电池占了整车 50% 以上的成本，自己做电池，就能比其他主机厂获得更大的优势。混动技术 dmi 采用了最简单的单档位，成本上也最到了最优。以及过去二十年供应链经验，有很大的供应链深度。所以比亚迪核心优势是供应链和成本能力。但短板是品牌塑造、智能化，而这两个是理想的长板。</p>\n<p><strong>特斯拉</strong>，核心优势是制造效率。特斯拉在生产制造上的一系列颠覆式改进，包括：电子电气架构改造、一体化压铸、汽车四大工艺的改造，都极大的降低了成本和优化了生产效率。马斯克强调第一性原理，第一性原理优势主要体现在生产制造环节，内部形成了一套 <code>question - delete - simplify - accelerate - automate</code> 体系，对生产制造有极强的改造能力。马斯克也多次强调特斯拉核心能力是制造能力。</p>\n<p>对比理想，理想的人会思考每个座位的人的使用场景，比如给副驾驶的人按屏幕、给后排的孩子按屏幕、为了老人方便上下车，车辆停止时车辆高度会自动下降、每个座位标配座椅通风加热按摩、极好的 nvh 等等，可以看到两家公司是两套完全不同的做事逻辑。理想的做法毫无疑问用户体验是更好的。长期来看，特斯拉在豪华车领域的竞争力会不如理想。</p>\n<p>总结下就是，特斯拉和比亚迪是主要竞对，瞄准的是大众市场。理想和这两家竞争不大，理想瞄准的是豪华市场。</p>\n<p><strong>华为</strong>，华为在产品、技术、团队、渠道都具有极强的竞争力，会是理想最主要的竞争对手。华为每年的研发投入是一千多亿，理想不到一百亿，存在量级上差异。渠道数量也明显优于理想。理想目前在产品力上优于问界，但华为早晚会追上。团队能力两者相当，理想的企业文化和管理水平不比华为差。长期来看理想在豪华车领域的销量能做到和华为 1:1 就很好了。</p>\n<p><strong>小鹏</strong>，核心问题是技术导向的企业文化。<strong>理想是选定用户群，给用户群最好的产品</strong>。小鹏是我相信自动驾驶，所以我只关心技术，用户体验好不好不关心或者不重视。这也决定了小鹏的产品的胜率不高，P5 和 G9 就是例子，没有想清楚这些产品是给谁用的就推出来了。王凤英来了之后能补上这块短板，但企业文化是否有改观，要看何小鹏是否愿意改变。</p>\n<p><strong>蔚来</strong>，核心问题是企业不专注，高估自己的能力，摊子铺得太大。月销量不足 2 万就要自己做电池，还要自研手机。现在有 7 款车月销只有一万多（对比理想只有 2 款已经月销 2 万），很多车型月销只有几百，还要再做两个子品牌，团队资源分散，交付等管理问题频出。每年亏损一百多亿，看不到好转的迹象，将来结局可能不会太好。</p>\n<p>传统车企，产品力、组织效率、认知，全方位落后。国内的合资和外资企业未来几年应该都会出局，自主品牌（长安、吉利、长城）和比亚迪抢一部分市场。</p>\n<h4 id=\"理想公司的护城河是什么？\"><a href=\"#理想公司的护城河是什么？\" class=\"headerlink\" title=\"理想公司的护城河是什么？\"></a>理想公司的护城河是什么？</h4><p>这个问题想了很久，产品可以被抄，像华为可以很快推出 M7 对标理想 one。也没有技术壁垒，在前几年理想一直是蔚小理里面研发投入最少的。那护城河是什么？没有护城河，意味着将来不会有好的利润率。</p>\n<p>直到前段时间再看段永平的问答录，说道：<strong>企业文化是护城河的一部分</strong>。突然意识到理想的企业文化就是护城河的一部分。</p>\n<p>因为企业文化就是一个公司的做事习惯，这个是很难改的，也很难抄。改变一个人都很难，何况一个企业。所以即使现有产品被抄，但理想可以持续推出更好的产品保持体验上的领先。</p>\n<p>靠良好的利润率和销量表现，公司就能不断加大在研发上的投入，来提升竞争力。2022 年理想的研发投入已经超过小鹏。</p>\n<h3 id=\"第三部分，未来能赚多少钱\"><a href=\"#第三部分，未来能赚多少钱\" class=\"headerlink\" title=\"第三部分，未来能赚多少钱\"></a>第三部分，未来能赚多少钱</h3><p>未来能赚多少钱 = 未来能卖多少车 * 车均单价 * 净利率。</p>\n<p>2025 年能卖多少辆车？</p>\n<p>近几年数据，国内 20w 以上乘用车年销量大概 600 万。宝马年销量 80 万，奔驰年销量 80 万，奥迪年销量 60 万。BBA 一共 220 万的年销量，都是理想未来的空间。</p>\n<p>再看理想怎么打这块市场。</p>\n<p>理想的车型规划，基本已经明确。L 系列 5 款车，纯电系列 6 款车。</p>\n<p>还是爆款产品的思路，20w 到 50w 每五万放一款增程一款纯电车型，同价位产品力最强，内部目标是每个价位都要做到销量第一名。</p>\n<p>L9、L8、L7 基本都做到了每款月销过万。理想的思路是高端车型配置完全下放，零部件高度复用，靠规模化来降低成本。L9 的配置几乎原封不动的下放给 L8/L7，只是尺寸减小。将来 L8/L7 的配置也会下放给 L6/L5。所以 L9 成功后，L8/L7 也会成功，L6/L5 大概率也会成功。L6/L5 放在 20w-30w 市场，产品力会极具竞争力。因为价格越来越低，所以销量肯定会比之前的车型销量更高。L 系列五款车月销量预计能到 5-6w，年销量 60-70w。</p>\n<p>同理，纯电车型也是类似思路，预计在 2025 年能贡献 30w-40w 的年销量。</p>\n<p>加一起，预计 2025 年有 100w 的年销量。（理想公司内部的目标是 2025 年 160w 销量，常州、北京、重庆三地工厂的产能也是按这个目标准备）</p>\n<p>再看毛利率，特斯拉 2022 年 25% 的毛利率，15% 的净利率。比亚迪 2022 年也是 25% 以上的毛利率（包含经销商费用）。预计 2025 年理想也能做到 25% 的毛利率。2022 年理想是 20% 的毛利率。净利率长期来看应该能做到 10%。</p>\n<p>25 年卖 100 万辆车，均价 30w，净利率 10%，20 倍市盈率，大致是 1000 亿美金。</p>\n<p>现在市值 230 亿美金，预计有 4-5 倍的获益空间。</p>\n<h3 id=\"第四部分，未来\"><a href=\"#第四部分，未来\" class=\"headerlink\" title=\"第四部分，未来\"></a>第四部分，未来</h3><p>李想在春季媒体沟通会提到一个观点：<strong>AI 改造物理世界</strong>。</p>\n<p>举了个例子，汽车之家没做成汽车电商，是因为汽车交易 90% 都是发生在线下，只把交易搬到线上解决的问题很有限，所以没有成功。滴滴和 uber 市值不高，是因为最重要的从 A 到 B 点没有被优化，公司要想获利只能压榨司机的工资。</p>\n<h4 id=\"物理世界的问题只能通过-AI-来解决。\"><a href=\"#物理世界的问题只能通过-AI-来解决。\" class=\"headerlink\" title=\"物理世界的问题只能通过 AI 来解决。\"></a>物理世界的问题只能通过 AI 来解决。</h4><p>汽车公司第一层是<strong>卖车</strong>，第二层是<strong>出行服务</strong>，第三层是<strong>机器人业务</strong>。这条路是特斯拉走出来的，但对理想同样适用。所以公司对 AI 都极度重视。造车公司会是最大的 AI 公司。李想在媒体会说公司会 <code>all in ai</code>。</p>\n<p>自动驾驶普及后会改造两个行业：出行服务和物流配送。出行服务最大收益者是造车公司，自己搭个服务就可以运营了，滴滴和 uber 应该就不存在了。物流配送最大受益者会是美团，外卖和同城配送业务因为没有了配送成本会有巨大的利润释放。</p>\n<p>做自动驾驶的过程中，公司也会拥有通用 AI 能力。因为和自动驾驶的能力是通用的，都是感知、计算、预测。特斯拉 AI 机器人的突破在于机器人是可编程的，你可以在上面编写软件，想象力巨大。现在的机器人大多是垂直领域，但特斯拉机器人是通用的，会有巨大空间。</p>\n<p>王兴说，认为李想操盘的是 1000 亿美金的公司，低估了一个量级。大致是这个意思。</p>\n","categories":["thinking"],"tags":["note"]},{"title":"思维方式决定商业模式","url":"/2017/11/27/thinking/google-methodology-20171127/","content":"<p>小数字世界里人的想法和做事方法，一定是和小数字世界相适应的，而生活在大数世界里的人，做事的方法完全不同。<br><a id=\"more\"></a></p>\n<p>昨天我们讲到，生活在小数字世界里的人，天然地缺乏处理大数字世界里的问题的思维方式，无形之中将人们限制在天花板之下了。</p>\n<p>有人可能会问，从一万想象到一亿，这点想象空间我还是有的，真到了一个亿的情况，我也能处理。但是，事实常常和这个想象是相违背的，小数字世界里人的想法和做事方法，一定是和小数字世界相适应的，而生活在大数世界里的人，做事的方法完全不同。</p>\n<p>我在商学院给 MBA，特别是 EMBA 的学员讲课的时候，常常会对学员们做这样的调查：请有100双以上鞋子的女生举手，一般来说，MBA 的女学员中会有一半举手，而 EMBA 班这个比例则高达80%。然后我再让只有不到10双鞋子的学员举手，一般会有一些男生举手。</p>\n<p>接下来我就问这两组不同的人管理自己鞋子的方法。那些不到十双鞋的人都是将鞋子随意地放在一起，不需要管理，出门之前扫一眼，选择一双就好了。</p>\n<p>而那些超过一百双鞋的人，几乎无一例外地进行了分类管理，否则的话，出门前这一百多双鞋每一双花20秒钟考虑一下，将近一个小时就过去了，约会恐怕就要迟到。</p>\n<p>如果鞋子再多，该怎么办？恰巧有一次有一个学员是做网上代购生意的，做的品类有几百种，累计卖了近万双，对他来讲，简单分类已经不能够解决问题了，他必须对鞋子建索引。</p>\n<p>类似地，我的一个朋友藏书近万册，也需要对书籍建索引，找一本书的时候，先要从索引中找到那本书在第几排书架，第几个架子，第几层，然后到那一排去找书。</p>\n<p>从这两个例子可以看出两个要点：</p>\n<ol>\n<li>生活在不同世界里的人，习惯性的做事方法不同。</li>\n<li>从小数量总结出来的方法无法应用到更高量级的问题之上。</li>\n</ol>\n<p>遗憾的是，由于人类生活在量级较小的世界里，因此思考问题喜欢从1，2，3这样小的例子开始，这当然并不是什么缺点。但是很多时候他们把这种思路用到解决大问题之上，事情就做不好了。这种情况在 IT 人士中很常见。</p>\n<p>我曾经看到一位总监批评下面年轻的程序员，但是程序员似乎不服气，我就问他原因。这位总监讲，那个程序员居然在用一种很笨的排序方法，自己就去批评他，而程序员则狡辩说，总共参加排序的数目不大，只有个位数，采用什么排序方法时间上都差不多，他因为任务时间紧，就用了最容易编写程序的方法，他觉得总监是鸡蛋里面挑骨头。</p>\n<p>我对那个程序员讲，人生活在小数字世界里，难免保留固有的习惯，但是既然从事了计算机这个行业，就需要按照计算机这个行业的规矩办事，不能先验地假设数值一定不多。万一多了，笨办法增加的计算量可不止十倍、百倍，恐怕是千倍，甚至一万倍。不换这个思路，永远成为不了合格的电脑工程师。</p>\n<p>其次，在计算机这个世界里，几乎任何常见的问题都已经有了优化过的答案，作为从业者，首先要擅长使用专业人士给出的，验证了无数次的答案，而不是自己凭着生活经验拍脑袋想出一个做法。</p>\n<p>如果为了赶时间，应该采用现有的，高质量的代码，而不是自己写一个（关于这种工作方式，我以后还会再讲）。当然，了解别人已经写好的高质量代码，需要经常学习，而这是 IT 从业者要做的事情。</p>\n<p>因此，IT 从业人员遇到职业天花板的第一个原因是一开始思维方式就错了。像上面那位程序员，再努力写代码，恐怕几年后还是一个低水平的程序员。不克服我们先天认识上的局限性，就无法领会 IT 这个行业的精髓，当然事业也就做不上去。</p>\n<p>对于 IT 这个行业以外的人，不了解这一点，有时被新起来的技术公司搞死，还不知道自己是怎么死的。今天，无论是 IT 企业，还是非 IT 公司，对大小不敏感，对变化不敏感，最后导致商业失败的例子非常多。曾经辉煌过的雅虎公司和中国几大门户网站今天遇到的困境，就植根于此。</p>\n<p>互联网在早期内容不算多，因此通过分类建目录的方式组织信息是有效的，这就如同当人只有一百双鞋或者几百本书的时候的做事方式。于是就诞生了以雅虎为代表的、以分类目录组织信息的门户网站。</p>\n<p>而在人的世界里，增长是缓慢的，因此一个公司得到这种基因以后，会天然地认为这种做法可以持久。但是，在计算机的世界里，什么都是剧增的，网页数量从90年代初的几百万，增加到今天的几百亿，因此雅虎等门户网站很快就衰落了，代之以 Google 这样的搜索公司。</p>\n<p>类似地，在制作和传播新闻方面，20多年前大家是手工编辑，每天每一类新闻很少，就那么几条，编辑挑选，主编拍板就可以搞定了，那时我们生活在小数字世界，门户网站像报纸版面那样的首页新闻和这个世界是一致的。</p>\n<p>在互联网2.0时代之后，每一个人都能够产生新闻，我们面对的是一个大数字的世界，因此在这个时代，理解了计算机思维的今日头条就用了和门户网站完全不同的思维方式来解决新闻传播的问题。</p>\n<p>这时，新闻多得靠栏目分类已经无法解决了，今日头条不得不靠个性化筛选新闻。新闻门户网站的每况愈下和今日头条的兴起，实际上就是两种思维方式的对决。</p>\n<p>当然，你可能会说，我不在 IT 行业工作，在我的领域，并没有你说的大数问题，变化也不是特别快。但是，既然我们都生活在智能时代，IT 对各行各业的冲击就无法避免。</p>\n<p>以金融业为例，这个行业的工作曾经被誉为“金饭碗”，但是今天各大银行的营业网点都在萎缩，贷款也比以前难做了。原因很简单，过去每一笔贷款都是手工审批的，一个贷款主管一周也未必会贷出10笔，这里面经验很重要，而且经验的积累又是靠自己摸索，同行之间的交流其实很少。</p>\n<p>但是等到阿里巴巴的蚂蚁金服出现之后，剧增的数据量让贷款主管的经验变得无济于事。蚂蚁金服的成功之处在于，它一开始就面对一个巨大的世界，因此它解决问题的思维方式就和传统的银行不同。</p>\n<p>因此，虽然各大银行有着自己固有的优势，但是却越来越受到蚂蚁金服的威胁，业务难以成长。很多银行为了应对互联网带来的变局，几年前纷纷成立了自己的互联网银行，一些银行的负责人还找过我了解互联网背后的逻辑。</p>\n<p>但是，几年下来，这些大银行的互联网银行业务基本上没有什么进步，原因也很简单，在过去小数字世界里形成的固有思维限制了他们的发展。当然，我这里说的“小数”并不是说传统大银行的钱少，而是指业务人员每天接触的客户数相对较少。</p>\n<p>像刚才说的这种例子还有非常多。在传统的制药行业里，分析过上千人的病例和数据就很了不起了，但其结果是药品研制缓慢，而且很多处方药对大多数人来讲其实并没有什么用途。</p>\n<p>与这些传统制药公司所不同的是，利用 IT 技术解决医疗问题的人类长寿公司和 Google 的大数据医疗公司 Calico，从一开始就是把自己定义在大数世界里，它们采用的研究方法和传统的药厂就完全不同。</p>\n<p>今天，各大药厂都在和它们两家公司合作，试图用新的方法解决老办法解决不了的问题。可以讲，对数量大小的认知决定了商业模式，也决定了企业的成败。</p>\n<p>造成雅虎等公司，或者大银行困局的，原因并非雅虎的员工不如 Google 的努力，也并非银行系统的人没有阿里巴巴的人聪明，而在于思维方式不同。雅虎和大银行都没有领悟到 <strong>计算机思维</strong> 的真谛。</p>\n<p>很多人问我在智能时代是否要学习计算机编程，我倒不觉得这对大多数人有必要。在新时代，更重要和有益的恐怕是在思维上要提升，这样才容易成为新时代前2%的受益者。</p>\n<p>相反，即使学会了计算机编程，如果还是按照人固有的思维定式理解计算机问题，很快也会遇到天花板。当然，计算机思维和人的思维的差异远不止在大和小上，它们有很多差异，这些我在以后的来信中会和你继续讲。</p>\n<p>好了，昨天和今天的内容算是全年的开场白，在接下来的一年，我和你讲述的内容会比较聚焦，所有的来信都会围绕着智能时代的认知升级来展开。</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"职业天花板来自认识的局限性","url":"/2017/11/26/thinking/google-methodology-20171126-1/","content":"<p>智能时代，我们应该习惯用计算机思维看待问题，习惯生活在大数世界中，作为IT从业者更应这样。从大数世界看眼下的生活，仿佛是从《三体》中的四维世界看三维世界一样，一切都很小，很狭窄，很缓慢。<br><a id=\"more\"></a></p>\n<p>快到年底了，可能是回顾一年工作收获的时候了，不知道你这一年在职业发展中是否满意。如果你获得了晋升，或者有明显进步，那么恭喜你。</p>\n<p>如果你觉得没有达到年初的预想，甚至遇到了职业发展的天花板，也不用着急。我们提高了见识，找到正确做法以后，相信你明年会做得比现在更好。</p>\n<p>遇到职业天花板是一件常见的事情，大家不用大惊小怪。很多 IT 从业人士向我抱怨，说他们在社会上被人看不起，被谑称为“码农”，希望我作为一个计算机行业成功的从业者、技术专家，在各种场合呼吁提高他们的地位。</p>\n<p>应该讲，今天的世界离不开程序员，就如同我们离不开建筑工人一样，因此全社会应该尊敬他们。但是，很多程序员完成工作的水准，以及对自己的要求，还真有一点像是码农。</p>\n<p>更让他们烦心的是，IT 行业的从业者，用不了10年就遇到职业天花板了，以至于无论他们怎么自我提升，如何努力学习新技术，都摆脱不了码农的处境。一些人虽然通过换工作当上了一线经理，管着几个人，但是事业也就到头了，大的事情做不了，小的事情做着烦。</p>\n<p>刚才说的这种现象不仅在 IT 行业里很普遍，在其他很多行业中也是如此，包括过去被誉为金饭碗的银行业，现在可以说是每况愈下，很多人不要说提升了，保住饭碗都是问题。</p>\n<p>这些人的问题，并非我们呼吁提高他们的地位就会有作用，也不是简单的努力就能解决问题。如果原因没找对，所谓的解决方法（比如跳槽和改行）无非是瞎添乱。</p>\n<p>实际上，不仅员工们着急，很多老板在新形势下也不知道该怎么办了。今年好几家国内巨无霸公司的董事长和 CEO 找到我，都是同一个原因，眼看着自己的企业在信息时代可能落伍，但是从上到下都感觉“好无力啊”。</p>\n<p>这些公司有的管理着几万亿的资产，有的一年有小一千亿的利润，但是四五家这样的企业市值加起来，还不如一家腾讯。他们想发展，但是不知从何入手。</p>\n<p>这些人和企业所缺失的是什么？其实是一种新的认知，一种信息时代的思维方式，我把它叫做<strong>计算机思维</strong>。</p>\n<p>为什么叫它计算机思维呢？这并不是说计算机有思维，而是因为这种思维方式是伴随着计算机出现的。简单地讲就是和常人思维完全不同的一种方式，它包括很多方面。</p>\n<p>今天为了方便你理解这个概念以及认识它的重要性，我只介绍计算机思维的一个方面，就是对“大”和“小”的理解，或者说对量级这个概念的认识。</p>\n<p><strong>我们人类生活的环境，决定了我们对大数字是无感的。</strong></p>\n<p>著名物理学家伽莫夫（宇宙大爆炸理论以及核聚变理论的提出者）在他的科普书《从1到无穷大》中举了这样一个例子。两个原始部落的酋长比赛，看谁说的数字大。第一个酋长说了三，第二个酋长想了半天，然后说你赢了。</p>\n<p>你今天听起来觉得这两个人真可笑，至少说出四，岂不就赢了？但是对这两位酋长来讲，所拥有的东西就很少超过三个，比三个多的东西他们就觉得没有必要数清楚了，就用许多来形容了。也就是说，他们生活的环境限制了他们的认知。</p>\n<p>生活在今天的人就对大数的认知好了很多么？其实好不了多少。我们不妨再看两个例子：</p>\n<p>第一个例子，会做 PPT 的人都知道要用图表，而不是用数字列表来说明问题，因为认知学家早就发现人对大数字是无感的。今天很多人数100，000，000这个数字，还是从后往前，个十百千万地数。</p>\n<p>第二个例子是王健林在2016年半开玩笑地讲，“先定个小目标，比如说一个亿”，被全社会吐槽，因为即便是在今天的美国，也很少有人能一辈子挣一亿人民币(也就是1400万美元左右)，关于这一点我在上一季的《硅谷来信》第138封信中有详细分析。</p>\n<p>但是，如果换一个角度思考这件事情，这也说明了人对“大”和“小”这两个概念的理解，其实受限于具体生活的环境。你习惯了某一个环境的度量，其实很难理解在量级上大得多的世界。对大部分人来讲，一亿等于财富自由，等于无穷大。</p>\n<p>今天人的思维当然比1万年前的酋长们开阔了许多，但是相比计算机的思维就显得落后很多了，因为计算机从诞生开始，就是针对大数设计的。</p>\n<p>1946年人类第一台电子计算机诞生时，每秒钟能进行5000次运算。虽然这个速度只有 iPhone 计算速度的一百万分之一左右，但是比人已经快得不得了了。</p>\n<p>当时科学家们让它计算长程火炮炮弹的轨迹——这其实是发明电子计算机的原始目的，炮弹还没有落地，计算机就算出了轨迹，以至于在场的蒙巴顿元帅看得目瞪口呆，说，真快啊，简直是电的脑，“电脑”一词就是这么来的。</p>\n<p>由于一开始就是针对海量数字设计的，因此计算机思维和人的思维是不同的，就如同我们和一万年前的酋长不同一样。比如说，我们觉得围棋的变化数量是数不清的，因为这个数量太大，以至于很多下围棋的人也说不清有多大。</p>\n<p>当然，如果用数学方法分析一下，围棋的复杂性还是可以分析清楚的。棋盘上每一个点最终可以是黑子、白子或者空位三种情况，而棋盘有361个交叉点，因此围棋最多可以有3^361≈2x10^172这么多种情况。这个数当然非常非常大，大约是2后面跟了172个零。这么大的一个数字，人类对它是无感的。</p>\n<p>不过，如果你去问物理学家，他们对这个数字会深有体会，他们会告诉你整个宇宙中不过才有10^80~10^82个基本粒子（质子、中子或者电子等等）。也就是说，如果把每一个基本粒子都变成一个完整的宇宙，再把这些宇宙中的基本粒子数一遍，数量也没有围棋棋盘上各种变化的总数大。</p>\n<p>因此，这么多变化对人类来说就是无穷无尽。于是乎，我们人类就不把下围棋当作一种计算问题，而把这件事当成一种文化，或者更具体地讲是“棋道”。</p>\n<p>但是，对于计算机来讲，围棋再复杂，2x10^172这个数字再大，它也是一个有限的问题。我们认为它不可计算，是因为人类脑子的计算能力也是有极限的，缺乏计算复杂问题的思路。但是在计算机看来，这个大问题是可以计算的。</p>\n<p>当我们嘲笑那两个酋长只能数到3的时候，计算机可能也在嘲笑我们算不清围棋的步数。可以讲，<strong>认知决定了思维方式，当我们算不清的时候，我们就发明了所谓“围棋文化”这种思维方式。</strong></p>\n<p>相比计算机，人类对数字的认知也受限于我们作为生物进化的速度，这是人的思维和计算机的思维的另一个不同之处。</p>\n<p>世界上最早的农业大约始于1万年前，人类大约从那个时代开始识数，人类最早的计算工具（在兽骨上刻上划痕计数）也始于那个年代。可以讲从酋长们认识3，到今天我们认识一个亿，经历了大约10000年的时间。平均每十年进步千分之八，不到1%。</p>\n<p>那么计算机的进步速度有多快呢？我们知道摩尔定律让计算机毎十八个月性能翻一番，这大约相当于每五年涨十倍，或者每十年进步一百倍！</p>\n<p>到今年，iPhone 正好是第十年，iPhone 8的速度恰巧大约是当初乔布斯宣布的第一款 iPhone 的100倍左右。今天如果你保留了一部第一版的 iPhone，不妨试试随便装一个今天的 App，根本用不了的，因为当初的 iPhone 速度太慢了。</p>\n<p>如果我们往未来看，今天如果要开发5年之后的 IT 产品，就必须假设在今天10倍资源的框架下进行设计。但是让今天很多搞 IT 的人考虑拥有了10倍的资源以后，怎样才能更好地服务大众，他们是缺乏这种想象力的。</p>\n<p>我们过去感叹乔布斯像神一样，因为他拥有一个计算机的思维，能够想象几年后的世界。相比之下，当时嘲笑他的诺基亚前 CEO 奥利拉（Jorma Ollila）的思维还是常人的思维。不幸的是，奥利拉等人的局限性让诺基亚遇到了天花板。</p>\n<p>我们常说今天是<strong>后信息时代</strong>，或者即将进入智能时代。很多 IT 从业者的思维方式并没有跟上这个时代，这是他们很难在这个行业里突破天花板的根本原因。</p>\n<p>不仅一般员工如此，老板或者一些大公司也不例外，明天我就举几个例子来说明这一点。从那些例子中你可以看出，需要换脑筋的不只是 IT 人士，而是我们这个时代的所有人。</p>\n","categories":["thinking"],"tags":["thinking","谷歌方法论"]},{"title":"跨平台开发技术盘点","url":"/2018/07/22/frontend/cross-platform-development-technology-inventory/","content":"<p>本文将主要对当前跨平台开发技术进行盘点，主要是想让读者知道Flutter技术出现的背景。了解一门新技术出现的背景是非常重要的，因为只有了解之前是什么样的，才能理解为什么会是现在这样。<br><a id=\"more\"></a></p>\n<h2 id=\"原生开发与跨平台技术\"><a href=\"#原生开发与跨平台技术\" class=\"headerlink\" title=\"原生开发与跨平台技术\"></a>原生开发与跨平台技术</h2><h3 id=\"原生开发\"><a href=\"#原生开发\" class=\"headerlink\" title=\"原生开发\"></a>原生开发</h3><p>原生应用程序是指某一个移动平台（比如iOS或安卓）所特有的应用，使用相应平台支持的开发工具和语言，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。原生开发有以下主要优势：</p>\n<ul>\n<li>可访问平台全部功能（GPS、摄像头）；</li>\n<li>速度快、性能高、可以实现复杂动画及绘制，整体用户体验好；</li>\n</ul>\n<p>主要缺点：</p>\n<ul>\n<li>平台特定，开发成本高；不同平台必须维护不同代码，人力成本随之变大；</li>\n<li>内容固定，动态化弱，大多数情况下，有新功能更新时只能发版；</li>\n</ul>\n<p>在移动互联网发展初期，业务场景并不复杂，原生开发还可以应对产品需求迭代。 但近几年，随着物联网时代到来、移动互联网高歌猛进，日新月异，在很多业务场景中，传统的纯原生开发已经不能满足日益增长的业务需求。主要表现在：</p>\n<ul>\n<li>动态化内容需求增大；当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这对高速变化的互联网时代来说是很难接受的，所以，对应用动态化(不发版也可以更新应用内容)的需求就变的迫在眉睫。</li>\n<li>业务需求变化快，开发成本变大；由于原生开发一般都要维护Android、iOS两个开发团队，版本迭代时，无论人力成本，还是测试成本都会变大。</li>\n</ul>\n<p>总结一下，纯原生开发主要面临动态化和开发成本两个问题，而针对这两个问题，诞生了一些跨平台的动态化框架。</p>\n<h2 id=\"跨平台技术简介\"><a href=\"#跨平台技术简介\" class=\"headerlink\" title=\"跨平台技术简介\"></a>跨平台技术简介</h2><p>针对原生开发面临问题，人们一直都在努力寻找好的解决方案，而时至今日，已经有很多跨平台框架(注意，本书中所指的“跨平台”若无特殊说明，即特指Android和iOS两个平台)，根据其原理，主要分为三类：</p>\n<ul>\n<li>H5+原生（Cordova、Ionic、微信小程序）</li>\n<li>JavaScript开发+原生渲染 （React Native、Weex、快应用）</li>\n<li>自绘UI+原生(QT for mobile、Flutter)</li>\n</ul>\n<p>在接下来的章节中我们逐个来看看这三类框架的原理及优缺点。</p>\n<h2 id=\"跨平台技术一：Hybrid技术\"><a href=\"#跨平台技术一：Hybrid技术\" class=\"headerlink\" title=\"跨平台技术一：Hybrid技术\"></a>跨平台技术一：Hybrid技术</h2><h3 id=\"H5-原生混合开发\"><a href=\"#H5-原生混合开发\" class=\"headerlink\" title=\"H5+原生混合开发\"></a>H5+原生混合开发</h3><p>这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件WebView (Android)或WKWebView（iOS）来加载（以后若无特殊说明，我们用WebView来统一指代android和iOS中的网页加载控件）。这样以来，H5部分是可以随时改变而不用发版，动态化需求能满足；同时，由于h5代码只需要一次开发，就能同时在Android和iOS两个平台运行，这也可以减小开发成本，也就是说，H5部分功能越多，开发成本就越小。我们称这种h5+原生的开发模式为混合开发，采用混合模式开发的APP我们称之为混合应用或Hybrid APP，如果一个应用的大多数功能都是H5实现的话，我们称其为Web APP。</p>\n<p>目前混合开发框架的典型代表有：Cordova、Ionic 和微信小程序，值得一提的是微信小程序目前是在webview中渲染的，并非原生渲染，但将来有可能会采用原生渲染。</p>\n<h3 id=\"混合开发技术点\"><a href=\"#混合开发技术点\" class=\"headerlink\" title=\"混合开发技术点\"></a>混合开发技术点</h3><p>如之前所述，原生开发可以访问平台所有功能，而混合开发中，H5代码是运行在WebView中，而WebView实质上就是一个浏览器内核，其JavaScript依然运行在一个权限受限的沙箱中，所以对于大多数系统能力都没有访问权限，如无法访问文件系统、不能使用蓝牙等。所以，对于H5不能实现的功能，都需要原生去做。而混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用，这样一来，WebView就成为了JavaScript与原生API之间通信的桥梁，主要负责JavaScript与原生之间传递调用消息，而消息的传递必须遵守一个标准的协议，它规定了消息的格式与含义，我们把依赖于WebView的用于在JavaScript与原生之间通信并实现了某种消息传输协议的工具称之为WebView JavaScript Bridge, 简称 JsBridge，它也是混合开发框架的核心。</p>\n<p>现在，我们回头来看一下，混合应用无非就是在第一步中预先实现一系列API供JavaScript调用，让JavaScript有访问系统的能力，看到这里，我相信你也可以自己实现一个混合开发框架了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>混合应用的优点是动态内容是H5，web技术栈，社区及资源丰富，缺点是性能不好，对于复杂用户界面或动画，WebView不堪重任。</p>\n<h2 id=\"跨平台技术二：JavaScript开发-原生渲染\"><a href=\"#跨平台技术二：JavaScript开发-原生渲染\" class=\"headerlink\" title=\"跨平台技术二：JavaScript开发+原生渲染\"></a>跨平台技术二：JavaScript开发+原生渲染</h2><h3 id=\"React-Native、Weex及快应用\"><a href=\"#React-Native、Weex及快应用\" class=\"headerlink\" title=\"React Native、Weex及快应用\"></a>React Native、Weex及快应用</h3><p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 React 在原生移动应用平台的衍生产物，目前支持iOS和Android两个平台。RN使用Javascript语言，类似于HTML的JSX，以及CSS来开发移动应用，因此熟悉Web前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。</p>\n<p>由于RN和React原理相通，并且Flutter也是受React启发，很多思想也都是相通的，万丈高楼平地起，我们有必要深入了解一下React原理。React是一个响应式的Web框架，我们先了解一下两个重要的概念：<strong>DOM树与响应式编程</strong>。</p>\n<h4 id=\"DOM树与控件树\"><a href=\"#DOM树与控件树\" class=\"headerlink\" title=\"DOM树与控件树\"></a>DOM树与控件树</h4><p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口，一种独立于平台和语言的方式访问和修改一个文档的内容和结构。换句话说，这是表示和处理一个HTML或XML文档的标准接口。简单来说，DOM就是文档树，与用户界面控件树对应，在前端开发中通常指HTML对应的渲染树，但广义的DOM也可以指Android中的XML布局文件对应的控件树，而术语DOM操作就是指直接来操作渲染树（或控件树）， 因此，可以看到其实DOM树和控件树是等价的概念，只不过前者常用于Web开发中，而后者常用于原生开发中。</p>\n<h4 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h4><p>React中提出一个重要思想：状态改变则UI随之自动改变，而React框架本身就是响应用户状态改变的事件而执行重新构建用户界面的工作，这就是典型的响应式编程范式，下面我们总结一下React中响应式原理：</p>\n<p>开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。</p>\n<p>React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。</p>\n<p>值得注意的是，在第二步中，状态变化后React框架并不会立即去计算并渲染DOM树的变化部分，相反，React会在DOM的基础上建立一个抽象层，即虚拟DOM树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到真实DOM中，而不是每次改变都去操作一下DOM。为什么不能每次改变都直接去操作DOM树？这是因为在浏览器中每一次DOM操作都有可能引起浏览器的重绘或回流：</p>\n<ul>\n<li>如果DOM只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。</li>\n<li>如果DOM树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。</li>\n</ul>\n<p>而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对DOM进行操作，这会带来性能问题，而批量操作只会触发一次DOM更新。</p>\n<blockquote>\n<p>思考题：Diff操作和DOM批量更新难道不应该是浏览器的职责吗？第三方框架中去做合不合适？</p>\n</blockquote>\n<h4 id=\"React-Native\"><a href=\"#React-Native\" class=\"headerlink\" title=\"React Native\"></a>React Native</h4><p>上文已经提到React Native 是React 在原生移动应用平台的衍生产物，那两者主要的区别是什么呢？其实，主要的区别在于虚拟DOM映射的对象是什么？React中虚拟DOM最终会映射为浏览器DOM树，而RN中虚拟DOM会通过 JavaScriptCore 映射为原生控件树。</p>\n<p>JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用：</p>\n<ul>\n<li>为JavaScript提供运行环境。</li>\n<li>是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。</li>\n</ul>\n<p>而RN中将虚拟DOM映射为原生控件的过程中分两步：</p>\n<ul>\n<li>布局消息传递； 将虚拟DOM布局信息传递给原生；</li>\n<li>原生根据布局信息通过对应的原生控件渲染控件树；</li>\n</ul>\n<p>至此，React Native 便实现了跨平台。 相对于混合应用，由于React Native是原生控件渲染，所以性能会比混合应用中H5好很多，同时React Native使用了Web开发技术栈，也只需维护一份代码，同样是跨平台框架。</p>\n<h4 id=\"Weex\"><a href=\"#Weex\" class=\"headerlink\" title=\"Weex\"></a>Weex</h4><p>Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。</p>\n<h4 id=\"快应用\"><a href=\"#快应用\" class=\"headerlink\" title=\"快应用\"></a>快应用</h4><p>快应用是华为、小米、OPPO、魅族等国内9大主流手机厂商共同制定的轻量级应用标准，目标直指微信小程序。它也是采用JavaScript语言开发，原生控件渲染，与React Native和Weex相比主要有两点不同：</p>\n<ul>\n<li>快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。</li>\n<li>React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>JavaScript开发+原生渲染的方式主要优点如下：</p>\n<ul>\n<li>采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。</li>\n<li>原生渲染，性能相比H5提高很多。</li>\n<li>动态化较好，支持热更新。</li>\n</ul>\n<p>不足：</p>\n<ul>\n<li>渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。</li>\n<li>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。</li>\n<li>由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。</li>\n</ul>\n<h2 id=\"跨平台技术三：自绘UI-原生\"><a href=\"#跨平台技术三：自绘UI-原生\" class=\"headerlink\" title=\"跨平台技术三：自绘UI+原生\"></a>跨平台技术三：自绘UI+原生</h2><p>我们看看最后一种跨平台技术：<strong>自绘UI+原生</strong>。这种技术的思路是，通过在不同平台实现一个统一接口的渲染引擎来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。注意，自绘引擎解决的是UI的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。这种平台技术的优点如下：</p>\n<ul>\n<li>性能高；由于自绘引擎是直接调用系统API来绘制UI，所以性能和原生控件接近。</li>\n<li>灵活、组件库易维护、UI外观保真度和一致性高；由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性；另外，由于不依赖原生控件，也就不会受原生布局系统的限制，这样布局系统会非常灵活。</li>\n</ul>\n<p>不足：</p>\n<ul>\n<li>动态性不足；为了保证UI绘制性能，自绘UI系统一般都会采用AOT模式编译其发布包，所以应用发布后，不能像Hybrid和RN那些使用JavaScript（JIT）作为开发语言的框架那样动态下发代码。</li>\n<li>开发效率低：QT使用C++作为其开发语言，而编程效率是直接会影响APP开发效率的，C++作为一门静态语言，在UI开发方面灵活性不及JavaScript这样的动态语言，另外，C++需要开发者手动去管理内存分配，没有JavaScript及Java中垃圾回收（GC）的机制。</li>\n</ul>\n<p>也许你已经猜到Flutter就属于这一类跨平台技术，没错，Flutter正是实现一套自绘引擎，并拥有一套自己的UI布局系统。不过，自绘制引擎的思路并不是什么新概念，Flutter并不是第一个尝试这么做的，在它之前有一个典型的代表，即大名鼎鼎的QT。</p>\n<h3 id=\"QT简介\"><a href=\"#QT简介\" class=\"headerlink\" title=\"QT简介\"></a>QT简介</h3><p>Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。2008年，Qt Company科技被诺基亚公司收购，Qt也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C/C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP，它提供给应用程序开发者构建图形用户界面所需的所有功能。但是，QT虽然在PC端获得了巨大成功，备受社区追捧，然而其在移动端却表现不佳，在近几年，虽然偶尔能听到QT的声音，但一直很弱，无论QT本身技术如何、设计思想如何，但事实上终究是败了，究其原因，笔者认为主要有四：</p>\n<ul>\n<li>QT移动开发社区太小，学习资料不足，生态不好。</li>\n<li>官方推广不利，支持不够。</li>\n<li>移动端发力较晚，市场已被其它动态化框架占领（Hybrid和RN)。</li>\n<li>在移动开发中，C++开发和Web开发栈相比有着先天的劣势，直接结果就是QT开发效率太低。</li>\n</ul>\n<p>基于此四点，尽管QT是移动端开发跨平台自绘引擎的先驱，但却成为了烈士。</p>\n<h3 id=\"Flutter\"><a href=\"#Flutter\" class=\"headerlink\" title=\"Flutter\"></a>Flutter</h3><p>Flutter是Google发布的一个用于创建跨平台、高性能移动应用的框架。Flutter和QT mobile一样，都没有使用原生控件，相反都实现了一个自绘引擎，使用自身的布局、绘制系统。那么，我们会担心，QT mobile面对的问题Flutter是否也一样，Flutter会不会步入QT mobile后尘，成为另一个烈士？要回到这个问题，我们先来看看Flutter诞生过程：</p>\n<ul>\n<li>2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架——Flutter。</li>\n<li>2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。</li>\n<li>2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。</li>\n</ul>\n<p>观其发展，在2018年5月份，Flutter 进入了 GitHub stars 排行榜前 100 名，已有 27k star。而今天(2019年5月29日)，已经有65K的Star。经历了短短2年多的时间，Flutter 生态系统得以快速增长，由此可见，Flutter在开发者中受到了热烈的欢迎，其未来发展值得期待！</p>\n<p>现在，我们来和QT mobile做一个对比：</p>\n<ul>\n<li>生态：从Github上来看，目前Flutter活跃用户正在高速增长。从Stackoverflow上提问来看，Flutter社区现在已经很庞大。Flutter的文档、资源也越来越丰富，开发过程中遇到的很多问题都可以在Stackoverflow或其github issue中找到答案。</li>\n<li>技术支持：现在Google正在大力推广Flutter，Flutter的作者中很多人都是来自Chromium团队，并且github上活跃度很高。另一个角度，从今年上半年Flutter频繁的版本发布也可以看出Google对Flutter的投入的资源不小，所以在官方技术支持这方面，大可不必担心。</li>\n<li>开发效率：Flutter的热重载可帮助开发者快速地进行测试、构建UI、添加功能并更快地修复错误。在iOS和Android模拟器或真机上可以实现毫秒级热重载，并且不会丢失状态。这真的很棒，相信我，如果你是一名原生开发者，体验了Flutter开发流后，很可能就不想重新回去做原生了，毕竟很少有人不吐槽原生开发的编译速度。</li>\n</ul>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>现在我们从框架角度对比一下它们，如表所示：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>技术类型</th>\n<th>UI渲染方式</th>\n<th>性能</th>\n<th>开发效率</th>\n<th>动态化</th>\n<th>框架代表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>H5+原生</td>\n<td>WebView渲染</td>\n<td>一般</td>\n<td>高</td>\n<td>支持</td>\n<td>Cordova、Ionic</td>\n</tr>\n<tr>\n<td>JavaScript+原生渲染</td>\n<td>原生控件渲染</td>\n<td>好</td>\n<td>中</td>\n<td>支持</td>\n<td>RN、Weex</td>\n</tr>\n<tr>\n<td>自绘UI+原生</td>\n<td>调用系统API渲染</td>\n<td>好</td>\n<td>Flutter高, QT低</td>\n<td>默认不支持</td>\n<td>QT、Flutter</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>上表中开发语言主要指UI的开发语言。而开发效率，是指整个开发周期的效率，包括编码时间、调试时间、以及排错、兼容时间。动态化主要指是否支持动态下发代码和是否支持热更新。值得注意的是Flutter的Release包默认是使用Dart AOT模式编译的，所以不支持动态化，但Dart还有JIT或snapshot运行方式，这些模式都是支持动态化的。</p>\n","categories":["FrontEnd"],"tags":["note"]},{"title":"Exploring The Potential Of Web Workers For Multithreading On The Web","url":"/2023/05/03/frontend/potential-web-workers-multithreading-web/","content":"<p>Multithreading is an important technique used in modern software development to enhance the performance and responsiveness of applications. However, it’s not a common practice on the web due to the single-threaded nature of JavaScript. To overcome this limitation, Web Workers were introduced as a way to enable this technique in web applications. In this article, Sarah Oke Okolo explores the importance of Web Workers for multithreading on the web, including the limitations and considerations of using them and the strategies for mitigating potential issues associated with Web Workers.<br><a id=\"more\"></a><br>Web Workers are a powerful feature of modern web development and were introduced as part of the HTML5 specification in 2009. They were designed to provide a way to execute JavaScript code in the background, separate from the main execution thread of a web page, in order to improve performance and responsiveness.</p>\n<p>The main thread is the single execution context that is responsible for rendering the UI, executing JavaScript code, and handling user interactions. In other words, JavaScript is “single-threaded”. This means that any time-consuming task, such as complex calculations or data processing that is executed, would block the main thread and cause the UI to freeze and become unresponsive.</p>\n<p>This is where Web Workers come in.</p>\n<p>Web Workers were implemented as a way to address this problem by allowing time-consuming tasks to be executed in a separate thread, called a worker thread. This enabled JavaScript code to be executed in the background without blocking the main thread and causing the page to become unresponsive.</p>\n<p>Creating a web worker in JavaScript is not much of a complicated task. The following steps provide a starting point for integrating a web worker into your application:</p>\n<ol>\n<li>Create a new JavaScript file that contains the code you want to run in the worker thread. This file should not contain any references to the DOM, as it will not have access to it.</li>\n<li>In your main JavaScript file, create a new worker object using the <code>Worker</code> constructor. This constructor takes a single argument, which is the URL of the JavaScript file you created in step 1.<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span><br></pre></td></tr></table></figure></li>\n<li>Add event listeners to the worker object to handle messages sent between the main thread and the worker thread. The <code>onmessage</code> event handler is used to handle messages sent from the worker thread, while the <code>postMessage</code> method is used to send messages to the worker thread.<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Worker said: '</span> + event.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">worker.postMessage(<span class=\"string\">'Hello, worker!'</span>);</span><br></pre></td></tr></table></figure></li>\n<li>In your worker JavaScript file, add an event listener to handle messages sent from the main thread using the <code>onmessage</code> property of the <code>self</code> object. You can access the data sent with the message using the <code>event.data</code> property.<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Main thread said: '</span> + event.data);</span><br><span class=\"line\">  self.postMessage(<span class=\"string\">'Hello, main thread!'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Now let’s run the web application and test the worker. We should see messages printed to the console indicating that messages were sent and received between the main thread and the worker thread.</p>\n<p>One key difference between Web Workers and the main thread is that Web Workers have no access to the DOM or the UI. This means that they cannot directly manipulate the HTML elements on the page or interact with the user.</p>\n<p>Another important difference is that Web Workers are designed to run in a <strong>sandboxed environment</strong>, separate from the main thread, which means that they have limited access to system resources and cannot access certain APIs, such as the <code>localStorage</code> or <code>sessionStorage</code> APIs. However, they can communicate with the main thread through a messaging system, allowing data to be exchanged between the two threads.</p>\n<h3 id=\"Importance-And-Benefits-Of-Web-Workers-For-Multithreading-On-The-Web\"><a href=\"#Importance-And-Benefits-Of-Web-Workers-For-Multithreading-On-The-Web\" class=\"headerlink\" title=\"Importance And Benefits Of Web Workers For Multithreading On The Web\"></a>Importance And Benefits Of Web Workers For Multithreading On The Web</h3><p>Web Workers provide a way for web developers to achieve multithreading on the web, which is crucial for building high-performance web applications. By enabling time-consuming tasks to be executed in the background, separate from the main thread, Web Workers improve the overall responsiveness of web pages and allow for a more seamless user experience. The following are some of the importance and benefits of Web Workers for multithreading on the Web.</p>\n<h4 id=\"Improved-Resource-Utilization\"><a href=\"#Improved-Resource-Utilization\" class=\"headerlink\" title=\"Improved Resource Utilization\"></a>Improved Resource Utilization</h4><p>By allowing time-consuming tasks to be executed in the background, Web Workers make more efficient use of system resources, enabling faster and more efficient processing of data and improving overall performance. This is especially important for web applications that involve large amounts of data processing or image manipulation, as Web Workers can perform these tasks without impacting the user interface.</p>\n<h4 id=\"Increased-Stability-And-Reliability\"><a href=\"#Increased-Stability-And-Reliability\" class=\"headerlink\" title=\"Increased Stability And Reliability\"></a>Increased Stability And Reliability</h4><p>By isolating time-consuming tasks in separate worker threads, Web Workers help to prevent crashes and errors that can occur when executing large amounts of code on the main thread. This makes it easier for developers to write stable and reliable web applications, reducing the likelihood of user frustration or loss of data.</p>\n<h4 id=\"Enhanced-Security\"><a href=\"#Enhanced-Security\" class=\"headerlink\" title=\"Enhanced Security\"></a>Enhanced Security</h4><p>Web Workers run in a sandboxed environment that is separate from the main thread, which helps to enhance the security of web applications. This isolation prevents malicious code from accessing or modifying data in the main thread or other Web Workers, reducing the risk of data breaches or other security vulnerabilities.</p>\n<h4 id=\"Better-Resource-Utilization\"><a href=\"#Better-Resource-Utilization\" class=\"headerlink\" title=\"Better Resource Utilization\"></a>Better Resource Utilization</h4><p>Web Workers can help to improve resource utilization by freeing up the main thread to handle user input and other tasks while the Web Workers handle time-consuming computations in the background. This can help to improve overall system performance and reduce the likelihood of crashes or errors. Additionally, by leveraging multiple CPU cores, Web Workers can make more efficient use of system resources, enabling faster and more efficient processing of data.</p>\n<p>Web Workers also enable better load balancing and scaling of web applications. By allowing tasks to be executed in parallel across multiple worker threads, Web Workers can help <strong>distribute the workload evenly across multiple cores or processors</strong>, enabling faster and more efficient processing of data. This is particularly important for web applications that experience high traffic or demand, as Web Workers can help to ensure that the application can handle an increased load without impacting performance.</p>\n<h3 id=\"Practical-Applications-Of-Web-Workers\"><a href=\"#Practical-Applications-Of-Web-Workers\" class=\"headerlink\" title=\"Practical Applications Of Web Workers\"></a>Practical Applications Of Web Workers</h3><p>Let us explore some of the most common and useful applications of Web Workers. Whether you’re building a complex web application or a simple website, understanding how to leverage Web Workers can help you improve performance and provide a better user experience.</p>\n<h4 id=\"Offloading-CPU-Intensive-Work\"><a href=\"#Offloading-CPU-Intensive-Work\" class=\"headerlink\" title=\"Offloading CPU-Intensive Work\"></a>Offloading CPU-Intensive Work</h4><p>Suppose we have a web application that needs to perform a large, CPU-intensive computation. If we perform this computation in the main thread, the user interface will become unresponsive, and the user experience will suffer. To avoid this, we can use a Web Worker to perform the computation in the background.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new Web Worker.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to handle messages from the worker.</span></span><br><span class=\"line\">worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = event.data;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Send a message to the worker to start the computation.</span></span><br><span class=\"line\">worker.postMessage(&#123; <span class=\"attr\">num</span>: <span class=\"number\">1000000</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// In worker.js:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to perform the computation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compute</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    sum += i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to handle messages from the main thread.</span></span><br><span class=\"line\">onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = event.data.num;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = compute(num);</span><br><span class=\"line\">  postMessage(result);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>In this example, we create a new Web Worker and define a function to handle messages from the worker. We then send a message to the worker with a parameter (<code>num</code>) that specifies the number of iterations to perform in the computation. The worker receives this message and performs the computation in the background. When the computation is complete, the worker sends a message back to the main thread with the result. The main thread receives this message and logs the result to the console.</p>\n<p>This task involves adding up all the numbers from <code>0</code> to a given number. While this task is relatively simple and straightforward for small numbers, it can become computationally intensive for very large numbers.</p>\n<p>In the example code we used above, we passed the number <code>1000000</code> to the <code>compute()</code> function in the Web Worker. This means that the compute function will need to add up all the numbers from 0 to one million. This involves a large number of additional operations and can take a significant amount of time to complete, especially if the code is running on a slower computer or in a browser tab that is already busy with other tasks.</p>\n<p>By offloading this task to a Web Worker, the main thread of the application can continue to run smoothly without being blocked by the computationally intensive task. This allows the user interface to remain responsive and ensures that other tasks, such as user input or animations, can be handled without delay.</p>\n<h4 id=\"Handling-Network-Requests\"><a href=\"#Handling-Network-Requests\" class=\"headerlink\" title=\"Handling Network Requests\"></a>Handling Network Requests</h4><p>Let us consider a scenario where a web application needs to initiate a significant number of network requests. Performing these requests within the main thread could cause the user interface to become unresponsive and result in a poor user experience. In order to prevent this issue, we can utilize Web Workers to handle these requests in the background. By doing so, the main thread remains free to execute other tasks while the Web Worker handles the network requests simultaneously, resulting in improved performance and a better user experience.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new Web Worker.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to handle messages from the worker.</span></span><br><span class=\"line\">worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> response = event.data;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(response);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Send a message to the worker to start the requests.</span></span><br><span class=\"line\">worker.postMessage(&#123; <span class=\"attr\">urls</span>: [<span class=\"string\">'https://api.example.com/foo'</span>, <span class=\"string\">'https://api.example.com/bar'</span>] &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// In worker.js:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to handle network requests.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetch(url).then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to handle messages from the main thread.</span></span><br><span class=\"line\">onmessage = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> urls = event.data.urls;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(urls.map(request));</span><br><span class=\"line\">  postMessage(results);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>In this example, we create a new Web Worker and define a function to handle messages from the worker. We then send a message to the worker with an array of URLs to request. The worker receives this message and performs the requests in the background using the <code>fetch</code> API. When all requests are complete, the worker sends a message back to the main thread with the results. The main thread receives this message and logs the results to the console.</p>\n<h4 id=\"Parallel-Processing\"><a href=\"#Parallel-Processing\" class=\"headerlink\" title=\"Parallel Processing\"></a>Parallel Processing</h4><p>Suppose we have a web application that needs to perform a large number of independent computations. If we perform these computations in sequence in the main thread, the user interface will become unresponsive, and the user experience will suffer. To avoid this, we can use a Web Worker to perform the computations in parallel.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a new Web Worker.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to handle messages from the worker.</span></span><br><span class=\"line\">worker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = event.data;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Send a message to the worker to start the computations.</span></span><br><span class=\"line\">worker.postMessage(&#123; <span class=\"attr\">nums</span>: [<span class=\"number\">1000000</span>, <span class=\"number\">2000000</span>, <span class=\"number\">3000000</span>] &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// In worker.js:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to perform a single computation.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compute</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">    sum += i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Define a function to handle messages from the main thread.</span></span><br><span class=\"line\">onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> nums = event.data.nums;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> results = nums.map(compute);</span><br><span class=\"line\">  postMessage(results);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>In this example, we create a new Web Worker and define a function to handle messages from the worker. We then send a message to the worker with an array of numbers to compute. The worker receives this message and performs the computations in parallel using the map method. When all computations are complete, the worker sends a message back to the main thread with the results. The main thread receives this message and logs the results to the console.</p>\n<h3 id=\"Limitations-And-Considerations\"><a href=\"#Limitations-And-Considerations\" class=\"headerlink\" title=\"Limitations And Considerations\"></a>Limitations And Considerations</h3><p>Web workers are a powerful tool for improving the performance and responsiveness of web applications, but they also have some limitations and considerations that you should keep in mind when using them. Here are some of the most important ones:</p>\n<h4 id=\"Browser-Support\"><a href=\"#Browser-Support\" class=\"headerlink\" title=\"Browser Support\"></a>Browser Support</h4><p>Web workers are supported in all major browsers, including Chrome, Firefox, Safari, and Edge. However, there are still some other browsers that do not support web workers or may have limited support.</p>\n<p>For a more extensive look at browser support, see <code>Can I Use</code>.</p>\n<p>It is important that you check out the browser support for any feature before using them in production code and test your application thoroughly to ensure compatibility.</p>\n<h4 id=\"Limited-Access-To-The-DOM\"><a href=\"#Limited-Access-To-The-DOM\" class=\"headerlink\" title=\"Limited Access To The DOM\"></a>Limited Access To The DOM</h4><p>Web workers run in a separate thread and do not have access to the DOM or other global objects in the main thread. This means you <strong>cannot directly manipulate the DOM from a web worker or access global objects like windows or documents</strong>.</p>\n<p>To work around this limitation, you can use the <code>postMessage</code> method to communicate with the main thread and update the DOM or access global objects indirectly. For example, you can send data to the main thread using <code>postMessage</code> and then update the DOM or global objects in response to the message.</p>\n<p>Alternatively, there are some libraries that help solve this issue. For example, the WorkerDOM library enables you to run the DOM in a web worker, allowing for faster page rendering and improved performance.</p>\n<h4 id=\"Communication-Overhead\"><a href=\"#Communication-Overhead\" class=\"headerlink\" title=\"Communication Overhead\"></a>Communication Overhead</h4><p>Web workers communicate with the main thread using the <code>postMessage</code> method, and as a result, could introduce communication overhead, which refers to the amount of time and resources required to establish and maintain communication between two or more computing systems, such as between a Web Worker and the main thread in a web application. This could result in a delay in processing messages and potentially slow down the application. To minimize this overhead, you should <strong>only send essential data</strong> between threads and <strong>avoid sending large amounts of data or frequent messages</strong>.</p>\n<h4 id=\"Limited-Debugging-Tools\"><a href=\"#Limited-Debugging-Tools\" class=\"headerlink\" title=\"Limited Debugging Tools\"></a>Limited Debugging Tools</h4><p>Debugging Web Workers can be more challenging than debugging code in the main thread, as there are fewer debugging tools available. To make debugging easier, you can use the <code>console</code> API to log messages from the worker thread and use browser developer tools to inspect messages sent between threads.</p>\n<h4 id=\"Code-Complexity\"><a href=\"#Code-Complexity\" class=\"headerlink\" title=\"Code Complexity\"></a>Code Complexity</h4><p>Using Web Workers can increase the complexity of your code, as you need to manage communication between threads and ensure that data is passed correctly. This can make it more difficult to write, debug, and maintain your code, so you should carefully consider whether using web workers is necessary for your application.</p>\n<h3 id=\"Strategies-For-Mitigating-Potential-Issues-With-Web-Workers\"><a href=\"#Strategies-For-Mitigating-Potential-Issues-With-Web-Workers\" class=\"headerlink\" title=\"Strategies For Mitigating Potential Issues With Web Workers\"></a>Strategies For Mitigating Potential Issues With Web Workers</h3><p>Web Workers are a powerful tool for improving the performance and responsiveness of web applications. However, when using Web Workers, there are several potential issues that can arise. Here are some strategies for mitigating these issues:</p>\n<h4 id=\"Minimize-Communication-Overhead-With-Message-Batching\"><a href=\"#Minimize-Communication-Overhead-With-Message-Batching\" class=\"headerlink\" title=\"Minimize Communication Overhead With Message Batching\"></a>Minimize Communication Overhead With Message Batching</h4><p>Message batching involves grouping multiple messages into a single batch message, which can be more efficient than sending individual messages separately. This approach reduces the number of round-trips between the main thread and Web Workers. It can help to minimize communication overhead and improve the overall performance of your web application.</p>\n<p>To implement message batching, you can <strong>use a queue to accumulate messages and send them together as a batch</strong> when the queue reaches a certain threshold or after a set period of time. Here’s an example of how you can implement message batching in your Web Worker:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create a message queue to accumulate messages.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> messageQueue = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Create a function to add messages to the queue.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addToQueue</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">  messageQueue.push(message);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// Check if the queue has reached the threshold size.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (messageQueue.length &gt;= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If so, send the batched messages to the main thread.</span></span><br><span class=\"line\">    postMessage(messageQueue);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Clear the message queue.</span></span><br><span class=\"line\">    messageQueue.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add a message to the queue.</span></span><br><span class=\"line\">addToQueue(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'log'</span>, <span class=\"attr\">message</span>: <span class=\"string\">'Hello, world!'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add another message to the queue.</span></span><br><span class=\"line\">addToQueue(&#123;<span class=\"attr\">type</span>: <span class=\"string\">'error'</span>, <span class=\"attr\">message</span>: <span class=\"string\">'An error occurred.'</span>&#125;);</span><br></pre></td></tr></table></figure><br>In this example, we create a message queue to accumulate messages that need to be sent to the main thread. Whenever a message is added to the queue using the <code>addToQueue</code> function, we check if the queue has reached the threshold size (in this case, ten messages). If so, we send the batched messages to the main thread using the <code>postMessage</code> method. Finally, we clear the message queue to prepare it for the next batch.</p>\n<p>By batching messages in this way, we can reduce the overall number of messages sent between the main thread and Web Workers.</p>\n<h4 id=\"Avoid-Synchronous-Methods\"><a href=\"#Avoid-Synchronous-Methods\" class=\"headerlink\" title=\"Avoid Synchronous Methods\"></a>Avoid Synchronous Methods</h4><p>These are JavaScript functions or operations that block the execution of other code until they are complete. Synchronous methods can block the main thread and cause your application to become unresponsive. To avoid this, you should avoid using synchronous methods in your Web Worker code. Instead, use <strong>asynchronous methods</strong> such as <code>setTimeout()</code> or <code>setInterval()</code> to perform long-running computations.</p>\n<p>Here is a little demonstration:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In the worker</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'message'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.data.action === <span class=\"string\">'start'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use a setTimeout to perform some computation asynchronously.</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = doSomeComputation(event.data.data);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Send the result back to the main thread.</span></span><br><span class=\"line\">      self.postMessage(&#123; <span class=\"attr\">action</span>: <span class=\"string\">'result'</span>, <span class=\"attr\">data</span>: result &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Be-Mindful-Of-Memory-Usage\"><a href=\"#Be-Mindful-Of-Memory-Usage\" class=\"headerlink\" title=\"Be Mindful Of Memory Usage\"></a>Be Mindful Of Memory Usage</h4><p>Web Workers have their own memory space, which can be limited depending on the user’s device and browser settings. To avoid memory issues, you should be mindful of the amount of memory your Web Worker code is using and avoid creating large objects unnecessarily. For example:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In the worker</span></span><br><span class=\"line\">self.addEventListener(<span class=\"string\">'message'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.data.action === <span class=\"string\">'start'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use a for loop to process an array of data.</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = event.data.data;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Process each item in the array and add the result to the result array.</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> itemResult = processItem(data[i]);</span><br><span class=\"line\">      result.push(itemResult);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Send the result back to the main thread.</span></span><br><span class=\"line\">    self.postMessage(&#123; <span class=\"attr\">action</span>: <span class=\"string\">'result'</span>, <span class=\"attr\">data</span>: result &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><br>In this code, the Web Worker processes an array of data and returns the result to the main thread using the <code>postMessage</code> method. However, the <code>for</code> loop used to process the data may be time-consuming.</p>\n<p>The reason for this is that the code is processing an entire array of data at once, meaning that all the data must be loaded into memory at the same time. If the data set is very large, this can cause the Web Worker to consume a significant amount of memory, potentially exceeding the memory limit allocated to the Web Worker by the browser.</p>\n<p>To mitigate this issue, you can consider using built-in JavaScript methods like <code>forEach</code> or <code>reduce</code>, which can process data one item at a time and avoid the need to load the entire array into memory at once.</p>\n<h4 id=\"Browser-Compatibility\"><a href=\"#Browser-Compatibility\" class=\"headerlink\" title=\"Browser Compatibility\"></a>Browser Compatibility</h4><p>Web Workers are supported in most modern browsers, but some older browsers may not support them. To ensure compatibility with a wide range of browsers, you should test your Web Worker code in different browsers and versions. You can also use feature detection to check if Web Workers are supported before using them in your code, like this:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> Worker !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Web Workers are supported.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Web Workers are not supported.</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Web Workers are not supported in this browser.'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>This code checks if Web Workers are supported in the current browser and creates a new Web Worker if they are supported. If Web Workers are not supported, the code logs a message to the console indicating that Web Workers are not supported in the browser.</p>\n<p>By following these strategies, you can ensure that your Web Worker code is efficient, responsive, and compatible with a wide range of browsers.</p>\n<h3 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h3><p>As web applications become increasingly complex and demanding, the importance of efficient multithreading techniques — such as Web Workers — is likely to increase. Web Workers are an essential feature of modern web development that allows developers to offload CPU-intensive tasks to separate threads, improving application performance and responsiveness. However, there are significant limitations and considerations to keep in mind when working with Web Workers, such as the lack of access to the DOM and limitations on the types of data that can be passed between threads.</p>\n<p>To mitigate these potential issues, developers can follow strategies as mentioned earlier, such as using asynchronous methods and being mindful of the complexity of the task being offloaded.</p>\n<p>Multithreading with Web Workers is likely to remain an important technique for improving web application performance and responsiveness in the future. While there are other techniques for achieving multithreading in JavaScript, such as using <code>WebSockets</code> or <code>SharedArrayBuffer</code>, Web Workers have several advantages that make them a powerful tool for developers.</p>\n<p>Adopting more recent technology such as <strong>WebAssembly</strong> may open up new opportunities for using Web Workers to offload even more complex and computationally-intensive tasks. Overall, Web Workers are likely to continue to evolve and improve in the coming years, helping developers create more efficient and responsive web applications.</p>\n<p>Additionally, many libraries and tools exist to help developers work with Web Workers. For example, <em>Comlink</em> and <em>Workerize</em> provide a simplified API for communicating with Web Workers. These libraries abstract away some of the complexity of managing Web Workers, making it easier to leverage their benefits.</p>\n<p>Hopefully, this article has given you a good understanding of the potential of web workers for multithreading and how to use them in your own code.</p>\n","categories":["WebDevelopment"],"tags":["WebDevelopment","English"]},{"title":"编程范式游记（1）- 起源","url":"/2016/01/01/mouse/programming-paradigm-travel-1-origin/","content":"<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><p>现在很多的文章和演讲都在谈架构，很少有人再会谈及编程范式。然而， 这些基础性和本质性的话题，却是非常非常重要的。<br><a id=\"more\"></a><br>一方面，我发现在一些语言争论上，有很多人对编程语言的认识其实并不深；另一方面，通过编程语言的范式，我们不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能写出更好的代码。</p>\n<p>这一经历可能有些漫长，途中也会有各式各样的各种语言的代码。但是我保证这一历程对于一个程序员来说是非常有价值的，因为你不但可以对主流编程语言的一些特性有所了解，而且当我们到达终点的时候，你还能了解到编程的本质是什么。</p>\n<p>这一系列文章中有各种语言的代码，其中有 C、C++、Python、Java、Scheme、Go、JavaScript、Prolog 等。所以，如果要能跟上本文的前因后果，你要对这几门比较主流的语言多少有些了解。而且，你需要在一线编写一段时间（大概 5 年以上吧）的代码，可能才能体会到这一系列文章的内涵。</p>\n<p>我根据每篇文章中所讲述的内容，将这一系列文章分为四个部分。</p>\n<p>第一部分：<strong>泛型编程</strong>，第 1~3 章，讨论了从 C 到 C++ 的泛型编程方法，并系统地总结了编程语言中的类型系统和泛型编程的本质。</p>\n<p>第二部分：<strong>函数式编程</strong>，第 4 章和第 5 章，讲述了函数式编程用到的技术，及其思维方式，并通过 Python 和 Go 修饰器的例子，展示了函数式编程下的代码扩展能力，以及函数的相互和随意拼装带来的好处。</p>\n<p>第三部分：<strong>面向对象编程</strong>，第 6~8 章，讲述与传统的编程思想相反，面向对象设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，列举了面向对象编程的优缺点，基于原型的编程范式，以及 Go 语言的委托模式。</p>\n<p>第四部分：<strong>编程本质和逻辑编程</strong>，第 9~11 章，先探讨了编程的本质：逻辑部分才是真正有意义的，控制部分只能影响逻辑部分的效率，然后结合 Prolog 语言介绍了逻辑编程范式，最后对程序世界里的编程范式进行了总结，对比了它们之间的不同。</p>\n<p>我会以每部分为一个发布单元，将这些文章陆续发表在专栏中。如果在编程范式方面，你有其他感兴趣的主题，欢迎留言给我。</p>\n<p>下面我们来说说什么是编程范式。编程范式的英语是 programming paradigm，范即模范之意，范式即模式、方法，是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照“方法学”一词）。</p>\n<p>编程语言发展到今天，出现了好多不同的代码编写方式，但不同的方式解决的都是同一个问题，那就是如何写出更为通用、更具可重用性的代码或模块。</p>\n<p>如果你准备好了，就和我一起来吧。</p>\n<h2 id=\"先从-C-语言开始\"><a href=\"#先从-C-语言开始\" class=\"headerlink\" title=\"先从 C 语言开始\"></a>先从 C 语言开始</h2><p>为了讲清楚这个问题，我需要从 C 语言开始讲起。因为 C 语言历史悠久，而几乎现在看到的所有编程语言都是以 C 语言为基础来拓展的，不管是 C++、Java、C#、Go、Python、PHP、Perl、JavaScript、Lua，还是 Shell。</p>\n<p>自 C 语言问世 40 多年以来，其影响了太多太多的编程语言，到现在还一直被广泛使用，不得不佩服它的生命力。但是，我们也要清楚地知道，大多数 C Like 编程语言其实都是在改善 C 语言带来的问题。</p>\n<p>那 C 语言有哪些特性呢？我简单来总结下：</p>\n<p>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</p>\n<p>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</p>\n<p>C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；</p>\n<p>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</p>\n<p>C 语言传递参数一般是以值传递，也可以传递指针；</p>\n<p>通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；</p>\n<p>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</p>\n<p>C 语言的这些特性，可以让程序员在微观层面写出非常精细和精确的编程操作，让程序员可以在底层和系统细节上非常自由、灵活和精准地控制代码。</p>\n<p>然而，在代码组织和功能编程上，C 语言的上述特性，却不那么美妙了。</p>\n<p>从 C 语言的一个简单例子说起<br>我们从 C 语言最简单的交换两个变量的 swap 函数说起，参看下面的代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void swap(int* x, int* y)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int temp &#x3D; *x;</span><br><span class=\"line\">    *x &#x3D; *y;</span><br><span class=\"line\">    *y &#x3D; tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>你可以想一想，这里为什么要传指针？这里是 C 语言指针，因为如果你不用指针的话，那么参数变成传值，即函数的形参是调用实参的一个拷贝，函数里面对形参的修改无法影响实参的结果。为了要达到调用完函数后，实参内容的交换，必须要把实参的地址传递进来，也就是传指针。这样在函数里面做交换，实际变量的值也被交换了。</p>\n<p>然而，这个函数最大的问题就是它只能给 int 值用，这个世界上还有很多类型包括 double、float，这就是静态语言最糟糕的一个问题。</p>\n<h2 id=\"数据类型与现实世界的类比\"><a href=\"#数据类型与现实世界的类比\" class=\"headerlink\" title=\"数据类型与现实世界的类比\"></a>数据类型与现实世界的类比</h2><p>与现实世界类比一下，数据类型就好像螺帽一样，有多种接口方式：平口的、有十字的、有六角的等，而螺丝刀就像是函数，或是用来操作这些螺丝的算法或代码。我们发现，这些不同类型的螺帽（数据类型），需要我们为之适配一堆不同的螺丝刀。</p>\n<p>而且它们还有不同的尺寸（尺寸就代表它是单字节的，还是多字节的，比如整型的 int、long，浮点数的 float 和 double），这样复杂度一下就提高了，最终导致电工（程序员）工作的时候需要带下图这样的一堆工具。</p>\n<p>这就是类型为编程带来的问题。要解决这个问题，我们还是来看一下现实世界。</p>\n<p>你应该见过下面图片中的这种经过优化的螺丝刀，上面手柄是一样的，拧螺丝的动作也是一样的，只是接口不一样。每次我看到这张图片的时候就在想，这密密麻麻的看着有 40 多种接口，不知道为什么人类世界要干出这么多的花样？你们这群人类究竟是要干什么啊。</p>\n<p>我们可以看到，无论是传统世界，还是编程世界，我们都在干一件事情，什么事呢？那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些。</p>\n<p>然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的——泛型编程。</p>\n<p>另外，我们还要注意到，在编程世界里，对于 C 语言来说，类型还可以转换。编译器会使用一切方式来做类型转换，因为类型转换有时候可以让我们编程更方便一些，也让相近的类型可以做到一点点的泛型。</p>\n<p>然而，对于 C 语言的类型转换，是会出很多问题的。比如说，传给我一个数组，这个数组本来是 double 的，或者是 long 64 位的，但是如果把数组类型强转成 int，那么就会出现很多问题，因为这会导致程序遍历数组的步长不一样了。</p>\n<p>比如：一个 double a[10] 的数组，a[2] 意味着 a + sizeof(double) * 2。如果你把 a 强转成 int，那么 a[2] 就意味着 a + sizeof(int) * 2。我们知道 sizeof(double) 是 8，而 sizeof(int) 是 4。于是访问到了不同的地址和内存空间，这就导致程序出现严重的问题。</p>\n<h2 id=\"C-语言的泛型\"><a href=\"#C-语言的泛型\" class=\"headerlink\" title=\"C 语言的泛型\"></a>C 语言的泛型</h2><p>一个泛型的示例 - swap 函数<br>好了，我们再看下，C 语言是如何泛型的。C 语言的类型泛型基本上来说就是使用void *关键字或是使用宏定义。</p>\n<p>下面是一个使用了void*泛型版本的 swap 函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">void swap(void* x, void* y, size_t size)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     char tmp[size];</span><br><span class=\"line\">     memcpy(tmp, y, size);</span><br><span class=\"line\">     memcpy(y, x, size);</span><br><span class=\"line\">     memcpy(x, tmp, size);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面这个函数几乎完全改变了 int 版的函数的实现方式，这个实现方式有三个重点：</p>\n<p>函数接口中增加了一个size参数。为什么要这么干呢？因为，用了 void* 后，类型被“抽象”掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。</p>\n<p>函数的实现中使用了memcpy()函数。为什么要这样干呢？还是因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。</p>\n<p>函数的实现中使用了一个temp[size]数组。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。</p>\n<p>于是，新增的size参数，使用的memcpy内存拷贝以及一个 buffer，这增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度的提升。</p>\n<p>在提升复杂度的同时，我们发现还有问题，比如，我们想交换两个字符串数组，类型是：char<em>，那么，我的swap()函数的x和y参数是不是要用void*</em>了？这样一来，接口就没法定义了。</p>\n<p>除了使用 void<em> 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define swap(x, y, size) &#123;\\</span><br><span class=\"line\">    char temp[size]; \\</span><br><span class=\"line\">    memcpy(temp, &amp;y, size); \\</span><br><span class=\"line\">    memcpy(&amp;y,   &amp;x, size); \\</span><br><span class=\"line\">    memcpy(&amp;x, temp, size); \\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用void</em>和宏替换来说都可以达到泛型。</p>\n<p>但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，对于下面的这个宏：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#define min(x, y)  （(x)&gt;(y) ? (y) : (x)）</span><br></pre></td></tr></table></figure><br>其中一个最大的问题，就是有可能会有重复执行的问题。如：</p>\n<p><code>min(i++, j++)</code> 对于这个案例来说，我们本意是比较完后，对变量做累加，但是，因为宏替换的缘故，这会导致变量i或j被累加两次。<br><code>min(foo(), bar())</code> 对于这个示例来说，我们本意是比较 foo() 和 bar() 函数的返回值，然而，经过宏替换后，foo() 或 bar() 会被调用两次，这会带来很多问题。<br>另外，你会不会觉得无论是用哪种方式，这种“泛型”是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式，感觉是不是比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。</p>\n<p>从上面的两个例子，我们可以发现，无论哪种方式，接口都变得复杂了——加入了size，因为如果不加入size的话，那么我们的函数内部就需要自己检查size。然而，void* 这种地址的方式是没法得到size的。</p>\n<p>而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 sizeof(x) 这样的方式得到 size。但是如果类型是 char*，那么，使用sizeof方式只能提到指针类型的size，而不是值的size。另外，对于不同的类型，比如说double和int，那应该用谁的size呢？是不是先转一下型呢？这些都是问题。</p>\n<p>于是，这种泛型，让我们根本没有办法检查传入参数的size，导致我们只能增加接口复杂度，加入一个size参数，然后把这个问题抛给调用者了。</p>\n<h2 id=\"一个更为复杂的泛型示例-Search-函数\"><a href=\"#一个更为复杂的泛型示例-Search-函数\" class=\"headerlink\" title=\"一个更为复杂的泛型示例 - Search 函数\"></a>一个更为复杂的泛型示例 - Search 函数</h2><p>如果我们把这个事情变得更复杂，写个search函数，再传一个int数组，然后想搜索target，搜到返回数组下标，搜不到返回-1。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int search(int* a, size_t size, int target) &#123;</span><br><span class=\"line\">    for(int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class=\"line\">        if (a[i] &#x3D;&#x3D; target) &#123;</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到，这个函数是类型 int 版的。如果我们要把这个函数变成泛型的应该怎么变呢？</p>\n<p>就像上面swap()函数那样，如果要把它变成泛型，我们需要变更并复杂化函数接口。</p>\n<p>我们需要在函数接口上增加一个 element size，也就是数组里面每个元素的 size。这样，当我们遍历数组的时候，可以通过这个 size 正确地移动指针到下一个数组元素。</p>\n<p>我还要加个cmpFn。因为我要去比较数组里的每个元素和target是否相等。因为不同数据类型的比较的实现不一样，比如，整型比较用 == 就好了。但是如果是一个字符串数组，那么比较就需要用 strcmp 这类的函数。而如果你传一个结构体数组（如：Account 账号），那么比较两个数据对象是否一样就比较复杂了。所以，必须要自定义一个比较函数。</p>\n<p>最终我们的search函数的泛型版如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int search(void* a, size_t size, void* target,</span><br><span class=\"line\">    size_t elem_size, int(*cmpFn)(void*, void*) )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; why not use memcmp()</span><br><span class=\"line\">        &#x2F;&#x2F; use unsigned char * to calculate the address</span><br><span class=\"line\">        if ( cmpFn ((unsigned char *)a + elem_size * i, target) &#x3D;&#x3D; 0 ) &#123;</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在上面的代码中，我们没有使用memcmp()函数，这是因为，如果这个数组是一个指针数组，或是这个数组是一个结构体数组，而结构体数组中有指针成员。我们想比较的是指针指向的内容，而不是指针这个变量。所以，用memcmp()会导致我们在比较指针（内存地址），而不是指针所指向的值。</p>\n<p>而调用者需要提供如下的比较函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int int_cmp(int* x, int* y)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return *x - *y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int string_cmp(char* x, char* y)&#123;</span><br><span class=\"line\">    return strcmp(x, y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果面对有业务类型的结构体，可能会是这样的比较函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef struct _account &#123;</span><br><span class=\"line\">    char name[10];</span><br><span class=\"line\">    char id[20];</span><br><span class=\"line\">&#125; Account;</span><br><span class=\"line\"></span><br><span class=\"line\">int account_cmp(Account* x, Account* y) &#123;</span><br><span class=\"line\">    int n &#x3D; strcmp(x-&gt;name, y-&gt;name);</span><br><span class=\"line\">    if (n !&#x3D; 0) return n;</span><br><span class=\"line\">    return strcmp(x-&gt;id, y-&gt;id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们的 C 语言干成这个样子，看上去还行，但是，上面的这个search函数只能用于数组这样的顺序型的数据容器（数据结构）。如果这个search函数要能支持一些非顺序型的数据容器（数据结构），比如：堆、栈、哈希表、树、图。那么，用 C 语言来干基本上干不下去了，对于像search()这样的算法来说，数据类型的自适应问题就已经把事情搞得很复杂了。然而，数据结构的自适应就会把这个事的复杂度搞上几个数量级。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>这里，如果说，<strong>程序 = 算法 + 数据</strong>，我觉得 C 语言会有这几个问题。</p>\n<p>一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或 宏替换的方式，这两种方式导致了类型过于宽松，并带来很多其它问题。</p>\n<p>适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。</p>\n<p>算法其实是在操作数据结构，而数据则是放到数据结构中的。所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升。比如容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型，再比如对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。</p>\n<p>最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来。如何平衡和选择，并没有定论，也不好解决。</p>\n<p>总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理低层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。C 语言把非常底层的控制权交给了程序员，它设计的理念是：</p>\n<ul>\n<li>相信程序员；</li>\n<li>不会阻止程序员做任何底层的事；</li>\n<li>保持语言的最小和最简的特性；</li>\n<li>保证 C 语言的最快的运行速度，那怕牺牲移值性。</li>\n</ul>\n<p>从某种角度上来说，C 语言的伟大之处在于——使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制。这是 C 语言的强大和优雅之处。也有人说，C 语言是高级语言中的汇编语言。</p>\n<p>不过，这只是在针对底层指令控制和过程式的编程方式。而对于更高阶更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务更为抽象的语言。</p>\n<p>说到这里，我想你会问，那 C 语言本会怎么去解决这些问题呢？简单点说，C 语言并没有解决这些问题，所以才有了后面的 C++ 等其他语言，下一篇文章中，我也会和你聊聊 C++ 是如何解决这些问题的。</p>\n<p>C 语言诞生于 1972 年，到现在已经有 45 年的历史，在它之后，C++、Java、C# 等语言前仆后继，一浪高过一浪，都在试图解决那个时代的那个特定问题，我们不能去否定某个语言，但可以确定的是，随着历史的发展，每一门语言都还在默默迭代，不断优化和更新。同时，也会有很多新的编程语言带着新的闪光耀眼的特性出现在我们面前。</p>\n<p>再回过头来说，编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。</p>\n<p>比如 C 语言就是过程式的编程语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的“命运”。</p>\n<p>我们怎么解决上述 C 语言没有解决好的问题呢？请期待接下来的文章。</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编程范式游记（2）- 泛型编程","url":"/2016/01/02/mouse/programming-paradigm-travel-2-generic-programming/","content":"<p>上一篇文章中，我从 C 语言开始说起，聊了聊面向过程式的编程范式，相信从代码的角度你对这类型的语言已经有了一些理解。作为一门高级语言，C 语言绝对是编程语言历史发展中的一个重要里程碑，但随着认知的升级，面向过程的 C 语言已经无法满足更高层次的编程的需要。于是，C++ 出现了。<br><a id=\"more\"></a></p>\n<h2 id=\"C-语言\"><a href=\"#C-语言\" class=\"headerlink\" title=\"C++ 语言\"></a>C++ 语言</h2><p>1980 年，AT&amp;T 贝尔实验室的Bjarne Stroustrup创建的 C++ 语言横空出世，它既可以全面兼容 C 语言，又巧妙揉和了一些面向对象的编程理念。现在来看，不得不佩服 Stroustrup 的魄力。在这里，我也向你推荐一本书，书名是 <strong>《C++ 语言的设计和演化》</strong>。</p>\n<p>这本书系统介绍了 C++ 诞生的背景以及初衷，书的作者就是Stroustrup本人，所以你可以非常详细地从语言创建者的角度了解他的设计思路和创新之旅。当然，就是在今天，C++ 这门语言也还有很多争议，这里我不细说。如果你感兴趣的话，可以看看我几年前在酷壳上发表的文章《C++ 的坑真的多吗？》。</p>\n<p>从语言角度来说，实际上早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求（这也是 C++ 复杂晦涩的原因，这点 Java 就干得比 C++ 彻底得多）。在 C89、C99 这两个 C 语言的标准中，有许多改进正是从 C++ 中所引进的。</p>\n<p>可见，C++ 对 C 语言的贡献非常之大。是的，C++ 很大程度就是来解决 C 语言中的各种问题和各种不方便。比如：</p>\n<ul>\n<li>用引用来解决指针的问题。</li>\n<li>用 namespace 来解决名字空间冲突的问题。</li>\n<li>通过 try-catch 来解决检查返回值编程的问题。</li>\n<li>用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。</li>\n<li>通过重载操作符来达到操作上的泛型。（比如，消除上一篇文章中提到的比较函数cmpFn，再比如- 用&gt;&gt;操作符消除printf()的数据类型不够泛型的问题。）</li>\n<li>通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。</li>\n<li>用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。</li>\n<li>用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。</li>\n</ul>\n<h2 id=\"C-泛型编程\"><a href=\"#C-泛型编程\" class=\"headerlink\" title=\"C++ 泛型编程\"></a>C++ 泛型编程</h2><p>C++ 是支持编程范式最多的一门语言，它虽然解决了很多 C 语言的问题，但我个人觉得它最大的意义是解决了 C 语言泛型编程的问题。因为，我们可以看到一些 C++ 的标准规格说明书里面，有一半以上都在说明 STL 的标准规格应该是什么样的，这说明泛型编程是 C++ 重点中的重点。</p>\n<p>理想情况下，算法应是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作。算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求是什么？</p>\n<p>那 C++ 是如何有效解决程序泛型问题的呢？我认为有三点。</p>\n<p><strong>第一，它通过类的方式来解决。</strong></p>\n<p>类里面会有构造函数、析构函数表示这个类的分配和释放。<br>还有它的拷贝构造函数，表示了对内存的复制。<br>还有重载操作符，像我们要去比较大于、等于、不等于。这样可以让一个用户自定义的数据类型和内建的那些数据类型就很一致了。</p>\n<p><strong>第二，通过模板达到类型和算法的妥协。</strong></p>\n<p>模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。<br>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。<br>模板很好地取代了 C 时代的宏定义带来的问题。</p>\n<p><strong>第三，通过虚函数和运行时类型识别。</strong></p>\n<p>虚函数带来的多态在语义上可以让“同一类”的类型进行泛型。<br>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。<br>这样一来，就可以写出基于抽象接口的泛型。</p>\n<p>拥有了这些 C++ 引入的技术，我们就可以做到 C 语言很难做到的泛型编程了。</p>\n<p>正如前面说过的，一个良好的泛型编程需要解决如下几个泛型编程的问题：</p>\n<ul>\n<li>算法的泛型；</li>\n<li>类型的泛型；</li>\n<li>数据结构（数据容器）的泛型。</li>\n</ul>\n<h3 id=\"C-泛型编程的示例-Search-函数\"><a href=\"#C-泛型编程的示例-Search-函数\" class=\"headerlink\" title=\"C++ 泛型编程的示例 - Search 函数\"></a>C++ 泛型编程的示例 - Search 函数</h3><p>就像前面的search()函数，里面的 <code>for(int i=0; i&lt;len; i++)</code> 这样的遍历方式，只能适用于顺序型的数据结构的方式迭代，如：array、set、queue、list 和 link 等。并不适用于非顺序型的数据结构。</p>\n<p>如哈希表 hash table，二叉树 binary tree、图 graph 等这样数据不是按顺序存放的数据结构（数据容器）。所以，如果找不到一种泛型的数据结构的操作方式（如遍历、查找、增加、删除、修改……），那么，任何的算法或是程序都不可能做到真正意义上的泛型。</p>\n<p>除了search()函数的“遍历操作”之外，还有 search 函数的返回值，是一个整型的索引下标。这个整型的下标对于“顺序型的数据结构”是没有问题的，但是对于“非顺序的数据结构”，在语义上都存在问题。</p>\n<p>比如，如果我要在一个 hash table 中查找一个 key，返回什么呢？一定不是返回“索引下标”，因为在 hash table 这样的数据结构中，数据的存放位置不是顺序的，而且还会因为容量不够的问题被重新 hash 后改变，所以返回数组下标是没有意义的。</p>\n<p>对此，我们要把这个事做得泛型和通用一些。如果找到，返回找到的这个元素的一个指针（地址）会更靠谱一些。</p>\n<p>所以，为了解决泛型的问题，我们需要动用以下几个 C++ 的技术。</p>\n<ul>\n<li>使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。</li>\n<li>使用一个迭代器来遍历或是操作数据结构内的元素。</li>\n</ul>\n<p>我们来看一下 C++ 版的search()函数是什么样的。</p>\n<p>先重温一下 C 语言版的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">int search(void* a, size_t size, void* target,</span><br><span class=\"line\">    size_t elem_size, int(*cmpFn)(void*, void*) )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class=\"line\">        if ( cmpFn (a + elem_size * i, target) &#x3D;&#x3D; 0 ) &#123;</span><br><span class=\"line\">            return i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们再来看一下 C++ 泛型版的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;typename T, typename Iter&gt;</span><br><span class=\"line\">Iter search(Iter pStart, Iter pEnd, T target)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for(Iter p &#x3D; pStart; p !&#x3D; pEnd; p++) &#123;</span><br><span class=\"line\">        if ( *p &#x3D;&#x3D; target )</span><br><span class=\"line\">            return p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在 C++ 的泛型版本中，我们可以看到：</p>\n<ul>\n<li>使用typename T抽象了数据结构中存储数据的类型。</li>\n<li>使用typename Iter，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。</li>\n</ul>\n<p>然后，我们对数据容器的遍历使用了Iter中的++方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。</p>\n<p>在函数的入参上使用了pStart和pEnd来表示遍历的起止。</p>\n<p>使用*Iter来取得这个“指针”的内容。这也是通过重载 * 取值操作符来达到的泛型。</p>\n<p>当然，你可能会问，为什么我们不用标准接口<code>Iter.Next()</code>取代++， 用<code>Iter.GetValue()</code>来取代*，而是通过重载操作符？这样做是为了兼容原有 C 语言的编程习惯。</p>\n<p>说明一下，所谓的Iter，在实际代码中，就是像<code>vector&lt;int&gt;::iterator</code>或<code>map&lt;int</code>, <code>string&gt;::iterator</code>这样的东西。这是由相应的数据容器来实现和提供的。</p>\n<p>注：下面是 C++ STL 中的find()函数的代码。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;class InputIterator, class T&gt;</span><br><span class=\"line\">  InputIterator find (InputIterator first, InputIterator last, const T&amp; val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  while (first!&#x3D;last) &#123;</span><br><span class=\"line\">    if (*first&#x3D;&#x3D;val) return first;</span><br><span class=\"line\">    ++first;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"C-泛型编程示例-Sum-函数\"><a href=\"#C-泛型编程示例-Sum-函数\" class=\"headerlink\" title=\"C++ 泛型编程示例 - Sum 函数\"></a>C++ 泛型编程示例 - Sum 函数</h3><p>也许你觉得到这一步，我们的泛型设计就完成了。其实，还远远不够。search函数只是一个开始，我们还有很多别的算法会让问题变得更为复杂。</p>\n<p>我们再来看一个sum()函数。</p>\n<p>先看 C 语言版：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">long sum(int *a, size_t size) &#123;</span><br><span class=\"line\">    long result &#x3D; 0;</span><br><span class=\"line\">    for(int i&#x3D;0; i&lt;size; i++) &#123;</span><br><span class=\"line\">        result +&#x3D; a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>再看一下 C++ 泛型的版本：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;typename T, typename Iter&gt;</span><br><span class=\"line\">T sum(Iter pStart, Iter pEnd) &#123;</span><br><span class=\"line\">    T result &#x3D; 0;</span><br><span class=\"line\">    for(Iter p&#x3D;pStart; p!&#x3D;pEnd; p++) &#123;</span><br><span class=\"line\">        result +&#x3D; *p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>你看到了什么样的问题？这个代码中最大的问题就是 <code>T result = 0;</code> 这条语句：</p>\n<p>那个0假设了类型是int；<br>那个T假设了 Iter 中出来的类型是T。<br>这样的假设是有问题的，如果类型不一样，就会导致转型的问题，这会带来非常 buggy 的代码。那么，我们怎么解决呢？</p>\n<h3 id=\"C-泛型编程的重要技术-迭代器\"><a href=\"#C-泛型编程的重要技术-迭代器\" class=\"headerlink\" title=\"C++ 泛型编程的重要技术 - 迭代器\"></a>C++ 泛型编程的重要技术 - 迭代器</h3><p>我们知道Iter在实际调用者那会是一个具体的像<code>vector&lt;int&gt;::iterator</code>这样的东西。在这个声明中，int已经被传入Iter中了。所以，定义result的T应该可以从Iter中来。这样就可以保证类型是一样的，而且不会有被转型的问题。</p>\n<p>所以，我们需要精心地实现一个“迭代器”。下面是一个“精简版”的迭代器（我没有把 C++ STL 代码里的迭代器列出来，是因为代码太多太复杂，我这里只是为了说明问题）。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template &lt;class T&gt;</span><br><span class=\"line\">class container &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    class iterator &#123;</span><br><span class=\"line\">    public:</span><br><span class=\"line\">        typedef iterator self_type;</span><br><span class=\"line\">        typedef T   value_type;</span><br><span class=\"line\">        typedef T*  pointer;</span><br><span class=\"line\">        typedef T&amp;     reference;</span><br><span class=\"line\"></span><br><span class=\"line\">        reference operator*();</span><br><span class=\"line\">        pointer operator-&gt;();</span><br><span class=\"line\">        bool operator&#x3D;&#x3D;(const self_type&amp; rhs)；</span><br><span class=\"line\">        bool operator!&#x3D;(const self_type&amp; rhs)；</span><br><span class=\"line\">        self_type operator++() &#123; self_type i &#x3D; *this; ptr_++; return i; &#125;</span><br><span class=\"line\">        self_type operator++(int junk) &#123; ptr_++; return *this; &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    private:</span><br><span class=\"line\">        pointer _ptr;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    iterator begin();</span><br><span class=\"line\">    iterator end();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>上面的代码是我写的一个迭代器（这个迭代器在语义上是没有问题的），我没有把所有的代码列出来，而把它的一些基本思路列了出来。这里我说明一下几个关键点。</p>\n<p>首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。<br>它需要重载一些操作符，比如：取值操作*、成员操作-&gt;、比较操作==和!=，还有遍历操作++，等等。<br>然后，还要typedef一些类型，比如value_type，告诉我们容器内的数据的实际类型是什么样子。<br>还有一些，如begin()和end()的基本操作。<br>我们还可以看到其中有一个pointer _ptr的内部指针来指向当前的数据（注意，pointer就是 T*）。</p>\n<p>好了，有了这个迭代器后，我们还要解决T result = 0后面的这个0的问题。这个事，算法没有办法搞定，最好由用户传入。于是出现了下面最终泛型的sum()版函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template &lt;class Iter&gt;</span><br><span class=\"line\">typename Iter::value_type</span><br><span class=\"line\">sum(Iter start, Iter end, T init) &#123;</span><br><span class=\"line\">    typename Iter::value_type result &#x3D; init;</span><br><span class=\"line\">    while (start !&#x3D; end) &#123;</span><br><span class=\"line\">        result &#x3D; result + *start;</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们可以看到<code>typename Iter::value_type result = init</code>这条语句是关键。我们解决了所有的问题。</p>\n<p>我们如下使用：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">container&lt;int&gt; c;</span><br><span class=\"line\">container&lt;int&gt;::iterator it &#x3D; c.begin();</span><br><span class=\"line\">sum(c.begin(), c.end(), 0);</span><br></pre></td></tr></table></figure><br>这就是整个 STL 的泛型方法，其中包括：</p>\n<ul>\n<li>泛型的数据容器；</li>\n<li>泛型数据容器的迭代器；</li>\n<li>然后泛型的算法就很容易写了。</li>\n<li>需要更多的抽象</li>\n<li>更为复杂的需求</li>\n</ul>\n<p>但是，还能不能做到更为泛型呢？比如：如果我们有这样的一个数据结构 Employee，里面有 vacation 就是休假多少天，以及工资。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct Employee &#123;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    string id;</span><br><span class=\"line\">    int vacation;</span><br><span class=\"line\">    double salary；</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>现在我想计算员工的总薪水，或是总休假天数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;Employee&gt; staff;</span><br><span class=\"line\">&#x2F;&#x2F;total salary or total vacation days?</span><br><span class=\"line\">sum(staff.begin(), staff.end(), 0);</span><br></pre></td></tr></table></figure><br>我们的sum完全不知道怎么搞了，因为要累加的是Employee类中的不同字段，即便我们的 Employee 中重载了+操作，也不知道要加哪个字段。</p>\n<p>另外，我们可能还会有：求平均值 average，求最小值 min，求最大值 max，求中位数 mean 等等。你会发现，算法写出来基本上都是一样的，只是其中的“累加”操作变成了另外一个操作。就这个例子而言，就是，我想计算员工薪水里面最高的，和休假最少的，或者我想计算全部员工的总共休假多少天。那么面对这么多的需求，我们是否可以泛型一些呢？怎样解决这些问题呢？</p>\n<h2 id=\"更高维度的抽象\"><a href=\"#更高维度的抽象\" class=\"headerlink\" title=\"更高维度的抽象\"></a>更高维度的抽象</h2><p>要解决这个问题，我希望我的这个算法只管遍历，具体要干什么，那是业务逻辑，由外面的调用方来定义我就好了，和我无关。这样一来，代码的重用度就更高了。</p>\n<p>下面是一个抽象度更高的版本，这个版本再叫sum就不太合适了。这个版本应该是reduce——用于把一个数组 reduce 成一个值。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;class Iter, class T, class Op&gt;</span><br><span class=\"line\">T reduce (Iter start, Iter end, T init, Op op) &#123;</span><br><span class=\"line\">    T result &#x3D; init;</span><br><span class=\"line\">    while ( start !&#x3D; end ) &#123;</span><br><span class=\"line\">        result &#x3D; op( result, *start );</span><br><span class=\"line\">        start++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码中，我们需要传一个函数进来。在 STL 中，它是个函数对象，我们还是这套算法，但是 result 不是像前面那样去加，是把整个迭代器值给你一个 operation，然后由它来做。我把这个方法又拿出去了，所以就会变成这个样子。</p>\n<p>在 C++ STL 中，与我的这个 reduce 函数对应的函数名叫 accumulate()，其实际代码有两个版本。</p>\n<p>第一个版本就是上面的版本，只不过是用for语句而不是while。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;class InputIt, class T&gt;</span><br><span class=\"line\">T accumulate(InputIt first, InputIt last, T init)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (; first !&#x3D; last; ++first) &#123;</span><br><span class=\"line\">        init &#x3D; init + *first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return init;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>第二个版本，更为抽象，因为需要传入一个“二元操作函数”——BinaryOperation op来做 accumulate。accumulate 的语义比 sum 更抽象了。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;class InputIt, class T, class BinaryOperation&gt;</span><br><span class=\"line\">T accumulate(InputIt first, InputIt last, T init,</span><br><span class=\"line\">             BinaryOperation op)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (; first !&#x3D; last; ++first) &#123;</span><br><span class=\"line\">        init &#x3D; op(init, *first);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return init;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>来看看我们在使用中是什么样子的：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">double sum_salaries &#x3D;</span><br><span class=\"line\">  reduce( staff.begin(), staff.end(), 0.0,</span><br><span class=\"line\">          [](double s, Employee e)</span><br><span class=\"line\">            &#123;return s + e.salary;&#125;  );</span><br><span class=\"line\"></span><br><span class=\"line\">double max_salary &#x3D;</span><br><span class=\"line\">  reduce( staff.begin(), staff.end(), 0.0,</span><br><span class=\"line\">          [](double s, Employee e)</span><br><span class=\"line\">            &#123;return s &gt; e.salary? s: e.salary; &#125; );</span><br></pre></td></tr></table></figure><br>注意：我这里用了 C++ 的 lambda 表达式。</p>\n<p>你可以很清楚地看到，reduce 这个函数就更通用了，具体要干什么样的事情呢？放在匿名函数里面，它会定义我，我只做一个 reduce。更抽象地来说，我就把一个数组，一个集合，变成一个值。怎么变成一个值呢？由这个函数来决定。</p>\n<h3 id=\"Reduce-函数\"><a href=\"#Reduce-函数\" class=\"headerlink\" title=\"Reduce 函数\"></a>Reduce 函数</h3><p>我们来看看如何使用 reduce 和其它函数完成一个更为复杂的功能。</p>\n<p>下面这个示例中，我先定义了一个函数对象counter。这个函数对象需要一个Cond的函数对象，它是个条件判断函数，如果满足条件，则加 1，否则加 0。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;class T, class Cond&gt;</span><br><span class=\"line\">struct counter &#123;</span><br><span class=\"line\">    size_t operator()(size_t c, T t) const &#123;</span><br><span class=\"line\">        return c + (Cond(t) ? 1 : 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>然后，我用上面的counter函数对象和reduce函数共同来打造一个counter_if算法（当条件满足的时候我就记个数，也就是统计满足某个条件的个数），我们可以看到，就是一行代码的事。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">template&lt;class Iter, class Cond&gt;</span><br><span class=\"line\">size_t count_if(Iter begin, Iter end, Cond c)&#123;</span><br><span class=\"line\">    return reduce(begin, end, 0,</span><br><span class=\"line\">                  counter&lt;Iter::value_type, Cond&gt;(c));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>至于是什么样的条件，这个属于业务逻辑，不是我的流程控制，所以，这应该交给使用方。</p>\n<p>于是，当我需要统计薪资超过 1 万元的员工的数量时，一行代码就完成了。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">size_t cnt &#x3D; count_if(staff.begin(), staff.end(), [](Employee e)&#123; return e.salary &gt; 10000; &#125;);</span><br></pre></td></tr></table></figure><br>Reduce 时可以只对结构体中的某些值做 Reduce，比如说只对 salary&gt;10000 的人做，只选出这个里面的值，它用 Reduce 就可以达到这步，只要传不同的方式给它，你就可以又造出一个新的东西出来。</p>\n<p>说着说着，就到了函数式编程。函数式编程里面，我们可以用很多的像 reduce 这样的函数来完成更多的像 STL 里面的count_if()这样的有具体意义的函数。关于函数式编程，我们会在后面继续具体聊。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>在这篇文章中，我们聊到 C++ 语言是如何通过泛型来解决 C 语言遇到的问题的，其实这里面主要就是泛型编程和函数式编程的基本方法相关的细节，虽然解决编程语言中类型带来的问题可能有多种方式，不一定就是 C++ 这种方式。</p>\n<p>而我之所以从 C/C++ 开始，目的只是因为 C/C++ 都是比较偏底层的编程语言。从底层的原理上，我们可以更透彻地了解，从 C 到 C++ 的演进这一过程中带来的编程方式的变化。这可以让你看到，在静态类型语言方面解决泛型编程的一些技术和方法，从而感受到其中的奥妙和原理。</p>\n<p>因为形式是多样的，但是原理是相通的。所以，这个过程会非常有助于你更深刻地了解后面会谈到的更多的编程范式。</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编程范式游记（6）- 面向对象编程","url":"/2016/01/06/mouse/programming-paradigm-travel-6-object-oriented-programming/","content":"<p>前面讲完了函数式编程，主要讲的是把一些功能或逻辑代码通过函数的拼装方式来组织的玩法。其中涉及最多的是函数，也就是编程中的代码逻辑。但我们知道，代码中还是需要处理数据的，这些就是所谓的“状态”，函数式编程需要我们写出无状态的代码。<br><a id=\"more\"></a><br>而这天下并不存在没有状态没有数据的代码，如果函数式编程不处理状态这些东西，那么，状态会放在什么地方呢？总是需要一个地方放这些数据的。</p>\n<p>对于状态和数据的处理，我们有必要提一下“面向对象编程”（Object-oriented programming，缩写为 OOP）这个编程范式了。我们知道，面向对象的编程有三大特性：<strong>封装、继承和多态</strong>。</p>\n<p>面向对象编程是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。</p>\n<p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象。</p>\n<p>目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。</p>\n<p>现在，几乎所有的主流语言都支持面向对象，比如：Common Lisp、Python、C++、Objective-C、Smalltalk、Delphi、Java、Swift、C#、Perl、Ruby 与 PHP 等。</p>\n<p>说起面向对象，就不得不提由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合作出版的《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software）一书，在此书中共收录了 23 种设计模式。</p>\n<p>这本书的 23 个经典的设计模式，基本上就是说了两个面向对象的核心理念。</p>\n<ul>\n<li>&quot;Program to an &#39;interface&#39;, not an &#39;implementation&#39;.&quot;<ul>\n<li>使用者不需要知道数据类型、结构、算法的细节。</li>\n<li>使用者不需要知道实现细节，只需要知道提供的接口。</li>\n<li>利于抽象、封装、动态绑定、多态。</li>\n<li>符合面向对象的特质和理念。</li>\n</ul>\n</li>\n<li>&quot;Favor &#39;object composition&#39; over &#39;class inheritance&#39;.&quot;<ul>\n<li>继承需要给子类暴露一些父类的设计和实现细节。</li>\n<li>父类实现的改变会造成子类也需要改变。</li>\n<li>我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。</li>\n<li>继承更多的应该是为了多态。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"示例一：拼装对象\"><a href=\"#示例一：拼装对象\" class=\"headerlink\" title=\"示例一：拼装对象\"></a>示例一：拼装对象</h4><p>好，我们先来看一个示例，假设我们有如下的描述：</p>\n<p>四个物体：木头桌子、木头椅子、塑料桌子、塑料椅子</p>\n<p>四个属性：燃点、密度、价格、重量</p>\n<p>那么，我们怎么用面向对象的方式来设计我们的类呢？</p>\n<p>参看下图：</p>\n<p>图的左边是“材质类” Material。其属性有燃点和密度。</p>\n<p>图的右边是“家具类” Furniture。其属性有价格和体积。</p>\n<p>在 Furniture 中耦合了 Material。而具体的 Material 是 Wood 还是 Plastic，这是在构造对象的时候注入到 Furniture 里就好了。</p>\n<p>这样，在家具类中，通过材料的密度属性和家具的体积属性就可以计算出重量属性。</p>\n<p>这样设计的优点显而易见，它能和现实世界相对应起来。而且，材料类是可以重用的。这个模式也表现了面向对象的拼装数据的另一个精髓——喜欢组合，而不是继承。这个模式在设计模式里叫“桥接模式”。</p>\n<p>和函数式编程来比较，函数式强调于动词，而面向对象强调于名词，面向对象更多的关注于接口间的关系，而通过多态来适配不同的具体实现。</p>\n<h4 id=\"示例二：拼装功能\"><a href=\"#示例二：拼装功能\" class=\"headerlink\" title=\"示例二：拼装功能\"></a>示例二：拼装功能</h4><p>再来看一个示例。我们的需求是这样的——处理订单，处理订单有一个关键的动作就是计算订单的价格。有的订单需要打折，有的则不打折。</p>\n<p>在进行面向对象编程时，假设我们用 Java 语言，我们需要先写一个接口—— BillingStrategy，其中就是一个方法：GetActPrice(double rawPrice)，输入一个原始的价格，输出一个根据相应的策略计算出来的价格。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface BillingStrategy &#123;</span><br><span class=\"line\">    public double GetActPrice(double rawPrice);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个接口很简单，只是对接口的抽象，而与实现无关。现在我们需要对这个接口进行实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Normal billing strategy (unchanged price)</span><br><span class=\"line\">class NormalStrategy implements BillingStrategy &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public double GetActPrice(double rawPrice) &#123;</span><br><span class=\"line\">        return rawPrice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Strategy for Happy hour (50% discount)</span><br><span class=\"line\">class HappyHourStrategy implements BillingStrategy &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public double GetActPrice(double rawPrice) &#123;</span><br><span class=\"line\">        return rawPrice * 0.5;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码实现了两个策略，一个是不打折的：NormalStrategy，一个是打了 5 折的：HappyHourStrategy。</p>\n<p>于是，我们先封装订单项 OrderItem，其包含了每个商品的原始价格和数量，以及计算价格的策略。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class OrderItem &#123;</span><br><span class=\"line\">    public String Name;</span><br><span class=\"line\">    public double Price;</span><br><span class=\"line\">    public int Quantity;</span><br><span class=\"line\">    public BillingStrategy Strategy;</span><br><span class=\"line\">    public OrderItem(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class=\"line\">        this.Name &#x3D; name;</span><br><span class=\"line\">        this.Price &#x3D; price;</span><br><span class=\"line\">        this.Quantity &#x3D; quantity;</span><br><span class=\"line\">        this.Strategy &#x3D; strategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>然后，在我们的订单类—— Order 中封装了 OrderItem 的列表，即商品列表。并在操作订单添加购买商品时，加入一个计算价格的 BillingStrategy。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Order &#123;</span><br><span class=\"line\">    private List&lt;OrderItem&gt; orderItems &#x3D; new ArrayList&lt;OrderItem&gt;();</span><br><span class=\"line\">    private BillingStrategy strategy &#x3D; new NormalStrategy();</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Add(String name, double price, int quantity, BillingStrategy strategy) &#123;</span><br><span class=\"line\">        orderItems.add(new OrderItem(name, price, quantity, strategy));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Payment of bill</span><br><span class=\"line\">    public void PayBill() &#123;</span><br><span class=\"line\">        double sum &#x3D; 0;</span><br><span class=\"line\">        for (OrderItem item : orderItems) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            actPrice &#x3D; item.Strategy.GetActPrice(item.price * item.quantity);</span><br><span class=\"line\">            sum +&#x3D; actPrice;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(&quot;%s -- %f(%d) - %f&quot;,</span><br><span class=\"line\">                    item.name, item.price, item.quantity, actPrice);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;Total due: &quot; + sum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>最终，我们在 PayBill() 函数中，把整个订单的价格明细和总价打印出来。</p>\n<p>在上面这个示例中，可以看到，我把订价策略和订单处理的流程分开了。这么做的好处是，我们可以随时给不同的商品注入不同的价格计算策略，这样一来就有很高的灵活度了。剩下的事就交给我们的运营人员来配置不同的商品使用什么样的价格计算的策略了。</p>\n<p>注意，现实社会中，订单价格计算会比这个事复杂得多，比如：有会员价，有打折卡，还有商品的打包价等，而且还可以叠加不同的策略（叠加策略用前面说的函数式的 pipeline 或 decorator 就可以实现）。我们这里只是为了说明面向对象编程范式，所以故意简单化了。</p>\n<p>其实，这个设计模式叫——策略模式。我认为，这是设计模式中最为经典的模式了，其充分体现了面向对象编程的方式。</p>\n<h4 id=\"示例三：资源管理\"><a href=\"#示例三：资源管理\" class=\"headerlink\" title=\"示例三：资源管理\"></a>示例三：资源管理</h4><p>先看一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mutex m;</span><br><span class=\"line\"></span><br><span class=\"line\">void foo() &#123;</span><br><span class=\"line\">    m.lock();</span><br><span class=\"line\">    Func();</span><br><span class=\"line\">    if ( ! everythingOk() ) return;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，上面这段代码是有问题的，原因是，那个 if 语句返回时没有把锁给 unlock 掉，这会导致锁没有被释放。如果我们要把代码写对，需要在 return 前 unlock 一下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mutex m;</span><br><span class=\"line\"></span><br><span class=\"line\">void foo() &#123;</span><br><span class=\"line\">    m.lock();</span><br><span class=\"line\">    Func();</span><br><span class=\"line\">    if ( ! everythingOk() ) &#123;</span><br><span class=\"line\">        m.unlock();</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    m.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但是，在所有的函数退出的地方都要加上 m.unlock(); 语句，这会让我们很难维护代码。于是可以使用面向对象的编程模式，我们先设计一个代理类。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class lock_guard &#123;</span><br><span class=\"line\">    private:</span><br><span class=\"line\">        mutex &amp;_m;</span><br><span class=\"line\">    public:</span><br><span class=\"line\">        lock_guard(mutex &amp;m):_m(m) &#123; _m.lock(); &#125;</span><br><span class=\"line\">        ~lock_guard() &#123; _m.unlock(); &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>然后，我们的代码就可以这样写了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">mutex m;</span><br><span class=\"line\"></span><br><span class=\"line\">void foo() &#123;</span><br><span class=\"line\">    lock_guard guard(m);</span><br><span class=\"line\">    Func();</span><br><span class=\"line\">    if ( ! everythingOk() ) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个技术叫 RAII（Resource Acquisition Is Initialization）， 是 C++ 中的一个利用了面向对象的技术。这个设计模式叫“代理模式”。我们可以把一些控制资源分配和释放的逻辑交给这些代理类，然后，就只需要关注业务逻辑代码了。而且，在我们的业务逻辑代码中，减少了这些和业务逻辑不相关的程序控制的代码。</p>\n<p>从上面的代码中，我们可以看到下面几个面向对象的事情。</p>\n<p>我们使用接口抽象了具体的实现类。</p>\n<p>然后其它类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性。</p>\n<p>因为这就是接口编程，所谓接口也就是一种“协议”，就像 HTTP 协议一样。浏览器和后端的程序都依赖于这一种协议，而不是具体实现（如果是依赖具体实现，那么浏览器就要依赖后端的编程语言或中间件了，这就太恶心了）。于是，浏览器和后端的程序就完全解开依赖关系，而去依赖于一个标准的协议。</p>\n<p>这就是面向对象的编程范式的精髓！同样也是 IoC/DIP（控制反转 / 依赖倒置）的本质。</p>\n<h3 id=\"IoC-控制反转\"><a href=\"#IoC-控制反转\" class=\"headerlink\" title=\"IoC 控制反转\"></a>IoC 控制反转</h3><p>关于 IoC 的的概念提出来已经很多年了，其被用于一种面向对象的设计。我在这里再简单地回顾一下这个概念。我先谈技术，再说管理。</p>\n<p>话说，我们有一个开关要控制一个灯的开和关这两个动作，最常见也是最没有技术含量的实现会是这个样子：</p>\n<p>然后，有一天，我们发现需要对灯泡扩展一下，于是做了个抽象类：</p>\n<p>但是，如果有一天，我们发现这个开关可能还要控制别的不单单是灯泡的东西，就会发现这个开关耦合了灯泡这种类别，非常不利于扩展，于是反转控制出现了。</p>\n<p>就像现实世界一样，造开关的工厂根本不关心要控制的东西是什么，它只做一个开关应该做好的事，就是把电接通，把电断开（不管是手动的，还是声控的，还是光控，还是遥控的）。而我们造的各种各样的灯泡（不管是日光灯，白炽灯）的工厂也不关心你用什么样的开关，反正我只管把灯的电源接口给做出来。然后，开关厂和电灯厂依赖于一个标准的通电和断电的接口。于是产生了 IoC 控制反转，如下图。</p>\n<p>所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备。也就是说，开关从依赖设备这种情况，变成了，设备反过来依赖于开关所定义的接口。</p>\n<p>这样的例子在生活中太多见了。比如说：</p>\n<p>钱就是一个很好的例子。以前大家都是“以物易物”，所以，在各种物品之前都需要相应的“交易策略”，比如：一头羊换 2 袋米，一袋米换一斤猪后腿肉……这种换算太复杂了。于是，“钱”就出来了，所谓“钱”，其实就是一种交易协议，所有的商品都依赖这个协议，而不用再互相依赖了。于是整个世界的运作就简单了很多。</p>\n<p>在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接依赖和控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。</p>\n<p>上面这个例子，可能还不明显，再举一个例子。海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法。随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。</p>\n<p>实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商。让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。</p>\n<p>这个思维方式其实还深远地影响了很多东西，比如我们的系统架构。</p>\n<p>云计算平台中有很多的云产品线。一些底层服务的开发团队只管开发底层的技术，然后什么也不管了，就交给上层的开发人员。上层开发人员在底层团队开发出来的产品上面开发各种管理这个底层资源的东西，比如：生产底层资源的业务，底层资源的控制台，底层资源的监控系统。<br>然而，随着接入的资源的越来越多，上层为各个云资源控制生产，开发控制台和监控的团队，完全干不过来了。这个时候依赖倒置和反转控制又可以解决问题了。为了有统一一致的云产品体验，各个云产品线需要遵从一定的协议或规范来开发。比如，每个云产品团队需要按照标准定义相关资源的生命周期管理，提供控制台，接入整体监控系统，通过标准的协议开发控制系统。</p>\n<p>集中式处理电子商务订单的流程。各个垂直业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多。于是，这个技术平台开始发现，对来自各个业务方的需求应接不暇，各种变态需求严重干扰系统，各种技术决策越来越不好做，导致需求排期排不过来。<br>这个时候，也可以使用依赖倒置和反转控制的思想来解决问题：开发一个插件模型、工作流引擎和 Pub/Sub 系统，让业务方的个性化需求可以以插件的方式插入订单流程中。业务方自己的数据存在自己的库中，业务逻辑也不要侵入系统，并可以使用工作流引擎或 Pub/Sub 的协议标准来自己定义工作流的各个步骤（甚至把工作流引擎的各个步骤的 decider 交给各个业务方自行处理）。</p>\n<p>让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。</p>\n<p>上面这些我想说什么？我想说的是：</p>\n<p>我们每天都在标准化和定制化中纠结。我们痛苦于哪些应该是平台要做的，哪些应该要甩出去的。</p>\n<p>这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口……</p>\n<p>通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。</p>\n<p>总而言之，我们就是想通过一种标准来让业务更为规范。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>不过，我们也需要知道面向对象的优缺点。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>能和真实的世界交相辉映，符合人的直觉。</li>\n<li>面向对象和数据库模型设计类型，更多地关注对象间的模型设计。</li>\n<li>强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。</li>\n<li>根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。</li>\n<li>拥有大量非常优秀的设计原则和设计模式。</li>\n<li>S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。</li>\n<li>代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。</li>\n<li>因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。</li>\n<li>还是好多人并不是喜欢面向对象，尤其是喜欢函数式和泛型那些人，似乎都是非常讨厌面向对象的。</li>\n<li>通过对象来达到抽象结果，把代码分散在不同的类里面，然后，要让它们执行起来，就需要把这些类粘合起来。所以，它另外一方面鼓励相当厚重的代码黏合层（代码黏合层就是把代码黏合到这里面）。</li>\n<li>在 Java 里有很多注入方式，像 Spring 那些注入，鼓励黏合，导致了大量的封装，完全不知道里面在干什么事情。而且封装屏蔽了细节，具体发生啥事你还不知道。这些都是面向对象不太好的地方。</li>\n</ul>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"编写一个简单的JavaScript模板引擎","url":"/2016/09/22/note/note-a-simple-javaScript-template-engine/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>能够访问到这篇文章的同学，初衷是想知道如何编写JavaScript的模板引擎。为了照顾一些没有使用过模板引擎的同学，先来稍微介绍一下什么叫模板引擎。如果没有使用过模板引擎，但是又尝试过在页面渲染一个列表的时候，那么一般的做法是通过拼接字符串实现的，如下：<br><a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const arr &#x3D; [&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;google&quot;,</span><br><span class=\"line\">\t&quot;url&quot;: &quot;https:&#x2F;&#x2F;www.google.com&quot;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;baidu&quot;,</span><br><span class=\"line\">\t&quot;url&quot;: &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;</span><br><span class=\"line\">&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">let html &#x3D; &#39;&#39;</span><br><span class=\"line\">html +&#x3D; &#39;&lt;ul&gt;&#39;</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">\thtml +&#x3D; &#96;&lt;li&gt;&lt;a href&#x3D;&quot;$&#123;arr[i].url&#125;&quot;&gt;$&#123;arr[i].name&#125;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#96;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">html +&#x3D; &#39;&lt;&#x2F;ul&gt;&#39;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，我使用了ES6的反引号(``)语法动态生成了一个ul列表，看上去貌似不会复杂（如果使用字符串拼接，会繁琐很多），但是这里有一点糟糕的是：数据和结构强耦合。这导致的问题是如果数据或者结构发生变化时，都需要改变上面的代码，这在当下前端开发中是不能忍受的，我们需要的是数据和结构松耦合。如果要实现松耦合，那么就应该结构归结构，数据从服务器获取并整理好之后，再通过模板渲染数据，这样我们就可以将精力放在JavaScript上了。而使用模板引擎的话是这样实现的。如下：<br>HTML列表<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">&lt;% for (var i &#x3D; 0; i &lt; obj.users.length; i++) &#123; %&gt;</span><br><span class=\"line\">\t&lt;li&gt;</span><br><span class=\"line\">\t\t&lt;a href&#x3D;&quot;&lt;%&#x3D; obj.users[i].url %&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;%&#x3D; obj.users[i].name %&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;a&gt;</span><br><span class=\"line\">\t&lt;&#x2F;li&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><br>JS数据<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const arr &#x3D; [&#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;google&quot;,</span><br><span class=\"line\">\t&quot;url&quot;: &quot;https:&#x2F;&#x2F;www.google.com&quot;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">\t&quot;name&quot;: &quot;baidu&quot;,</span><br><span class=\"line\">\t&quot;url&quot;: &quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;</span><br><span class=\"line\">&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">const html &#x3D; tmpl(&#39;list&#39;, arr)</span><br><span class=\"line\">console.log(html)</span><br></pre></td></tr></table></figure><br>打印出的结果为<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &lt;li&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.google.com&quot;&gt;google&lt;&#x2F;a&gt;</span><br><span class=\"line\">    &lt;&#x2F;li&gt;</span><br><span class=\"line\">    &lt;li&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;baidu&lt;&#x2F;a&gt;</span><br><span class=\"line\">    &lt;&#x2F;li&gt;</span><br><span class=\"line\">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><br>从以上的代码可以看出，将结构和数据传入tmpl函数中，就能实现拼接。而tmpl正是我们所说的模板引擎（函数）。</p>\n<p>接下来我们就来实现一下这个函数。</p>\n<p>模板引擎的实现通过函数将数据塞到模板里面，函数内部的具体实现还是通过拼接字符串来实现。而通过模板的方式，可以降低拼接字符串出错而造成时间成本的增加。而模板引擎函数实现的本质，就是将模板中HTML结构与JavaScript语句、变量分离，通过Function构造函数 + apply(call)动态生成具有数据性的HTML代码。而如果要考虑性能的话，可以将模板进行缓存处理。请记住上面所说的本质，甚至背诵下来。实现一个模板引擎函数，大致有以下步骤：</p>\n<p>模板获取模板中HTML结构与JavaScript语句、变量分离Function + apply(call)动态生成JavaScript代码模板缓存OK，接下来看看如何实现吧: )模板获取一般情况下，我们会把模板写在script标签中，赋予id属性，标识模板的唯一性；赋予type=&#39;text/html&#39;属性，标识其MIME类型为HTML，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type&#x3D;&quot;text&#x2F;html&quot; id&#x3D;&quot;template&quot;&gt;</span><br><span class=\"line\">\t&lt;ul&gt;</span><br><span class=\"line\">\t\t&lt;% if (obj.show) &#123; %&gt;</span><br><span class=\"line\">\t\t\t&lt;% for (var i &#x3D; 0; i &lt; obj.users.length; i++) &#123; %&gt;</span><br><span class=\"line\">\t\t\t\t&lt;li&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;a href&#x3D;&quot;&lt;%&#x3D; obj.users[i].url %&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t\t\t&lt;%&#x3D; obj.users[i].name %&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;&#x2F;a&gt;</span><br><span class=\"line\">\t\t\t\t&lt;&#x2F;li&gt;</span><br><span class=\"line\">\t\t\t&lt;% &#125; %&gt;</span><br><span class=\"line\">\t\t&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">\t\t\t&lt;p&gt;不展示列表&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t&lt;% &#125; %&gt;</span><br><span class=\"line\">\t&lt;&#x2F;ul&gt;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<p>在模板引擎中，选用&lt;% xxx %&gt;标识JavaScript语句，主要用于流程控制，无输出；&lt;%= xxx %&gt;标识JavaScript变量，用于将数据输出到模板；其余部分都为HTML代码。（与EJS类似）。当然，你也可以用&lt;@ xxx @&gt;, &lt;=@ @&gt;、&lt;* xxx *&gt;, &lt;*= xxx *&gt;等。传入模板引擎函数中的第一个参数，可以是一个id，也可以是模板字符串。此时，需要通过正则去判断是模板字符串还是id。如下<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let tpl &#x3D; &#39;&#39;</span><br><span class=\"line\">const tmpl &#x3D; (str, data) &#x3D;&gt; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %,  等）；如果是id，则需要通过getElementById获取</span><br><span class=\"line\">    if (!&#x2F;[\\s\\W]&#x2F;g.test(str)) &#123;</span><br><span class=\"line\">        tpl &#x3D; document.getElementById(str).innerHTML</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        tpl &#x3D; str</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>HTML结构与JavaScript语句、变量分离这一步骤是引擎中最最最重要的步骤，如果实现了，那就是实现了一大步了。所以我们使用两种方法来实现。假如获取到的模板字符串如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">\t&lt;% if (obj.show) &#123; %&gt;</span><br><span class=\"line\">\t\t&lt;% for (var i &#x3D; 0; i &lt; obj.users.length; i++) &#123; %&gt;</span><br><span class=\"line\">\t\t\t&lt;li&gt;</span><br><span class=\"line\">\t\t\t\t&lt;a href&#x3D;&quot;&lt;%&#x3D; obj.users[i].url %&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;%&#x3D; obj.users[i].name %&gt;</span><br><span class=\"line\">\t\t\t\t&lt;&#x2F;a&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;li&gt;</span><br><span class=\"line\">\t\t&lt;% &#125; %&gt;</span><br><span class=\"line\">\t&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">\t\t&lt;p&gt;不展示列表&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t&lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><br>先来看看第一种方法吧，主要是通过replace函数替换实现的。说明一下主要流程：创建数组arr，再拼接字符串arr.push(&#39;遇到换行回车，替换为空字符串遇到&lt;%时，替换为&#39;);遇到&gt;%时，替换为arr.push(&#39;遇到&lt;%= xxx %&gt;，结合第3、4步，替换为&#39;); arr.push(xxx); arr.push(&#39;最后拼接字符串&#39;); return p.join(&#39;&#39;);在代码中，需要将第5步写在2、3步骤前面，因为有更高的优先级，否则会匹配出错。如下<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let tpl &#x3D; &#39;&#39;</span><br><span class=\"line\">const tmpl &#x3D; (str, data) &#x3D;&gt; &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %,  等）；如果是id，则需要通过getElementById获取</span><br><span class=\"line\">  if (!&#x2F;[\\s\\W]&#x2F;g.test(str)) &#123;</span><br><span class=\"line\">      tpl &#x3D; document.getElementById(str).innerHTML</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">      tpl &#x3D; str</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  let result &#x3D; &#96;let p &#x3D; []; p.push(&#39;&#96;</span><br><span class=\"line\">  result +&#x3D; &#96;$&#123;</span><br><span class=\"line\">\ttpl.replace(&#x2F;[\\r\\n\\t]&#x2F;g, &#39;&#39;)</span><br><span class=\"line\">\t   .replace(&#x2F;&lt;%&#x3D;\\s*([^%&gt;]+?)\\s*%&gt;&#x2F;g, &quot;&#39;); p.push($1); p.push(&#39;&quot;)</span><br><span class=\"line\">\t   .replace(&#x2F;&lt;%&#x2F;g, &quot;&#39;);&quot;)</span><br><span class=\"line\">\t   .replace(&#x2F;%&gt;&#x2F;g, &quot;p.push(&#39;&quot;)</span><br><span class=\"line\">  &#125;&#96;</span><br><span class=\"line\">  result +&#x3D; &quot;&#39;); return p.join(&#39;&#39;);&quot;      </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>细细品味上面的每一个步骤，就能够将HTML结构和JavaScript语句、变量拼接起来了。拼接之后的代码如下（格式化代码了，否则没有换行的）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let p &#x3D; [];</span><br><span class=\"line\">p.push(&#39;&lt;ul&gt;&#39;);</span><br><span class=\"line\">if (obj.show) &#123;</span><br><span class=\"line\">    p.push(&#39;&#39;);</span><br><span class=\"line\">    for (var i &#x3D; 0; i &lt; obj.users.length; i++) &#123;</span><br><span class=\"line\">        p.push(&#39;&lt;li&gt;&lt;a href&#x3D;&quot;&#39;);</span><br><span class=\"line\">        p.push(obj.users[i].url);</span><br><span class=\"line\">        p.push(&#39;&quot;&gt;&#39;);</span><br><span class=\"line\">        p.push(obj.users[i].name);</span><br><span class=\"line\">        p.push(&#39;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p.push(&#39;&#39;);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    p.push(&#39;&lt;p&gt;不展示列表&lt;&#x2F;p&gt;&#39;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p.push(&#39;&lt;&#x2F;ul&gt;&#39;);</span><br><span class=\"line\">return p.join(&#39;&#39;);</span><br></pre></td></tr></table></figure><br>这里要注意的是，我们不能将JavaScript语句push到数组里面，而是单独存在。因为如果以JS语句的形式push进去，会报错；如果以字符串的形式push进去，那么就不会有作用了，比如for循环、if判断都会无效。当然JavaScript变量push到数组内的时候，要注意也不能以字符串的形式，否则会无效。如<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.push(&#39;for(var i &#x3D;0; i &lt; obj.users.length; i++)&#123;&#39;)  &#x2F;&#x2F; 无效</span><br><span class=\"line\">p.push(&#39;obj.users[i].name&#39;) &#x2F;&#x2F; 无效</span><br><span class=\"line\">p.push(for(var i &#x3D;0; i &lt; obj.users.length; i++)&#123;)  &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure><br>从模板引擎函数可以看出，我们是通过单引号来拼接HTML结构的，这里如果稍微思考一下，如果模板中出现了单引号，那会影响整个函数的执行的。还有一点，如果出现了 \\ 反引号，会将单引号转义了。所以需要对单引号和反引号做一下优化处理。模板中遇到 \\ 反引号，需要转义遇到 &#39; 单引号，需要将其转义转换为代码，即为<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">str.replace(&#x2F;\\\\&#x2F;g, &#39;\\\\\\\\&#39;)</span><br><span class=\"line\">    .replace(&#x2F;&#39;&#x2F;g, &quot;\\\\&#39;&quot;)</span><br><span class=\"line\">&#96;&#96;&#96;   </span><br><span class=\"line\">结合上面的部分，即</span><br></pre></td></tr></table></figure><br>let tpl = &#39;&#39;<br>const tmpl = (str, data) =&gt; {<br>  // 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %,  等）；如果是id，则需要通过getElementById获取<br>  if (!/[\\s\\W]/g.test(str)) {<br>      tpl = document.getElementById(str).innerHTML<br>  } else {<br>      tpl = str<br>  }<br>  let result = <code>let p = []; p.push(&#39;</code><br>  result += <code>${\n    tpl.replace(/[\\r\\n\\t]/g, &#39;&#39;)\n           .replace(/\\\\/g, &#39;\\\\\\\\&#39;)\n           .replace(/&#39;/g, &quot;\\\\&#39;&quot;)\n       .replace(/&lt;%=\\s*([^%&gt;]+?)\\s*%&gt;/g, &quot;&#39;); p.push($1); p.push(&#39;&quot;)\n       .replace(/&lt;%/g, &quot;&#39;);&quot;)\n       .replace(/%&gt;/g, &quot;p.push(&#39;&quot;)\n  }</code><br>  result += &quot;&#39;); return p.join(&#39;&#39;);&quot;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里的模板引擎函数用了ES6的语法和正则表达式，如果对正则表达式懵逼的同学，可以先去学习正则先，懂了之后再回头看这篇文章，会恍然大悟的。OK，来看看第二种方法实现模板引擎函数。跟第一种方法不同的是，不只是使用replace函数进行简单的替换。简单说一下思路：需要一个正则表达式&#x2F;&lt;%&#x3D;?\\s*([^%&gt;]+?)\\s*%&gt;&#x2F;g， 可以匹配&lt;% xxx %&gt;, &lt;%&#x3D; xxx %&gt;需要一个辅助变量cursor，记录HTML结构匹配的开始位置需要使用exec函数，匹配过程中内部的index值会根据每一次匹配成功后动态的改变其余一些逻辑与第一种方法类似OK，我们来看看具体的代码</span><br></pre></td></tr></table></figure><br>let tpl = &#39;&#39;<br>let match = &#39;&#39;  // 记录exec函数匹配到的值<br>// 匹配模板id<br>const idReg = /[\\s\\W]/g<br>// 匹配JavaScript语句或变量<br>const tplReg = /&lt;%=?\\s<em>(<sup><a href=\"#fn_%>\" id=\"reffn_%>\">%></a></sup>+?)\\s</em>%&gt;/g</p>\n<p>const add = (str, result) =&gt; {<br>    str = str.replace(/[\\r\\n\\t]/g, &#39;&#39;)<br>        .replace(/\\/g, &#39;\\\\&#39;)<br>        .replace(/&#39;/g, &quot;\\&#39;&quot;)<br>    result += <code>result.push(&#39;${string}&#39;);</code><br>    return result<br>}</p>\n<p>const tmpl = (str, data) =&gt; {<br>    // 记录HTML结构匹配的开始位置<br>    let cursor = 0<br>    let result = &#39;let result = [];&#39;<br>    // 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %,  等）；如果是id，则需要通过getElementById获取<br>    if (!idReg.test(str)) {<br>        tpl = document.getElementById(str).innerHTML<br>    } else {<br>        tpl = str<br>    }<br>        // 使用exec函数，每次匹配成功会动态改变index的值<br>    while (match = tplReg.exec(tpl)) {<br>        result = add(tpl.slice(cursor, match.index), result) // 匹配HTML结构<br>        result = add(match[1], result)                     // 匹配JavaScript语句、变量<br>        cursor = match.index + match[0].length                 // 改变HTML结果匹配的开始位置<br>    }<br>    result = add(tpl.slice(cursor), result)                                 // 匹配剩余的HTML结构<br>    result += &#39;return result.join(&quot;&quot;)&#39;<br>}<br>console.log(tmpl(&#39;template&#39;))<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">上面使用了辅助函数add，每次传入str的时候，都需要对传入的模板字符串做优化处理，防止模板字符串中出现非法字符（换行，回车，单引号&#39;，反引号\\ 等）。执行后代码格式化后如下（实际上没有换行，因为替换成空字符串了，为了好看..）。</span><br></pre></td></tr></table></figure><br>let result =[];<br>result.push(&#39;<ul>');\nresult.push('if (obj.show) {');\nresult.push('');\nresult.push('for (var i = 0; i < obj.users.length; i++) {');\nresult.push('<li><a href=\"');\nresult.push('obj.users[i].url');\nresult.push('\">');\nresult.push('obj.users[i].name');\nresult.push('</a></li>');\nresult.push('}');\nresult.push('');\nresult.push('} else {');\nresult.push('<p>什么鬼什么鬼</p>');\nresult.push('}');\nresult.push('</ul>&#39;);<br>return result.join(&quot;&quot;)<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">从以上代码中，可以看出HTML结构作为字符串push到result数组了。但是JavaScript语句也push进去了，变量作为字符串push进去了.. 原因跟第一种方法一样，要把语句单独拎出来，变量以自身push进数组。改造一下代码</span><br></pre></td></tr></table></figure><br>let tpl = &#39;&#39;<br>let match = &#39;&#39;  // 记录exec函数匹配到的值<br>// 匹配模板id<br>const idReg = /[\\s\\W]/g<br>// 匹配JavaScript语句或变量<br>const tplReg = /&lt;%=?\\s<em>(<sup><a href=\"#fn_%>\" id=\"reffn_%>\">%></a></sup>+?)\\s</em>%&gt;/g<br>const keyReg = /(for|if|else|switch|case|break|{|})/g   // <em>**</em> 增加正则匹配语句</p>\n<p>const add = (str, result, js) =&gt; {<br>    str = str.replace(/[\\r\\n\\t]/g, &#39;&#39;)<br>        .replace(/\\/g, &#39;\\\\&#39;)<br>        .replace(/&#39;/g, &quot;\\&#39;&quot;)<br>        // <em>**</em> 增加三元表达式的判断，三种情况：JavaScript语句、JavaScript变量、HTML结构。<br>    result += js ? str.match(keyReg) ? <code>${str}</code> : <code>result.push(${str});</code> : <code>result.push(&#39;${str}&#39;);</code><br>    return result<br>}</p>\n<p>const tmpl = (str, data) =&gt; {<br>    // 记录HTML结构匹配的开始位置<br>    let cursor = 0<br>    let result = &#39;let result = [];&#39;<br>    // 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %,  等）；如果是id，则需要通过getElementById获取<br>    if (!idReg.test(str)) {<br>        tpl = document.getElementById(str).innerHTML<br>    } else {<br>        tpl = str<br>    }<br>        // 使用exec函数，每次匹配成功会动态改变index的值<br>    while (match = tplReg.exec(tpl)) {<br>        result = add(tpl.slice(cursor, match.index), result) // 匹配HTML结构<br>        result = add(match[1], result, true)             // <em>**</em> 匹配JavaScript语句、变量<br>        cursor = match.index + match[0].length                 // 改变HTML结果匹配的开始位置<br>    }<br>    result = add(tpl.slice(cursor), result)                     // 匹配剩余的HTML结构<br>    result += &#39;return result.join(&quot;&quot;)&#39;<br>}<br>console.log(tmpl(&#39;template&#39;))<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">执行后的代码格式化后如下</span><br></pre></td></tr></table></figure><br>let result = [];<br>result.push(&#39;<ul>');\nif (obj.show) {\n    result.push('');\n    for (var i = 0; i < obj.users.length; i++) {\n        result.push('<li><a href=\"');\n        result.push(obj.users[i].url);\n        result.push('\">');\n        result.push(obj.users[i].name);\n        result.push('</a></li>');\n    }\n    result.push('');\n} else {\n    result.push('<p>什么鬼什么鬼</p>');\n}\nresult.push('</ul>&#39;);<br>return result.join(&quot;&quot;)<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">至此，已经达到了我们的要求。两种模板引擎函数的实现已经介绍完了，这里稍微总结一下两种方法都使用了数组，拼接完成后再join一下第一种方法纯属使用replace函数，匹配成功后进行替换第二种方法使用exec函数，利用其动态改变的index值捕获到HTML结构、JavaScript语句和变量当然，两种方法都可以使用字符串拼接，但是我在Chrome浏览器中对比了一下，数组还是快很多的呀，所以这也算是一个优化方案吧：用数组拼接比字符串拼接要快50%左右！</span><br><span class=\"line\"></span><br><span class=\"line\">以下是字符串和数组拼接的验证</span><br></pre></td></tr></table></figure><br>console.log(&#39;开始计算字符串拼接&#39;)<br>const start2 = Date.now()<br>let str = &#39;&#39;<br>for (var i = 0; i &lt; 9999999; i++) {<br>  str += &#39;1&#39;<br>}<br>const end2 = Date.now()<br>console.log(<code>字符串拼接运行时间: ${end2 - start2}</code>ms)</p>\n<p>console.log(&#39;----------------&#39;)</p>\n<p>console.log(&#39;开始计算数组拼接&#39;)<br>const start1 = Date.now()<br>const arr = []<br>for (var i = 0; i &lt; 9999999; i++) {<br>  arr.push(&#39;1&#39;)<br>}<br>arr.join(&#39;&#39;)<br>const end1 = Date.now()<br>console.log(<code>数组拼接运行时间: ${end1 - start1}</code>ms)<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">结果如下：  </span><br><span class=\"line\">开始计算字符串拼接  </span><br><span class=\"line\">字符串拼接运行时间: 2548ms</span><br><span class=\"line\"></span><br><span class=\"line\">开始计算数组拼接  </span><br><span class=\"line\">数组拼接运行时间: 1359ms  </span><br><span class=\"line\"></span><br><span class=\"line\">Function + apply(call)动态生成HTML代码上面两种方法中，result是字符串，怎么将其变成可执行的JavaScript代码呢？这里使用了Function构造函数来创建一个函数（当然也可以使用eval函数，但是不推荐）大多数情况下，创建一个函数会直接使用函数声明或函数表达式的方式</span><br></pre></td></tr></table></figure><br>function test () {}<br>const test = function test () {}<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">以这种方式生成的函数会成为Function构造函数的实例对象test instanceof Function   &#x2F;&#x2F; true</span><br><span class=\"line\">当然也可以直接使用Function构造函数直接创建一个函数，这样做的性能会稍微差了一些（双重解析，JavaScript解析JavaScript代码，代码包含在字符串中，也就是说在 JavaScript 代码运行的同时必须新启动一个解析器来解析新的代码。实例化一个新的解析器有不容忽视的开销，所以这种代码要比直接解析慢得多。）</span><br></pre></td></tr></table></figure><br>const test = new Function(&#39;arg1&#39;, &#39;arg2&#39;, ... , &#39;console.log(arg1 + arg2)&#39;)<br>test(1 + 2) // 3<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">鱼和熊掌不可得兼，渲染便利的同时带来了部分的性能损失Function构造函数可以传入多个参数，最后一个参数代表执行的语句。因此我们可以这样const fn &#x3D; new Funcion(result)</span><br><span class=\"line\">如果需要传入参数，可以使用call或者apply改变函数执行时所在的作用域即可。fn.apply(data)</span><br><span class=\"line\"></span><br><span class=\"line\">模板缓存使用模板的原因不仅在于避免手动拼接字符串而带来不必要的错误，而且在某些场景下可以复用模板代码。为了避免同一个模板多次重复拼接字符串，可以将模板缓存起来。我们这里缓存当传入的是id时可以缓存下来。实现的逻辑不复杂，在接下来的代码可以看到。好了， 结合上面讲到的所有内容，给出两种方式实现的模板引擎的最终代码第一种方法：</span><br></pre></td></tr></table></figure><br>let tpl = &#39;&#39;<br>// 匹配模板的id<br>let idReg = /[\\s\\W]/g<br>const cache = {}</p>\n<p>const add = tpl =&gt; {<br>    // 匹配成功的值做替换操作<br>    return tpl.replace(/[\\r\\n\\t]/g, &#39;&#39;)<br>        .replace(/\\/g, &#39;\\\\&#39;)<br>        .replace(/&#39;/g, &quot;\\&#39;&quot;)<br>        .replace(/&lt;%=\\s<em>(<sup><a href=\"#fn_%>\" id=\"reffn_%>\">%></a></sup>+?)\\s</em>%&gt;/g, &quot;&#39;); p.push($1); p.push(&#39;&quot;)<br>        .replace(/&lt;%/g, &quot;&#39;);&quot;)<br>        .replace(/%&gt;/g, &quot;p.push(&#39;&quot;)<br>}</p>\n<p>const tmpl = (str, data) =&gt; {<br>    let result = <code>let p = []; p.push(&#39;</code><br>        // 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %,  等）；如果是id，则需要通过getElementById获取<br>    if (!idReg.test(str)) {<br>        tpl = document.getElementById(&#39;template&#39;).innerHTML<br>        if (cache[str]) {<br>            return cache[str].apply(data)<br>        }<br>    } else {<br>        tpl = str<br>    }<br>    result += add(tpl)<br>    result += &quot;&#39;); return p.join(&#39;&#39;);&quot;<br>    let fn = new Function(result)        // 转成可执行的JS代码<br>    if (!cache[str] &amp;&amp; !idReg.test(str)) {    // 只用传入的是id的情况下才缓存模板<br>        cache[str] = fn<br>    }<br>    return fn.apply(data)                                        // apply改变函数执行的作用域<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">第二种方法：</span><br></pre></td></tr></table></figure><br>let tpl = &#39;&#39;<br>let match = &#39;&#39;<br>const cache = {}<br>// 匹配模板id<br>const idReg = /[\\s\\W]/g<br>// 匹配JavaScript语句或变量<br>const tplReg = /&lt;%=?\\s<em>(<sup><a href=\"#fn_%>\" id=\"reffn_%>\">%></a></sup>+?)\\s</em>%&gt;/g<br>// 匹配各种关键字<br>const keyReg = /(for|if|else|switch|case|break|{|})/g</p>\n<p>const add = (str, result, js) =&gt; {<br>    str = str.replace(/[\\r\\n\\t]/g, &#39;&#39;)<br>        .replace(/\\/g, &#39;\\\\&#39;)<br>        .replace(/&#39;/g, &quot;\\&#39;&quot;)<br>    result += js ? str.match(keyReg) ? <code>${str}</code> : <code>result.push(${str});</code> : <code>result.push(&#39;${str}&#39;);</code><br>    return result<br>}</p>\n<p>const tmpl = (str, data) =&gt; {<br>    let cursor = 0<br>    let result = &#39;let result = [];&#39;<br>        // 如果是模板字符串，会包含非单词部分（&lt;, &gt;, %,  等）；如果是id，则需要通过getElementById获取<br>    if (!idReg.test(str)) {<br>        tpl = document.getElementById(str).innerHTML<br>        // 缓存处理<br>        if (cache[str]) {<br>            return cache[str].apply(data)<br>        }<br>    } else {<br>        tpl = str<br>    }<br>    // 使用exec函数，动态改变index的值<br>    while (match = tplReg.exec(tpl)) {<br>        result = add(tpl.slice(cursor, match.index), result) // 匹配HTML结构<br>        result = add(match[1], result, true)             // 匹配JavaScript语句、变量<br>        cursor = match.index + match[0].length             // 改变HTML结果匹配的开始位置<br>    }<br>    result = add(tpl.slice(cursor), result)                     // 匹配剩余的HTML结构<br>    result += &#39;return result.join(&quot;&quot;)&#39;<br>    let fn = new Function(result)                             // 转成可执行的JS代码<br>    if (!cache[str] &amp;&amp; !idReg.test(str)) {                       // 只有传入的是id的情况下才缓存模板<br>        cache[str] = fn<br>    }<br>    return fn.apply(data)                                      // apply改变函数执行的作用域<br>}<br>```</p>\n<p>最后呼，基本上说完了，最后还是想稍微总结一下假如！假如面试的时候面试官问你，请大致描述一下JavaScript模板引擎的原理，那么以下的总结可能会给予你一些帮助。噢.. 模板引擎实现的原理大致是将模板中的HTML结构和JavaScript语句、变量分离，将HTML结构以字符串的形式push到数组中，将JavaScript语句独立抽取出来，将JavaScript变量以其自身push到数组中，通过replace函数的替换或者exec函数的遍历，构建出带有数据的HTML代码，最后通过Function构造函数 + apply(call)函数生成可执行的JavaScript代码。如果回答出来了，面试官心里顿时发现千里马：欸，好像很叼也？</p>\n<p>接着试探一下：<br>为什么要用数组？<br>可以用字符串吗？<br>两者有什么区别？<br>简单的一下replace和exec函数的使用？<br>exec 和match函数有什么不同？<br>/&lt;%=?\\s<em>(<sup><a href=\"#fn_%>\" id=\"reffn_%>\">%></a></sup>+?)\\s</em>%&gt;/g 这段正则是什么意思？<br>简单说明apply、call、bind函数的区别？<br>Function构造函数的使用，有什么弊端？<br>函数声明和函数表达式的区别？<br>....<br>这一段总结还可以扯出好多知识点... 翻滚吧，千里马！OK，至此，关于实现一个简单的JavaScript模板引擎就介绍到这里了，如果读者耐心、细心的看完了这篇文章，我相信你的收获会是满满的。如果看完了仍然觉得懵逼，如果不介意的话，可以再多品味几次。</p>\n","categories":["javascript"],"tags":["note","javascript"]},{"title":"VS Code为什么能这么牛?","url":"/2020/03/16/note/note-vscode-why-so-good/","content":"<p>VS Code 无疑是非常成功的。读完这篇文章对其成功也窥见一二，但远不止如此。文中表达的观点也与我一直以来对架构设计的认识相同：</p>\n<ul>\n<li>简洁：实现目标的情况下，更简洁的东西才更能生命力</li>\n<li>聚焦：明白一个东西要做什么事情，做好应该做的事情</li>\n<li>取舍：有舍有得，放弃是一件很难的事情。但是只有在聚焦的基础有所放弃，才能强化本来应该做的事情。<a id=\"more\"></a>\n</li>\n</ul>\n<blockquote>\n<p>文章转自码农翻身</p>\n</blockquote>\n<p>Visual Studio Code（VS Code）近年来获得了爆炸式增长，成为广大开发者工具库中的必备神器。它作为一个开源项目，也吸引了无数第三方开发者和终端用户，成为顶尖开源项目之一。它在功能上做到了够用，体验上做到了好用，更在拥有海量插件的情况下做到了简洁流畅，实属难能可贵。</p>\n<p>我是VS Code用户，同时也为它开发插件，插件市场里的众多Java插件基本都是我们团队的作品，所以我在日常工作中观察到不少VS Code在工程方面的亮点，下面就来逐一探讨。</p>\n<h2 id=\"简洁而聚焦的产品定位，贯穿始终\"><a href=\"#简洁而聚焦的产品定位，贯穿始终\" class=\"headerlink\" title=\"简洁而聚焦的产品定位，贯穿始终\"></a>简洁而聚焦的产品定位，贯穿始终</h2><p>你知道VS Code的开发团队人数只有二十出头吗？</p>\n<p>难以相信吧，大家都觉得VS Code无所不能，如此强大的工具那么几个人怎么做得出来。实际上功能丰富是个美好的错觉，因为大部分针对特定编程语言和技术的功能都是第三方插件提供的，VS Code的核心始终非常精简，这很考验产品团队的拿捏能力：做多了，臃肿，人手也不够；做少了，太弱，没人用。</p>\n<p>他们团队选择了专注于核心功能的开发，为用户提供简洁流畅的体验，并将该思路贯穿在产品开发的每个环节。在我看来，这就是第一个亮点。</p>\n<p>第一个亮点同时也是一个难点，因为“简洁”说到底是产品的“形态”，更关键的其实是前置问题——产品的定位，它到底解决什么问题。该问题如果从用户的角度来看，可以转换为以下几个点——我们为什么需要一个新的工具？它到底是代码编辑器(Editor)还是集成开发环境(IDE)？让我们来看看项目负责人Erich Gamma 的说法：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/KyXfCrME6UIqiaLBvCPXibnTVMY66whB7GGF0Oia9yXCQa9ytVIVswc95OFXDVPAsFJQicAUNVCo9kcCmhAWk3gnZA/640?wx_fmt=jpeg\" alt=\"视频截图 - Erich阐述了VS Code的定位：编辑器+代码理解+调试\"></p>\n<p>(视频截图 - Erich阐述了VS Code的定位：编辑器+代码理解+调试)</p>\n<p>这张截图它阐述了VS Code的定位：<strong>编辑器+代码理解+调试</strong>。这是一个非常节制而平衡的选择，专注于开发者“最常用”的功能，同时在产品的形式上力求简洁高效。从结果来看，这个定位是相当成功的。</p>\n<p>在这个定位的指导下，这二十多位工程师搞出了VS Code。相对较小的功能集，使得开发者们能在代码质量上精益求精，最终用户们也得到了一个性能优异的工具，这是VS Code从一众编辑器中脱颖而出的重要原因。</p>\n<p>正因为产品定位以及团队职责上的高度节制，团队成员才能把时间花在这类问题上，写出经得起考验的代码。</p>\n<p>与此同时，较小的团队也使得团队成员做到了行为层面的整齐划一，这点在社区互动上体现得尤为明显，大家可以去GitHub上看他们的Issues，超出产品定位范畴的请求和反馈基本都被婉拒或者转交到第三方插件项目，可以说是很专注了。</p>\n<p>看到这里，似乎一切都好，但问题来了，码农千千万，你用Node我用Go，你搞前端我弄后台，VS Code如何满这些五花八门的需求呢？机智的你已经抢答了——海量插件。那么接下来我们来深究一下VS Code是如何经营一个庞大的插件生态的。</p>\n<h2 id=\"进程隔离的插件模型\"><a href=\"#进程隔离的插件模型\" class=\"headerlink\" title=\"进程隔离的插件模型\"></a>进程隔离的插件模型</h2><p>通过插件来扩展功能的做法已经是司空见惯了，但如何保证插件和原生功能一样优秀呢？历史告诉我们：不能保证。</p>\n<p>大家可以参考Eclipse，插件模型可以说是做得非常彻底了，功能层面也是无所不能，但存在几个烦人的问题：不稳定、难用、慢，所以不少用户转投IntelliJ的怀抱。可谓成也插件，败也插件。</p>\n<p>问题的本质在于信息不对称，它导致不同团队写出来的代码，无论是思路还是质量，都不一致。最终，用户得到了一个又乱又卡的产品。所以要让插件在稳定性、速度和体验的层面都做到和原生功能统一，只能是一个美好的愿望。</p>\n<p>来看看其他IDE是怎么做的，Visual Studio自己搞定所有功能，并且做到优秀，让别人无事可做，这也成就了其“宇宙第一IDE”的美名；IntelliJ与之相仿，开箱即用，插件可有可无。这么看起来，自己搞定所有的事情是个好办法，但大家是否知道，Visual Studio背后有上千人的工程团队，显然，这不是VS Code这二十几号人能搞定的。他们选择了让大家来做插件，那怎么解决Eclipse所遇到的问题呢？</p>\n<p>这里分享一个小知识——Eclipse核心部分的开发者就是早期的VS Code团队。嗯，所以他们没有两次踏入同一条河流。<strong>与Eclipse不同，VS Code选择了把插件关进盒子里</strong>。</p>\n<p>这样做首先解决的问题就是稳定性，这个问题对于VS Code来说尤为重要。都知道VS Code基于Electron，实质上是个Node.js环境，单线程，任何代码崩了都是灾难性后果。所以VS Code干脆不信任任何人，把插件们放到单独的进程里，任你折腾，主程序妥妥的。</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/KyXfCrME6UIqiaLBvCPXibnTVMY66whB7GbsNDM0ZJovGGl2P8SzqFO6mZVSaPKxovBz0GgqXLHc6HlIDYy8ONKg/640?wx_fmt=jpeg\" alt=\"插件与主进程隔离\"></p>\n<p>插件与主进程隔离</p>\n<p>VS Code团队的这一决策不是没有原因的，正如前面提到的，团队里很多人其实是Eclipse的旧部，自然对Eclipse的插件模型有深入的思考。Eclipse的设计目标之一就是把组件化推向极致，所以很多核心功能都是用插件的形式来实现的。遗憾的是，Eclipse的插件运行在主进程中，任何插件性能不佳或者不稳定，都直接影响到Eclipse，最终结果是大家抱怨Eclipse臃肿、慢、不稳定。VS Code基于进程做到了物理级别的隔离，成功解决了该问题。实际上进程级别的隔离也带出了另一个话题，那就是界面与业务逻辑的隔离。</p>\n<h2 id=\"UI渲染与业务逻辑隔离，一致的用户体验\"><a href=\"#UI渲染与业务逻辑隔离，一致的用户体验\" class=\"headerlink\" title=\"UI渲染与业务逻辑隔离，一致的用户体验\"></a>UI渲染与业务逻辑隔离，一致的用户体验</h2><p>“不稳定”之后的问题是“难用”，具体来说就是混乱的界面和流程，究其原因就是插件之间的界面语言的“不一致”，它导致学习曲线异常陡峭，并且在面临问题时没有统一的解决路径。VS Code的做法是根本不给插件们“发明”新界面的机会。</p>\n<p>如上图，插件们被关在Extension Host进程里，而UI则在主进程里，所以插件们天然没法直接在用户界面上做手脚。</p>\n<p>VS Code统管所有用户交互入口，制定交互的标准，所有用户的操作被转化为各种请求发送给插件，插件能做的就是响应这些请求，专注于业务逻辑。但从始至终，<strong>插件都不能“决定”或者“影响”界面元素如何被渲染（颜色、字体等，一概不行）</strong>，至于弹对话框什么的，就更是天方夜谭了。</p>\n<p>VS Code对于用户界面的把控可以说是谨慎到变态，做过插件的人都懂的，感兴趣的同学可以去深挖一下TreeView的历史，会有更直观的体会。乍一看，第三方开发者被卡得死死的，这样不是限制了大家的创造力吗？我想说这个做法跟这个团队的背景密切相关，换一拨人很有可能会失败。他们之所以能成功，是因为该团队在开发工具领域深耕多年，他们把经验转换为观点，最终落实到了VS Code的界面元素以及交互语言上，从结果来看，广受欢迎。</p>\n<p>界面和业务逻辑的彻底隔离，使得所有插件有了一致的行为，用户就得到了整齐划一的体验。不仅如此，这种接口和行为层面的一致性，最终转化成了另一个“伟大”的功能——Remote Development，我们稍后讨论。接下来我们要聊的是VS Code另一个创举——Language Server Protocol。</p>\n<h2 id=\"LSP——基于文本的协议\"><a href=\"#LSP——基于文本的协议\" class=\"headerlink\" title=\"LSP——基于文本的协议\"></a>LSP——基于文本的协议</h2><p>前文提到了VS Code定位中的两个特色：代码理解和调试，绝大部分都由第三方插件来实现，中间的桥梁就是两大协议——Language Server Protocol(LSP)和Debug Adapter Protocol(DAP)。两者从设计的角度来看高度相似，我们着重看一下最火的LSP。首先，为什么需要LSP？</p>\n<p>全栈开发早已成为这个时代的主流，软件从业者们也越来越不被某个特定的语言或者技术所局限，这也对我们手里的金刚钻提出了新的挑战。</p>\n<p>举个栗子，我用TypeScript和Node.js做前端，同时用Java写后台，偶尔也用Python做一些数据分析，那么我很有可能需要若干工具的组合，这样做的问题就在于需要在工具间频繁切换，无论从系统资源消耗和用户体验的角度来看，都是低效的。</p>\n<p>那么有没有一种工具能在同一个工作区里把三个语言都搞定呢？没错，就是VS Code——支持多语言的开发环境，而多语言支持的基础就是Language Server Protocol(LSP)。</p>\n<p>该协议在短短几年内取得了空前的成功，到目前为止，已经有来自微软等大厂以及社区的一百个实现，基本覆盖了所有主流编程语言。同时，它也被其他开发工具所采纳，比如Atom、Vim、Sublime、Emacs、Visual Studio和Eclipse，从另一个角度证明了它的优秀。</p>\n<p>更难能可贵的是，该协议还做到了轻量和快速，可以说是VS Code的杀手级特性了，同时也是微软最重要的IP之一。。。哇塞，又强大又轻巧，怎么看都是个骗局啊，那我们就来看看它到底怎么做到的。</p>\n<p>先划重点：<strong>1、节制的设计 2、合理的抽象 2、周全的细节。</strong></p>\n<p>先来说说设计(Design)，大而全是很常见的问题。如果让我来设计这么一个用来支持所有编程语言的东西，第一反应很可能是搞个涵盖所有语言特性的超集。</p>\n<p>微软就有过这样的尝试，比如Roslyn——一个语言中立的编译器，C#和VB.NET的编译器都是基于它做的。大家都知道C#在语言特性层面是非常丰富的，Roslyn能撑起C#足以说明它的强大。那么问题来了，为啥它没有在社区得到广泛应用呢？我想根本原因是“强大”所带来的副作用：复杂、主观(Opinionated)。光是语法树就已经很复杂了，其他各种特性以及他们之间的关系更是让人望而却步，这样一个庞然大物，普通开发者是不会轻易去碰的。</p>\n<p>相较之下，LSP显然把小巧作为设计目标之一，它选择做最小子集，贯彻了团队一贯节制的作风。它<strong>关心的是用户在编辑代码时最经常处理的物理实体（比如文件、目录）和状态（光标位置）</strong>。它根本没有试图去理解语言的特性，编译也不是它所关心的问题，所以自然不会涉及语法树一类的复杂概念。</p>\n<p>它也不是一步到位的，而是随着VS Code功能的迭代而逐步发展的。所以它自诞生至今依然保持着小巧的身材，易懂，实现门槛也很低，迅速在社区得到了广泛的支持，各种语言的Language Server(LS)遍地开花。</p>\n<p>小归小，功能可不能少，所以抽象就非常关键了。LSP最重要的概念是动作和位置，LSP的大部分请求都是在表达”在指定位置执行规定动作“。</p>\n<p>举个栗子，用户把鼠标悬停在某个类名上方，查看相关的定义和文档。这时VS Code会发送一个&#39;textDocument/hover&#39;请求给LS，这个请求里最关键的信息就是当前的文档和光标的位置。LS收到请求之后，经过一系列内部计算（识别出光标位置所对应的符号，并找出相关文档），找出相关的信息，然后发回给VS Code显示给用户看。这样一来一回的交互，在LSP里被抽象成请求(Request)和回复(Response)，LSP同时也规定了它们的规格(Schema)。在开发者看来，概念非常少，交互形式也很简单，实现起来非常轻松。</p>\n<p>看到这里，大家应该对LSP有了更进一步的理解，它本质上是胶水，把VS Code和各种语言的LS粘在一起。但它不是普通的胶水，而是非常有品位的胶水，这品位就体现在细节上。</p>\n<p>首先这是一个基于文本的协议，文本降低了理解和调试的难度。参考HTTP和REST的成功，很难想象如果这是一个二进制协议会是什么局面，甚至同样是文本协议的SOAP也早已作古，足以说明“简单”在打造开发者生态里的重要性。</p>\n<p>其次这是一个基于JSON的协议，JSON可以说是最易读的结构化数据格式了，大家看看各个代码仓库里的配置文件都是啥格式就知道这是个多么正确的决定了，现在还有人在新项目里用XML吗？又一次——“简单”。</p>\n<p>再次，这是一个基于JSONRPC的协议，由于JSON的流行，各大语言都对它有极好的支持，所以开发者根本不需要处理序列化、反序列化一类的问题，这是实现层面的“简单”。</p>\n<p>从这些细节可以看出，VS Code团队对当今技术趋势的把握是相当精准的，他们决策充分考虑到了“简单”，牢牢抓住了社区开发者的心。所以重要的事情说三遍：</p>\n<blockquote>\n<p>在做设计的时候一定要倾向于简单。</p>\n<p>在做设计的时候一定要倾向于简单。</p>\n<p>在做设计的时候一定要倾向于简单。</p>\n</blockquote>\n<h2 id=\"集大成的Remote-Development\"><a href=\"#集大成的Remote-Development\" class=\"headerlink\" title=\"集大成的Remote Development\"></a>集大成的Remote Development</h2><p>今年五月，VS Code发布了Remote Development(VSCRD)，有了它，我们可以在远程环境（比如虚机、容器）里开一个VS Code工作区，然后用本地的VS Code连上去工作，下图说明了它的运行模式：<br><img data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/KyXfCrME6UIqiaLBvCPXibnTVMY66whB7GhXp7L45w8djTLHDKusSDLfoolVC14p7jDZmlszfFKDTHNmfUD4fjiag/640?wx_fmt=jpeg\" alt=\"\"></p>\n<p>VSCRD从本质上改善了远程开发的体验，与常用的远程桌面共享相比，具体改进如下：</p>\n<p><strong>响应迅速</strong>：VSCRD所有的交互都在本地UI内完成，响应迅速；远程桌面由于传输的是截屏画面，数据往返延迟很大，卡顿是常态</p>\n<p><strong>沿用本地设置</strong>：VSCRD的UI运行在本地，遵从所有本地设置，所以你依然可以使用自己所习惯的快捷键、布局、字体，避免了工作效率层面的开销</p>\n<p><strong>数据传输开销小</strong>：远程桌面传输的是视频数据，而VS Code传输是操作请求和响应，开销与命令行相仿，卡顿的情况进一步改善</p>\n<p><strong>第三方插件可用</strong>：在远程工作区里，不仅VS Code的原生功能可用，所有第三方插件的功能依然可用；远程桌面的话，你得自己一个个装好</p>\n<p><strong>远程文件系统可用</strong>：远程文件系统被完整映射到本地，这个两者差不多</p>\n<p>那么VSCRD做了什么神奇的操作能够实现以上效果呢？来看看它的架构图：<br><img data-src=\"https://mmbiz.qpic.cn/mmbiz_jpg/KyXfCrME6UIqiaLBvCPXibnTVMY66whB7GF2KlxFJO6IP2yZsDvVOJ9q7nBB3onzZZeN8SxibFvzThzn5y3EAaWUA/640?wx_fmt=jpeg\" alt=\"\"></p>\n<p>其实答案都在前文有所提及：</p>\n<h3 id=\"进程级别隔离的插件模型\"><a href=\"#进程级别隔离的插件模型\" class=\"headerlink\" title=\"进程级别隔离的插件模型\"></a>进程级别隔离的插件模型</h3><p>Extension Host（也就是图中的VS Code Server）与主程序做到了物理级别的分离，那么把Extension Host在远程或者本地跑没有本质的区别</p>\n<h3 id=\"UI渲染与插件逻辑隔离，整齐划一的插件行为\"><a href=\"#UI渲染与插件逻辑隔离，整齐划一的插件行为\" class=\"headerlink\" title=\"UI渲染与插件逻辑隔离，整齐划一的插件行为\"></a>UI渲染与插件逻辑隔离，整齐划一的插件行为</h3><p>所有的插件的UI都由VS Code统一渲染，所以插件里面只有纯业务逻辑，行为高度统一，跑在哪里都没区别</p>\n<h3 id=\"高效的协议LSP\"><a href=\"#高效的协议LSP\" class=\"headerlink\" title=\"高效的协议LSP\"></a>高效的协议LSP</h3><p>VS Code的两大协议LSP、DAP都非常精简，天然适合网络延迟高的情况，用在远程开发上再适合不过<br>VS Code团队在架构上的决策无疑是非常有前瞻性的，与此同时，他们对细节的把握也是无可挑剔。正因为有了如此扎实的工程基础，VSCRD这样的功能才得以诞生，所以我认为这是集大成的作品。</p>\n<p>还没有尝试过VSCRD的同学，这里再安利一下，它在以下场景中非常有用：</p>\n<ul>\n<li><p>开发环境配置起来很繁琐，比如物联网开发，需要自己安装和配置各种工具和插件。在VSCRD里，一个远程工作区的模板即可搞定，如需安装额外的工具，也就是改改Dockerfile的事情，非常简单。在这里可以找到常用的编程语言和场景的模板。</p>\n</li>\n<li><p>本地机器太弱，某些开发搞不了，比如机器学习，海量数据及和计算需求需要非常好的机器。在VSCRD里，可以直接操作远程文件系统，使用远程计算资源。</p>\n</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>VS Code像一颗耀眼的星星，吸引着成千上万开发者为其添砖加瓦。从VS Code的成功中，我们看到了好的设计和工程实践能创造多少奇迹。放眼软件产业，各个层面的模式不断被刷新，让人激动之余，也要求从业者不断提高技能水平。从个人学习的角度来看，了解这些模式诞生的前因后果，理解工程实践中的决策过程是非常有利于提高工程能力的。</p>\n","tags":["note"]},{"title":"弄不懂真正的“赚钱逻辑”，你永远都是社会最底层！","url":"/2012/08/18/thinking/note-money-making-logic/","content":"<p>整个中国的阶层，究竟是依照什么来划分的？</p>\n<p>为什么很多人勤勤恳恳，但是永远都是穷人？</p>\n<p>为什么“资本收入”永远都大于“劳动收入”？</p>\n<p>为什么有人的财富增长那么快？</p>\n<p>读完这篇真正的“赚钱的逻辑”之后，你就一目了然！<br><a id=\"more\"></a></p>\n<h3 id=\"1、资本\"><a href=\"#1、资本\" class=\"headerlink\" title=\"1、资本\"></a>1、资本</h3><p>首先，我们先来了解一下什么是“资本”。“资本”仅仅是指钱吗？不是。资本是对资源的“支配权”，通过资源支配带来更多的支配权叫“资本运作”，通过“资本运作”优化和配置社会财富，实现社会效率的最大化就是“资本运作”的社会价值。</p>\n<p>因为资本有趋利性和增值性，追求利润最大化。这就会促使社会资源的配置朝着效率、效益最大化的方向上行。社会资源将依次流入最有效率的国家和地区、最有效率的产业、最有效率的企业、最有效率的项目、最有效率的个人。资本的逐利促进资源的优化，资源的优化顺势产生新的资本，并且不断产生新的机会，如此一边循环一边膨胀。</p>\n<p>比如，在物理学上，石墨和金刚石是同素异型体，它们都属于碳元素形成的单质，但是物理性质大不相同，价值也天壤之别，就是因为他们的组成结构不同而已。</p>\n<p>所以资本思维的精髓是结构重组。即对资源的分子进行时空和结构上的调整，从而产生由“石墨”到“金刚石”的增值效果。宏观方面的资本运作是对全社会的资源重组，比如中国的国企重组，将大大改变中国经济的结构，提升整个社会的运作效率。</p>\n<h3 id=\"2、资本思维\"><a href=\"#2、资本思维\" class=\"headerlink\" title=\"2、资本思维\"></a>2、资本思维</h3><p>在此基础上，我们再来了解一下“资本思维”。在物理学上“杠杆”的作用是利用“力臂”将“力量”放大，从而可以翘起更大质量物体。经济上多了这一根杠杆，其活动空间和灵活性都大大增强，这也叫“资本思维”。今后的中国人必须深刻理解和运用“资本思维”这个工具。</p>\n<h3 id=\"3、三种角色\"><a href=\"#3、三种角色\" class=\"headerlink\" title=\"3、三种角色\"></a>3、三种角色</h3><p>今后的社会，将只有以下三类人：</p>\n<p>第一，资源者（工薪阶层）。他们是资源的最直接拥有者，依靠出卖自己的资源生存，比如农民靠耕地、工人靠体力、医生靠技能、作家靠写作，还有老师律师等等。</p>\n<p>第二，配置者（企业家）。资源是谁的不重要，关键要有资源配置权。这类人依靠配置资源挣钱，从事资源的投入-整合-运营-产出工作，以企业家为主，创业者也属于此类。</p>\n<p>第三，资本家（金融家）。金融是社会食物链的最高环节，他们离资源最远，但是所有资源却统统归他们掌控，他们只躲在幕后玩操作游戏。比如孙正义投资马云，阿里巴巴上市使他大获成功。资本家无国界，他们可以控制全球资源流向；可以通过金融体系支配大量别人的资产。</p>\n<p>所以，一个社会的资源名义上都是资源者的，实际上都是资本家的。看一个人能量多大，关键是他能配置多少资源。</p>\n<p>按照这三种不同性质的角色扮演，今后的个人如何获得财富？无非只有三条渠道：出售资源、配置资源、掌握资本。</p>\n<h4 id=\"（1）资源者（工薪阶层）\"><a href=\"#（1）资源者（工薪阶层）\" class=\"headerlink\" title=\"（1）资源者（工薪阶层）\"></a>（1）资源者（工薪阶层）</h4><p>“资源者”通过出售自己资源生存，也就是资源者的技能，即：时间+体力，这也是社会上分布最多的人群。<br>所以一般普通人只能找一家企业工作，出售自己本身换来财富。然而普通人的时间、体力都是相差无几的，他们能够出售的资源都是差不多的，于是为了让自己的资源卖上好价钱，就只能提升自己的技能水平和熟练水平。</p>\n<p>这时一个普遍的做法就是读书，这就是为什么父母们都希望自己的孩子好好读书，为什么清华北大的毕业生一般会比没有文化的人起薪高一些。</p>\n<p>但是现在文凭带来的技能差距差别越来越小，一个普通的一本学生与二本学生已经没有什么本质的差别，反而不如蓝翔挖掘机学的好的人附加价值高，这是因为前者数量多，后者数量少，而且后者更加注重实践，供需关系决定了资源的价格，因此读书无用论早就开始流行。</p>\n<p>所以，如果你只是一个普通人，要么通过读书获得更高、更稀罕的的技能价值；要么通过爱思考、会做人、大量实践提高自己实践能力。</p>\n<p>另外，对于“资源者”来说，还有天生稀罕资源，比如外貌。长的好看的普通人，可以在日常的婚配、工作、生活中获得很多额外的财富；如果长的好看再加上运气好就可以进入演艺圈，成为明星之后自己的资源就成了稀缺资源，资源的价格远远高于一般人！</p>\n<p>但是这类财富，可遇而不可求，只能靠运气。因此这个群体的绝大部分人都是社会的最底层，他们勤勤恳恳、任劳任怨，只为了能讨好领导或者老板，从而每月多领那么一点工资。当然他们也不用承担什么风险，生活最安逸。所以马云说那些月收入2——3万的人生活是最幸福的，就是基于这个角度考虑的。</p>\n<p>在中国的安徽、河南以及很多北方落后地区，依然还在遵循这种思维：父母总希望孩子能够找到一份好工作，使自己的劳动力更加值钱。不过，这种“雇佣”关系越来越不适应未来社会的发展，无论你是什么角色，必须学会主动解决问题，否则你存在的价值会越来越小，因此我认为工薪阶层很快将成为社会的最底层。</p>\n<h4 id=\"（2）配置者（企业主）\"><a href=\"#（2）配置者（企业主）\" class=\"headerlink\" title=\"（2）配置者（企业主）\"></a>（2）配置者（企业主）</h4><p>这种人不是资源的直接拥有者，他们往往通过脑力去设计资源的配置，通过优化资源去赚钱，企业家就属于这一类。</p>\n<p>在奴隶社会最重要的生产力要素是“人力”（即：奴隶）；封建时代的最重要的生产力要素是“土地”，而资本时代最重要的生产力要素是“资本”，资本的本质就是资源的配置。</p>\n<p>从定义上来讲，企业家是从事资源的组织、管理并承担经营风险的人。企业家的收入跟他配置的效率成正比，上不设限。但同时也要为自己的资源配置承担风险，下限就是破产。</p>\n<p>为什么很多人想去创业呢？就是因为他们想从第一类人努力攀爬到第二类人。一旦从“资源者”升级到“配置者”，就意味着不用再出卖自己的技能，而是开始经营自己的思想和智慧，人身和经济都实现了自由，从而实现人格上的自由。</p>\n<p>但是并不是所有的“资源者”都适合去创业。他们要具备一定的文化、眼光、魄力、创新力、机遇和资本。配置者是一个社会最重要的群体，他们的素质和数量决定了一个社会的资源配置效率，代表了生产力水平。配置者非常需要创新精神，所谓创新就是他们对新产品、新市场、新的生产方式、新组织的开拓以及新的原材料来源的控制调配。</p>\n<p>这里我们需要提到中国企业家的更新换代。30多年前，中国开始第一次改革开放，那时整个中国百废俱兴，当时的大环境就是最好的机遇，只要大胆出来闯荡的人，即使没有文化、没有见识，都成了企业家，这是当时的环境造成的。</p>\n<p>而如今，中国进行改革开放的深化，这个时候的中国已经发生天翻地覆的变化，此时也对企业家的素质提出了更高的要求。比如在欧美和日本，企业家始终是社会的精英阶层才可以担任。而接下来的中国，如果没有一定的文化素养、理想追求，以及对创新的深刻理解，很难再成为社会的“配置者”。因此，中国的企业家正在更新换代，一些90后创业者纷纷走近我们视野，很多老的企业家也自愿退出历史舞台，这是时代的发展，也是一种必然！</p>\n<p>观察一下周围，几乎每个人身边都有创业的经历，创业更是一场修行。创业者是链接上层和下层之间的桥梁，是整个社会的中流砥柱！它们加速了社会财富的流通，我们应该向每一个创业者致敬。</p>\n<h4 id=\"（3）资本家（金融家）\"><a href=\"#（3）资本家（金融家）\" class=\"headerlink\" title=\"（3）资本家（金融家）\"></a>（3）资本家（金融家）</h4><p>这个社会的财富，看似是属于分散的“资源者”的，实际上却是归“配置者”享用的。但在本质上，全部是属于资本家的！</p>\n<p>这是一个非常残酷是事实，我们今天却把它说穿了。</p>\n<p>资本家的定义是：以资本运作为业的人。第二次工业革命后，掌握了科技与运用的企业家们，能迅速的积累起巨额的财富，他们的企业对一个国家产生极大的影响，这些企业组成了这个国家的经济命脉，企业为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制，于是形成了垄断，而这时的“企业家”开始坐在了幕后操纵这一切，演变成了“资本家”。</p>\n<p>“资本家”跟“企业家”的最大区别是：资本家不直接参与企业的经营和管理，而是在幕后操纵企业宏观思路，企业的产品是各类快消品，而资本家的产品就是各个企业。通过投资、入股、并购、重组的方式，将一个企业的未来把控到自己手中，孙正义投资了马云，成全了阿里巴巴，马云就是企业家，而孙正义就是资本家。孙正义手里有N个马云，成了日本首富。再比如巴菲特专门坐在老家做投资操纵他的布局，他也是资本家。</p>\n<p>美国是自由市场经济，但是为什么叫“资本”主义社会呢？而不叫“自有市场主义”社会呢？因为在这样的社会，“资本”是度量和决定一切的标准。如果你有了1亿元的资本，你可以花一千万雇上这个国家最聪明的一批人，把你的资本从1亿变成2亿，你躺在床上就赚了九千万。而这一切，只因为你再从事资本运作，你只需要够聪明和有魄力，不需要有力气、不需要花时间、更不需要长得漂亮。</p>\n<p>我们需要明白的是：第3种人赚的钱就比第2种人多，第2种人赚的钱比第1种人多。因此，第1种人在努力进化到第2种人，而第二种人在拼命进化到第3种人。</p>\n<p>因为中国建国时期就消灭了资本家，所以中国天生具有资本的人是极少的，大部分第3种人都是从第1种人或者第2种人进化过来的，虽然目前这种进化已经越来越难了，但还不是没有希望，因为以后会更加的困难。这就是阶级的固化，阶级间流动的减少。</p>\n<p>每个人都在玩命探索的方法，有的人成功了，有的人失败了。原因就只有两点：你的头脑有多聪明？你有多大魄力？剩下的就是看机会！</p>\n<p>既然阶层已经固化，那么还有打破的希望吗？当然有！</p>\n<p>我不是很同意最近流传的一些文章，他们把社会描述的越来越绝望。但是实际上，今后的社会是全开放的，资源流动的会越来越快。任何一个人都可以从身边流动的资源进行取用，然后盘活！</p>\n<p>比如如果你一个普通人（工薪阶层），有一天你忽然想到了一个可以改变世界的idea，那你要问自己，你有没有这个资金去运作这个idea？如果没有，是不是可以把它表达出来，找有兴趣、有钱的人（资本家）来投资你去做呢？只要这个想法是合理的，自然就会有人赏识，然后你就成了第二种人（企业家），从而支配一群人去实现你的梦想，同时你也在为大家实现梦想。</p>\n<p>所以：第一步，你要进行资本积累，你愿意打工也好，愿意自己做产品也好（有的人就自认为在创业了），先完成资本积累。这一步最重要，上班、摆地摊、开淘宝、做网站、做APP、炒股票、海外代购、开设计工作室、卖肉夹馍、给幼儿园摄影的等等等等，一句话，这步就是出卖你的个人资源，就看你卖不卖的上价了，多学习吧，即使不为了文凭；多辛苦吧，只要不是出卖健康。</p>\n<p>第二步、善用资本，用资本赚钱。怎么用资本赚钱？问你们个问题你们就明白了。如果你家开了个小饭店，每个月能赚1万，但是需要个厨师。你自己炒菜水平很高，如果自己当厨师，饭店每月净赚1万；如果雇佣一个厨师，每月花8千，饭店净赚2千。你怎么选择？</p>\n<p>答案：雇一个厨师！这样你只要能用每月一千利息的贷款，再盘下一个饭店，那个饭店也能净赚一千了。而你，只需要这样盘下100个饭店，每个月就能净赚10万，而你这时，却在国外旅游，成了第3种人。</p>\n<p>很多人一直在打工，他们没有成为第3种人，很好理解。就是因为：他自己做厨师，自己妹妹做服务员，自己的老妈管收银，仅此而已。</p>\n<p>所以，以后问自己怎么成为第3种人，就是一句话：“不要自己炒菜，雇一个厨师”。如果能用资本去赚1块钱，也比用出售自己的体力赚100块钱更符合金融思维。</p>\n<p>另外，聪明和资本，如果你只具有其中一点，记得，要找只有另一点的人去合作，他们也在等着你！</p>\n<h3 id=\"4、普通人的提升\"><a href=\"#4、普通人的提升\" class=\"headerlink\" title=\"4、普通人的提升\"></a>4、普通人的提升</h3><p>同时，再强调一点，如果你是个普通人，或者自认是个普通人，但是又有上进心，不如务实一点，脚踏实地的往前走。</p>\n<p>曾经有个公司的公关部经理，打开她的博客，已经更新了500多页，有2000多个帖子，全部都是每天她自己做口译练习的文章，她坚持做这件事已经快10年了，非专业出身的她因为爱好英语而一直努力。</p>\n<p>她说，10年前，她曾经看到一份调查报告，一个人如果要掌握一项技能，成为专家，需要不间断地练习10000个小时。当时她算了一笔账，如果每天练习5个小时，每年300天的话，那么需要7年的时间，一个人才能掌握这项技能。</p>\n<p>她说：“幸运的是，我知道自己想掌握什么技能，我只需要立马投入干起来就行了，我没有5个小时的时间，我每天只能学习3个小时，现在已经快10年了，我觉得自己差不多已经掌握了这个技能吧。”</p>\n<p>再比如，披头士乐队在成名前已经参加过1200场演出。可是为什么你做了10年公务员还只是一名小职员？为什么在家里做了7年的饭，没变成特级大厨，反而发现婚姻到了7年之痒呢？</p>\n<p>那是因为，你没有投入精力和热情来练习一项技能。每天上班只是看报纸、上网、应付各种琐碎任务，刷朋友圈，浏览那些看似丰富却没有价值的信息，每天做饭只是为了让家庭正常运转，并不用专业的眼光看待这件事。</p>\n<p>不要再哀叹大学毕业之后专业就丢了。如果从初中开始算起，12年的学校教育，就算每天学习一门技能2小时，一年300天，你也只有7200小时，还有2800小时的缺口；就算你毕业后每天坚持练习1小时，你需要10年。</p>\n<p>为什么理工科的人更容易成功？只要他们毕业后专业对口，还是做的那点事，那么他们就等于1天8小时都在练习。这2800小时，只需要1年多就填补了。可我们很多人，工作的内容并不是在练习技能，大部分是应对琐碎的人和事，实际上，是在荒废人生。</p>\n<p>也许你会说，我是平凡人，我不想成为什么家，只想安安分分过日子。那只是你的错觉，时间在流逝，你每天重复重复再重复的那些行为，就是在塑造你，你不想成为什么人，可是你注定会成为什么人。</p>\n<p>每天5个小时，如果你是用来看韩剧、翻手机、玩游戏，那么7年后，你会变成一个生活的旁观者，你最擅长的就是如数家珍地说起别人的成功和失败，自己身上找不到任何可说的东西。</p>\n<p>花1分钟想一想，曾经最想做的事情是什么，然后每天去做这件事。7年后，你会发现你已经可以靠这件事出去混饭吃了。</p>\n<p>哪怕你喜欢逛街呢，你规定自己每天逛街3小时试试？可能一开始你觉得很高兴，每天如此，你会发现无聊。再坚持下去，你就开始琢磨了，我逛街还能发现点什么？还能搞出点什么花样？坚持下去，7年之后，你可能会成为时尚达人、形象设计专家、街拍摄影师、服装买手……</p>\n<p>生命中下个7年，下个10000小时，你打算怎样度过？</p>\n","categories":["thinking"],"tags":["thinking"]},{"title":"编程范式游记（4）- 函数式编程","url":"/2016/01/04/mouse/programming-paradigm-travel-4-functional-programming/","content":"<p>从前三章内容中，我们了解到，虽然 C 语言简单灵活，能够让程序员在高级语言特性之上轻松进行底层上的微观控制，被誉为“高级语言中的汇编语言”，但其基于过程和底层的设计初衷又成了它的短板。<br><a id=\"more\"></a><br>在程序世界中，编程工作更多的是解决业务上的问题，而不是计算机的问题，我们需要更为贴近业务更为抽象的语言，如面向对象语言 C++ 和 Java 等。</p>\n<p>C++ 很大程度上解决了 C 语言中的各种问题和不便，尤其是通过类、模板、虚函数和运行时识别等解决了 C 语言的泛型编程问题。然而，如何做更为抽象的泛型呢？答案就是函数式编程（Functional Programming）。</p>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>相对于计算机的历史而言，函数式编程其实是一个非常古老的概念。函数式编程的基础模型来源于 λ 演算，而 λ 演算并非设计于在计算机上执行。它是由 Alonzo Church 和 Stephen Cole Kleene 在 20 世纪 30 年代引入的一套用于研究函数定义、函数应用和递归的形式系统。</p>\n<p>如 Alonzo 所说，像 booleans、integers 或者其他的数据结构都可以被函数取代掉。</p>\n<p>我们来看一下函数式编程，它的理念就是借用于数学中的代数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(x)&#x3D;5x^2+4x+3</span><br><span class=\"line\">g(x)&#x3D;2f(x)+5&#x3D;10x^2+8x+11</span><br><span class=\"line\">h(x)&#x3D;f(x)+g(x)&#x3D;15x^2+12x+14</span><br></pre></td></tr></table></figure><br>假设 f(x) 是一个函数，g(x) 是第二个函数，把 f(x) 这个函数套下来，并展开。然后还可以定义一个由两个一元函数组合成的二元函数。还可以做递归，下面这个函数定义就是斐波那契数列。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(x)&#x3D;f(x-1)+f(x-2)</span><br></pre></td></tr></table></figure>\n<p>对于函数式编程来说，其只关心，定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。</p>\n<p>函数式编程有以下特点。</p>\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ul>\n<li>stateless：函数不维护任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，你给我数据我处理完扔出来，里面的数据是不变的。</li>\n<li>immutable：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。</li>\n</ul>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ul>\n<li>没有状态就没有伤害</li>\n<li>并行执行无伤害。</li>\n<li>Copy-Paste 重构代码无伤害。</li>\n<li>函数的执行没有顺序上的问题。</li>\n</ul>\n<p>函数式编程还带来了以下一些好处。</p>\n<ul>\n<li><p>惰性求值。这需要编译器的支持。表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。也就是说，语句如 x:=expression; (把一个表达式的结果赋值给一个变量) 显式地调用这个表达式被计算并把结果放置到 x 中，但是先不管实际在 x 中的是什么，直到通过后面的表达式中到 x 的引用而有了对它的值的需求的时候，而后面表达式自身的求值也可以被延迟，最终为了生成让外界看到的某个符号而计算这个快速增长的依赖树。</p>\n</li>\n<li><p>确定性。所谓确定性，就是像在数学中那样，f(x) = y 这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。而不是像程序中的很多函数那样，同一个参数，却会在不同的场景下计算出不同的结果。所谓不同的场景，就是我们的函数会根据运行中的状态信息的不同而发生变化。</p>\n</li>\n</ul>\n<p>我们知道，因为状态，在并行执行和 copy-paste 时引发 bug 的概率是非常高的，所以没有状态就没有伤害，就像没有依赖就没有伤害一样，并行执行无伤害，copy 代码无伤害，因为没有状态，代码怎样拷都行。</p>\n<h3 id=\"劣势\"><a href=\"#劣势\" class=\"headerlink\" title=\"劣势\"></a>劣势</h3><p>数据复制比较严重。<br>注：有一些人可能会觉得这会对性能造成影响。其实，这个劣势并不见得会导致性能不好。因为没有状态，所以代码在并行上根本不需要锁（不需要对状态修改的锁），所以可以拼命地并发，反而可以让性能很不错。比如：Erlang 就是其中的代表。</p>\n<p>对于纯函数式（也就是完全没有状态的函数）的编程来说，各个语言支持的程度如下。</p>\n<ul>\n<li>完全纯函数式 Haskell</li>\n<li>容易写纯函数 F#, Ocaml, Clojure, Scala</li>\n<li>纯函数需要花点精力 C#, Java, JavaScript</li>\n</ul>\n<p>完全纯函数的语言，很容易写成函数，纯函数需要花精力。只要所谓的纯函数的问题，传进来的数据不改，改完的东西复制一份拷出去，然后没有状态。</p>\n<p>但是很多人并不习惯函数式编程，因为函数式编程和过程式编程的思维方式完全不一样。过程式编程是在把具体的流程描述出来，所以可以不假思索，而函数式编程的抽象度更大，在实现方式上，函数套函数，函数返回函数，函数里定义函数……把人搞得很糊涂。</p>\n<h2 id=\"函数式编程用到的技术\"><a href=\"#函数式编程用到的技术\" class=\"headerlink\" title=\"函数式编程用到的技术\"></a>函数式编程用到的技术</h2><p>下面是函数式编程用到的一些技术。</p>\n<ul>\n<li><p>first class function（头等函数） ：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改，并当成变量一样传递、返回，或是在函数中嵌套函数。</p>\n</li>\n<li><p>tail recursion optimization（尾递归优化） ： 我们知道递归的害处，那就是如果递归很深的话，stack 受不了，并会导致性能大幅度下降。因此，我们使用尾递归优化技术——每次递归时都会重用 stack，这样能够提升性能。当然，这需要语言或编译器的支持。Python 就不支持。</p>\n</li>\n<li><p>map &amp; reduce ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做 Map 和 Reduce 操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用 for/while 循环，然后在各种变量中把数据倒过来倒过去的）这个很像 C++ STL 中 foreach、find_if、count_if 等函数的玩法。</p>\n</li>\n<li><p>pipeline（管道）：这个技术的意思是，将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。</p>\n</li>\n<li><p>recursing（递归） ：递归最大的好处就简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。</p>\n</li>\n<li><p>currying（柯里化） ：将一个函数的多个参数分解成多个函数， 然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。在 C++ 中，这很像 STL 中的 bind1st 或是 bind2nd。</p>\n</li>\n<li><p>higher order function（高阶函数）：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象满天飞一样。这个技术用来做 Decorator 很不错。</p>\n</li>\n</ul>\n<p>上面这些技术太抽象了，我们还是从一个最简单的例子开始。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 非函数式，不是 pure funciton，有状态</span><br><span class=\"line\">int cnt;</span><br><span class=\"line\">void increment()&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这里有个全局变量，调这个全局函数变量 ++，这里面是有状态的，这个状态在外部。所以，如果是多线程的话，这里面的代码是不安全的。</p>\n<p>如果写成纯函数，应该是下面这个样子。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 函数式，pure function， 无状态</span><br><span class=\"line\">int increment(int cnt)&#123;</span><br><span class=\"line\">    return cnt+1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个是你传给我什么，我就返回这个值的 +1 值，你会发现，代码随便拷，而且与线程无关，代码在并行时候不用锁，因为是复制了原有的数据，并返回了新的数据。</p>\n<p>我们再来看另一个例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def inc(x):</span><br><span class=\"line\">    def incx(y):</span><br><span class=\"line\">        return x+y</span><br><span class=\"line\">    return incx</span><br><span class=\"line\"></span><br><span class=\"line\">inc2 &#x3D; inc(2)</span><br><span class=\"line\">inc5 &#x3D; inc(5)</span><br><span class=\"line\"></span><br><span class=\"line\">print inc2(5) # 输出 7</span><br><span class=\"line\">print inc5(5) # 输出 10</span><br></pre></td></tr></table></figure><br>上面这段 Python 的代码，开始有点复杂了。我们可以看到上面那个例子inc()函数返回了另一个函数incx()，于是可以用inc()函数来构造各种版本的 inc 函数，比如：inc2()和inc5()。这个技术其实就是上面所说的 currying 技术。从这个技术上，你可能体会到函数式编程的理念。</p>\n<p>把函数当成变量来用，关注描述问题而不是怎么实现，这样可以让代码更易读。</p>\n<p>因为函数返回里面的这个函数，所以函数关注的是表达式，关注的是描述这个问题，而不是怎么实现这个事情。</p>\n<h2 id=\"Lisp-语言介绍\"><a href=\"#Lisp-语言介绍\" class=\"headerlink\" title=\"Lisp 语言介绍\"></a>Lisp 语言介绍</h2><p>要说函数式语言，不可避免地要说一下 Lisp。</p>\n<p>下面，我们再来看看 Scheme 语言（Lisp 的一个方言）的函数式玩法。在 Scheme 里，所有的操作都是函数，包括加减乘除这样的东西。所以，一个表达式是这样的形式—— （函数名 参数 1 参数 1）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(define (plus x y)  (+ x y))</span><br><span class=\"line\">(define (times x y) (* x y))</span><br><span class=\"line\">(define (square x)  (times x x))</span><br></pre></td></tr></table></figure><br>上面三个函数：</p>\n<p>用内置的 + 函数定义了一个新的 plus 函数。<br>用内置的 <em> 函数定义了一个新的 times 函数。<br>用之前的 times 函数定义了一个 square 函数。<br>下面这个函数定义了： `f(x) = 5 </em> x^2 +10`<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(define (f1 x) ;;; f(x) &#x3D; 5 * x^2 + 10</span><br><span class=\"line\">    (plus 10 (times 5 (square x))))</span><br></pre></td></tr></table></figure><br>也可以这样定义——使用 lambda 匿名函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(define f2</span><br><span class=\"line\">    (lambda (x)</span><br><span class=\"line\">        (define plus</span><br><span class=\"line\">            (lambda (a b) (+ a b)))</span><br><span class=\"line\">        (define times</span><br><span class=\"line\">            (lambda (a b) (* a b)))</span><br><span class=\"line\">        (plus 10 (times 5 (times x x)))))</span><br></pre></td></tr></table></figure><br>在上面的这个代码里，我们使用 lambda 来定义函数 f2 ，然后也同样用 lambda 定义了两个函数—— plus 和 times。 最后，由 (plus 10 (times 5 (times x x))) 定义了 f2 。</p>\n<p>我们再来看一个阶乘的示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">;;; recursion</span><br><span class=\"line\">(define factoral (lambda (x)</span><br><span class=\"line\">    (if (&lt;&#x3D; x 1) 1</span><br><span class=\"line\">        (* x (factoral (- x 1))))))</span><br><span class=\"line\"></span><br><span class=\"line\">(newline)</span><br><span class=\"line\">(display(factoral 6))</span><br><span class=\"line\">下面是另一个版本的，使用了尾递归。</span><br><span class=\"line\"></span><br><span class=\"line\">;;; another version of recursion</span><br><span class=\"line\">(define (factoral_x n)</span><br><span class=\"line\">    (define (iter product counter)</span><br><span class=\"line\">        (if (&lt; counter n)</span><br><span class=\"line\">            product</span><br><span class=\"line\">            (iter (* counter product) (+ counter 1))))</span><br><span class=\"line\">    (iter 1 1))</span><br><span class=\"line\"></span><br><span class=\"line\">(newline)</span><br><span class=\"line\">(display(factoral_x 5))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数式编程的思维方式\"><a href=\"#函数式编程的思维方式\" class=\"headerlink\" title=\"函数式编程的思维方式\"></a>函数式编程的思维方式</h2><p>前面提到过多次，函数式编程关注的是：describe what to do, rather than how to do it。于是，我们把以前的过程式编程范式叫做 Imperative Programming – 指令式编程，而把函数式编程范式叫做 Declarative Programming – 声明式编程。</p>\n<h3 id=\"传统方式的写法\"><a href=\"#传统方式的写法\" class=\"headerlink\" title=\"传统方式的写法\"></a>传统方式的写法</h3><p>下面我们看一下相关的示例。比如，我们有 3 辆车比赛，简单起见，我们分别给这 3 辆车有 70% 的概率可以往前走一步，一共有 5 次机会，然后打出每一次这 3 辆车的前行状态。</p>\n<p>对于 Imperative Programming 来说，代码如下（Python）：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from random import random</span><br><span class=\"line\"></span><br><span class=\"line\">time &#x3D; 5</span><br><span class=\"line\">car_positions &#x3D; [1, 1, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">while time:</span><br><span class=\"line\">    # decrease time</span><br><span class=\"line\">    time -&#x3D; 1</span><br><span class=\"line\"></span><br><span class=\"line\">    print &#39;&#39;</span><br><span class=\"line\">    for i in range(len(car_positions)):</span><br><span class=\"line\">        # move car</span><br><span class=\"line\">        if random() &gt; 0.3:</span><br><span class=\"line\">            car_positions[i] +&#x3D; 1</span><br><span class=\"line\"></span><br><span class=\"line\">        # draw car</span><br><span class=\"line\">        print &#39;-&#39; * car_positions[i]</span><br></pre></td></tr></table></figure><br>我们可以把这两重循环变成一些函数模块，这样有利于更容易地阅读代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from random import random</span><br><span class=\"line\"></span><br><span class=\"line\">def move_cars():</span><br><span class=\"line\">    for i, _ in enumerate(car_positions):</span><br><span class=\"line\">        if random() &gt; 0.3:</span><br><span class=\"line\">            car_positions[i] +&#x3D; 1</span><br><span class=\"line\"></span><br><span class=\"line\">def draw_car(car_position):</span><br><span class=\"line\">    print &#39;-&#39; * car_position</span><br><span class=\"line\"></span><br><span class=\"line\">def run_step_of_race():</span><br><span class=\"line\">    global time</span><br><span class=\"line\">    time -&#x3D; 1</span><br><span class=\"line\">    move_cars()</span><br><span class=\"line\"></span><br><span class=\"line\">def draw():</span><br><span class=\"line\">    print &#39;&#39;</span><br><span class=\"line\">    for car_position in car_positions:</span><br><span class=\"line\">        draw_car(car_position)</span><br><span class=\"line\"></span><br><span class=\"line\">time &#x3D; 5</span><br><span class=\"line\">car_positions &#x3D; [1, 1, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">while time:</span><br><span class=\"line\">    run_step_of_race()</span><br><span class=\"line\">    draw()</span><br></pre></td></tr></table></figure><br>上面的代码，从主循环开始，我们可以很清楚地看到程序的主干，因为我们把程序的逻辑分成了几个函数。这样一来，代码逻辑就会变成几个小碎片，于是我们读代码时要考虑的上下文就少了很多，阅读代码也会更容易。不像第一个示例，如果没有注释和说明，你还是需要花些时间理解一下。而将代码逻辑封装成了函数后，我们就相当于给每个相对独立的程序逻辑取了个名字，于是代码成了自解释的。</p>\n<p>但是，你会发现，封装成函数后，这些函数都会依赖于共享的变量来同步其状态。于是，在读代码的过程中，每当我们进入到函数里，读到访问了一个外部的变量时，我们马上要去查看这个变量的上下文，然后还要在大脑里推演这个变量的状态， 才能知道程序的真正逻辑。也就是说，这些函数间必需知道其它函数是怎么修改它们之间的共享变量的，所以，这些函数是有状态的。</p>\n<h3 id=\"函数式的写法\"><a href=\"#函数式的写法\" class=\"headerlink\" title=\"函数式的写法\"></a>函数式的写法</h3><p>我们知道，有状态并不是一件很好的事情，无论是对代码重用，还是对代码的并行来说，都是有副作用的。因此，要想个方法把这些状态搞掉，于是出现了函数式编程的编程范式。下面，我们来看看函数式的方式应该怎么写？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">from random import random</span><br><span class=\"line\"></span><br><span class=\"line\">def move_cars(car_positions):</span><br><span class=\"line\">    return map(lambda x: x + 1 if random() &gt; 0.3 else x,</span><br><span class=\"line\">               car_positions)</span><br><span class=\"line\"></span><br><span class=\"line\">def output_car(car_position):</span><br><span class=\"line\">    return &#39;-&#39; * car_position</span><br><span class=\"line\"></span><br><span class=\"line\">def run_step_of_race(state):</span><br><span class=\"line\">    return &#123;&#39;time&#39;: state[&#39;time&#39;] - 1,</span><br><span class=\"line\">            &#39;car_positions&#39;: move_cars(state[&#39;car_positions&#39;])&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">def draw(state):</span><br><span class=\"line\">    print &#39;&#39;</span><br><span class=\"line\">    print &#39;\\n&#39;.join(map(output_car, state[&#39;car_positions&#39;]))</span><br><span class=\"line\"></span><br><span class=\"line\">def race(state):</span><br><span class=\"line\">    draw(state)</span><br><span class=\"line\">    if state[&#39;time&#39;]:</span><br><span class=\"line\">        race(run_step_of_race(state))</span><br><span class=\"line\"></span><br><span class=\"line\">race(&#123;&#39;time&#39;: 5,</span><br><span class=\"line\">      &#39;car_positions&#39;: [1, 1, 1]&#125;)</span><br></pre></td></tr></table></figure><br>上面的代码依然把程序的逻辑分成了函数。不过这些函数都是函数式的，它们有三个特点：它们之间没有共享的变量；函数间通过参数和返回值来传递数据；在函数里没有临时变量。</p>\n<p>我们还可以看到，for 循环被递归取代了（见 race 函数）—— 递归是函数式编程中常用到的技术，正如前面所说的，递归的本质就是描述问题是什么。</p>\n<h3 id=\"函数式语言的三套件\"><a href=\"#函数式语言的三套件\" class=\"headerlink\" title=\"函数式语言的三套件\"></a>函数式语言的三套件</h3><p>函数式语言有三套件，<strong>Map、Reduce 和 Filter</strong>。这在谈 C++ 的泛型编程时已经介绍过。下面我们来看一下 Python 语言中的一个示例。这个示例的需求是，我们想把一个字符串数组中的字符串都转成小写。</p>\n<p>用常规的面向过程的方式，代码如下所示：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 传统的非函数式</span><br><span class=\"line\">upname &#x3D;[&#39;HAO&#39;, &#39;CHEN&#39;, &#39;COOLSHELL&#39;]</span><br><span class=\"line\">lowname &#x3D;[]</span><br><span class=\"line\">for i in range(len(upname)):</span><br><span class=\"line\">    lowname.append( upname[i].lower() )</span><br><span class=\"line\">如果写成函数式，用 map() 函数，是下面这个样子。</span><br><span class=\"line\"></span><br><span class=\"line\"># 函数式</span><br><span class=\"line\">def toUpper(item):</span><br><span class=\"line\">      return item.upper()</span><br><span class=\"line\"></span><br><span class=\"line\">upper_name &#x3D; map(toUpper, [&quot;hao&quot;, &quot;chen&quot;, &quot;coolshell&quot;])</span><br><span class=\"line\"></span><br><span class=\"line\">print upper_name</span><br><span class=\"line\"># 输出 [&#39;HAO&#39;, &#39;CHEN&#39;, &#39;COOLSHELL&#39;]</span><br></pre></td></tr></table></figure><br>顺便说一下，上面的例子是不是和我们 C++ 语言中的 STL 的transform()函数有些像？<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">string s&#x3D;&quot;hello&quot;;</span><br><span class=\"line\">transform(s.begin(), s.end(), back_inserter(out), ::toupper);</span><br></pre></td></tr></table></figure><br>在上面 Python 的那个例子中可以看到，我们定义了一个函数 toUpper，这个函数没有改变传进来的值，只是把传进来的值做个简单的操作，然后返回。然后，我们把其用在 map 函数中，就可以很清楚地描述出我们想要干什么。而不会去理解一个在循环中怎么实现的代码，最终在读了很多循环的逻辑后才发现原来是这个或那个意思。</p>\n<p>如果你觉得上面的代码在传统的非函数式的方式下还是很容易读的，那么我们再来看一个计算数组平均值的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 计算数组中正数的平均值</span><br><span class=\"line\">num &#x3D;  [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]</span><br><span class=\"line\">positive_num_cnt &#x3D; 0</span><br><span class=\"line\">positive_num_sum &#x3D; 0</span><br><span class=\"line\">for i in range(len(num)):</span><br><span class=\"line\">    if num[i] &gt; 0:</span><br><span class=\"line\">        positive_num_cnt +&#x3D; 1</span><br><span class=\"line\">        positive_num_sum +&#x3D; num[i]</span><br><span class=\"line\"></span><br><span class=\"line\">if positive_num_cnt &gt; 0:</span><br><span class=\"line\">    average &#x3D; positive_num_sum &#x2F; positive_num_cnt</span><br><span class=\"line\"></span><br><span class=\"line\">print average</span><br></pre></td></tr></table></figure><br>上面的代码如果没有注释的话，你需要看一会儿才能明白，只是计算数组中正数的平均值。</p>\n<p>我们再来看看函数式下使用 filter/reduce 函数的玩法。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 计算数组中正数的平均值</span><br><span class=\"line\">positive_num &#x3D; filter(lambda x: x&gt;0, num)</span><br><span class=\"line\">average &#x3D; reduce(lambda x,y: x+y, positive_num) &#x2F; len( positive_num )</span><br></pre></td></tr></table></figure><br>首先，我们使用 filter 函数把正数过滤出来（注意： lambda x : x&gt;0 这个 lambda 表达式），保存在一个新的数组中 —— positive_num。然后，我们使用 reduce 函数对数组 positive_num 求和后，再除以其个数，就得到正数的平均值了。</p>\n<p>我们可以看到， 隐藏了数组遍历并过滤数组控制流程的 filter 和 reduce， 不仅让代码更为简洁，因为代码里只有业务逻辑了，而且让我们能更容易地理解代码。</p>\n<p>对 num 数组 filter 条件 x &gt; 0 的数据。<br>然后对 positive_num 进行 x + y 操作的 reduce，即求和。<br>……<br>感觉代码更亲切了，不是吗？因为：</p>\n<ul>\n<li>数据集、对数据的操作和返回值都放在了一起。</li>\n<li>没有了循环体，就可以少了些临时用来控制程序执行逻辑的变量，也少了把数据倒来倒去的控制逻辑。</li>\n<li>代码变成了在描述你要干什么，而不是怎么干。</li>\n</ul>\n<p>当然，如果你是第一次见到 map/reduce/filter，那你可能还是会有点儿陌生和不解，这只是你不了解罢了。</p>\n<p>对于函数式编程的思路，下图是一个比较形象的例子，面包和蔬菜 map 到切碎的操作上，再把结果给 reduce 成汉堡。</p>\n<p>在这个图中，我们可以看到 map 和 reduce 不关心源输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么。</p>\n<h3 id=\"函数式的-pipeline-模式\"><a href=\"#函数式的-pipeline-模式\" class=\"headerlink\" title=\"函数式的 pipeline 模式\"></a>函数式的 pipeline 模式</h3><p>pipeline（管道）借鉴于 Unix Shell 的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。（注：管道绝对是一个伟大的发明，它的设计哲学就是 KISS – 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的 Web Service、云计算，以及大数据的流式计算等。）</p>\n<p>比如，我们如下的 shell 命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ps auwwx | awk &#39;&#123;print $2&#125;&#39; | sort -n | xargs echo</span><br></pre></td></tr></table></figure><br>上面的例子是要查看一个用户执行的进程列表，列出来以后，然后取第二列，第二列是它的进程 ID，排个序，再把它显示出来。</p>\n<p>抽象成函数式的样子，我们就可以反过来，一层套一层。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">xargs(  echo, sort(n, awk(&#39;print $2&#39;, ps(auwwx)))  )</span><br></pre></td></tr></table></figure><br>我们也可以把函数放进数组里面，然后顺序执行一下。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pids &#x3D; for_each(result, [ps_auwwx, awk_p2, sort_n, xargs_echo])</span><br></pre></td></tr></table></figure><br>多说一句，如果我们把这些函数比作微服务，那么管道这个事是在干什么呢？其实就是在做服务的编排。像 Unix 这些经典的技术上的实践或理论，往往是可以反映到分布式架构的，所以，一般来说，一个好的分布式架构师，通常都是对这些传统的微观上的经典技术有非常深刻的认识，因为这些东西在方法论上都是相通的。</p>\n<p>好了，还是让我们用一个简单的示例来看一下如何实现 pipeline。</p>\n<p>我们先来看一个程序，这个程序的 process() 有三个步骤：</p>\n<ul>\n<li>找出偶数；</li>\n<li>乘以 3；</li>\n<li>转成字符串返回。</li>\n</ul>\n<p>传统的非函数式的实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def process(num):</span><br><span class=\"line\">    # filter out non-evens</span><br><span class=\"line\">    if num % 2 !&#x3D; 0:</span><br><span class=\"line\">        return</span><br><span class=\"line\">    num &#x3D; num * 3</span><br><span class=\"line\">    num &#x3D; &#39;The Number: %s&#39; % num</span><br><span class=\"line\">    return num</span><br><span class=\"line\"></span><br><span class=\"line\">nums &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\"></span><br><span class=\"line\">for num in nums:</span><br><span class=\"line\">    print process(num)</span><br><span class=\"line\"></span><br><span class=\"line\"># 输出：</span><br><span class=\"line\"># None</span><br><span class=\"line\"># The Number: 6</span><br><span class=\"line\"># None</span><br><span class=\"line\"># The Number: 12</span><br><span class=\"line\"># None</span><br><span class=\"line\"># The Number: 18</span><br><span class=\"line\"># None</span><br><span class=\"line\"># The Number: 24</span><br><span class=\"line\"># None</span><br><span class=\"line\"># The Number: 30</span><br></pre></td></tr></table></figure><br>我们可以看到，输出的结果并不够完美，另外，代码阅读上如果没有注释，你也会比较晕。下面，我们来看看函数式的 pipeline（第一种方式）应该怎么写？</p>\n<p>第一步，我们先把三个“子需求”写成函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def even_filter(nums):</span><br><span class=\"line\">    for num in nums:</span><br><span class=\"line\">        if num % 2 &#x3D;&#x3D; 0:</span><br><span class=\"line\">            yield num</span><br><span class=\"line\">def multiply_by_three(nums):</span><br><span class=\"line\">    for num in nums:</span><br><span class=\"line\">        yield num * 3</span><br><span class=\"line\">def convert_to_string(nums):</span><br><span class=\"line\">    for num in nums:</span><br><span class=\"line\">        yield &#39;The Number: %s&#39; % num</span><br><span class=\"line\">然后，我们再把这三个函数串起来：</span><br><span class=\"line\"></span><br><span class=\"line\">nums &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">pipeline &#x3D; convert_to_string(multiply_by_three(even_filter(nums)))</span><br><span class=\"line\">for num in pipeline:</span><br><span class=\"line\">    print num</span><br><span class=\"line\"># 输出：</span><br><span class=\"line\"># The Number: 6</span><br><span class=\"line\"># The Number: 12</span><br><span class=\"line\"># The Number: 18</span><br><span class=\"line\"># The Number: 24</span><br><span class=\"line\"># The Number: 30</span><br></pre></td></tr></table></figure><br>上面，我们动用了 Python 的关键字 yield，它是一个类似 return 的关键字，只是这个函数返回的是 Generator（生成器）。所谓生成器，指的是 yield 返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被迭代时，yield 函数才会真正运行，运行到 yield 语句时就会停住，然后等下一次的迭代。（ yield 是个比较诡异的关键字）这就是 lazy evluation（懒惰加载）。</p>\n<p>好了，根据前面的原则——“使用 Map &amp; Reduce，不要使用循环”（还记得吗？使用循环会让我们只能使用顺序型的数据结构），那我们用比较纯朴的 Map &amp; Reduce 吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def even_filter(nums):</span><br><span class=\"line\">    return filter(lambda x: x%2&#x3D;&#x3D;0, nums)</span><br><span class=\"line\"></span><br><span class=\"line\">def multiply_by_three(nums):</span><br><span class=\"line\">    return map(lambda x: x*3, nums)</span><br><span class=\"line\"></span><br><span class=\"line\">def convert_to_string(nums):</span><br><span class=\"line\">    return map(lambda x: &#39;The Number: %s&#39; % x,  nums)</span><br><span class=\"line\"></span><br><span class=\"line\">nums &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">pipeline &#x3D; convert_to_string(</span><br><span class=\"line\">               multiply_by_three(</span><br><span class=\"line\">                   even_filter(nums)</span><br><span class=\"line\">               )</span><br><span class=\"line\">            )</span><br><span class=\"line\">for num in pipeline:</span><br><span class=\"line\">    print num</span><br></pre></td></tr></table></figure><br>上面的代码是不是更容易读了，但需要嵌套使用函数，这个有点儿不爽，如果我们能像下面这个样子就好了（第二种方式）。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pipeline_func(nums, [even_filter,</span><br><span class=\"line\">                     multiply_by_three,</span><br><span class=\"line\">                     convert_to_string])</span><br></pre></td></tr></table></figure><br>可以看到，其实，就是对一堆函数做一个 reduce， 于是，pipeline 函数可以实现成下面这样：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">def pipeline_func(data, fns):</span><br><span class=\"line\">    return reduce(lambda a, x: x(a),   fns,   data)</span><br></pre></td></tr></table></figure><br>当然，使用 Python 的 force 函数以及 decorator 模式可以把上面的代码写得更像管道：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Pipe(object):</span><br><span class=\"line\">    def __init__(self, func):</span><br><span class=\"line\">        self.func &#x3D; func</span><br><span class=\"line\"></span><br><span class=\"line\">    def __ror__(self, other):</span><br><span class=\"line\">        def generator():</span><br><span class=\"line\">            for obj in other:</span><br><span class=\"line\">                if obj is not None:</span><br><span class=\"line\">                    yield self.func(obj)</span><br><span class=\"line\">        return generator()</span><br><span class=\"line\"></span><br><span class=\"line\">@Pipe</span><br><span class=\"line\">def even_filter(num):</span><br><span class=\"line\">    return num if num % 2 &#x3D;&#x3D; 0 else None</span><br><span class=\"line\"></span><br><span class=\"line\">@Pipe</span><br><span class=\"line\">def multiply_by_three(num):</span><br><span class=\"line\">    return num*3</span><br><span class=\"line\"></span><br><span class=\"line\">@Pipe</span><br><span class=\"line\">def convert_to_string(num):</span><br><span class=\"line\">    return &#39;The Number: %s&#39; % num</span><br><span class=\"line\"></span><br><span class=\"line\">@Pipe</span><br><span class=\"line\">def echo(item):</span><br><span class=\"line\">    print item</span><br><span class=\"line\">    return item</span><br><span class=\"line\"></span><br><span class=\"line\">def force(sqs):</span><br><span class=\"line\">    for item in sqs: pass</span><br><span class=\"line\"></span><br><span class=\"line\">nums &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\"></span><br><span class=\"line\">force(nums | even_filter | multiply_by_three | convert_to_string | echo)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>相对于计算机发展史，函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。以 Stateless（无状态）和 Immutable（不可变）为主要特点，代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性——无论在什么场景下都会得到同样的结果。</p>\n<p>本文结合递归、map 和 reduce，以及 pipeline 等技术，对比了非函数式编程和函数式编程在解决相同问题时的不同处理思路，让你对函数式编程范式有了清晰明确的认知。并在文末引入了 decorator（修饰器），使得将普通函数管道化成为一件轻而易举的事情。此时你可能有疑问，decorator 到底是什么呢？怎样使用它呢？敬请关注下一章中的内容，来得到这些答案。</p>\n<p>了解了这么多函数式编程的知识，想请你深入思考一个问题：你是偏好在命令式编程语言中使用函数式编程风格呢，还是坚持使用函数式语言编程？</p>\n","tags":["mouse","thinking","programming_paradigm"]},{"title":"《重构：改善既有代码的设计》书摘","url":"/2019/09/30/read/refactoring/","content":"<p>对软件内部结构的一种调整，目的是在不改变软件可察行为的前提下，提高可理解性，降低修改成本。<br><a id=\"more\"></a></p>\n<h2 id=\"重构原则\"><a href=\"#重构原则\" class=\"headerlink\" title=\"重构原则\"></a>重构原则</h2><ol>\n<li>重构的定义<ul>\n<li>（名词形式）对软件内部结构的一种调整，目的是在不改变软件可察行为的前提下，提高可理解性，降低修改成本。</li>\n<li>（动词形式）使用一些列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li>\n</ul>\n</li>\n<li>软件开发的两顶帽子<ul>\n<li>添加新功能时，不应该修改既有代码，只管添加新功能并通过测试。</li>\n<li>重构时不再添加新功能，只管改进程序结构，并通过已有测试。</li>\n</ul>\n</li>\n<li>为何重构<ul>\n<li>重构改进软件设计（Design）</li>\n<li>重构使软件更容易理解（Maintain）</li>\n<li>重构帮助找到BUG（Debug）</li>\n<li>重构提高编程速度（Efficiency）</li>\n</ul>\n</li>\n<li>何时重构<ul>\n<li>三次法则：事不过三，三则重构</li>\n<li>添加功能时重构（New Feature）</li>\n<li>修补错误时重构（Bug Fix）</li>\n<li>复审代码时重构（Code Review）</li>\n</ul>\n</li>\n<li>何时不该重构<ul>\n<li>既有代码太混乱，且不能正常工作，需要重写而不是重构。</li>\n<li>项目接近最后期限时，应该避免重构。</li>\n</ul>\n</li>\n<li>重构的目标<ul>\n<li>为什么程序如此难以相与？    设计与重构的目标</li>\n<li>难以阅读的程序，难以修改    容易阅读</li>\n<li>逻辑重复的程序，难以修改    所有逻辑都只在唯一地点指定</li>\n<li>添加新行为时需要修改已有代码的程序，难以修改    新的改动不会危及现有行为</li>\n<li>带复杂条件逻辑的程序，难以修改    尽可能简单表达条件逻辑</li>\n</ul>\n</li>\n<li>间接层和重构<ul>\n<li>间接层的价值</li>\n<li>允许逻辑共享（避免重复代码）</li>\n<li>分开解释意图和实现（方法越短小，越容易起好名字揭示意图，单一职责）</li>\n<li>隔离变化（软件需要根据需求的变化不断修改，隔离缩小修改的范围）</li>\n<li>封装条件逻辑（多态消息）</li>\n<li>大多数重构都为程序引入了更多的间接层</li>\n<li>“计算机科学是这样一门科学：它相信所有问题都可以通过增加一个间接层来解决。” ——Dennis Debruler</li>\n<li>过多的间接层会导致代码的层次太深</li>\n<li>使代码难以阅读.因此要权衡加入间接层的利弊<h2 id=\"代码的坏味道\"><a href=\"#代码的坏味道\" class=\"headerlink\" title=\"代码的坏味道\"></a>代码的坏味道</h2>我觉得这一章的内容非常重要，识别出代码的坏味道，是正确重构的前提。</li>\n</ul>\n</li>\n<li><p>Duplicated Code（重复代码）</p>\n<ul>\n<li>代码有很多中坏味道，重复是最坏的一种。</li>\n<li>一个类中的两个方法有重复代码，可以通过抽取方法将重复代码放到另一个方法中以供调用；</li>\n<li>互为兄弟的子类中如果有重复代码，可以将重复代码抽取到父类中；</li>\n<li>两个没有关系的类中如果有重复代码，可以重新抽取一个类将重复代码放到这个第三方类中。</li>\n</ul>\n</li>\n<li><p>Long Method（过长函数）</p>\n<ul>\n<li>使用短小的方法首先符合高内聚的要求，同时给方法起一个好的名字，可以帮助理解方法的作用。</li>\n<li>如果感觉方法的某个地方需要注释来加以说明，可以把这部分代码放入一个独立的方法中，并以用途（而不是实现手法）来命名方法。</li>\n</ul>\n</li>\n<li><p>Large Class（过大的类）</p>\n<ul>\n<li>类的设计应当遵循单一职责原则（SRP）。重构一个巨大的类可以使用抽取接口的方式来搞清楚这个类应该如何分解。</li>\n</ul>\n</li>\n<li><p>Long Parameter List（过长参数列表）</p>\n<ul>\n<li>比较常见的是将相关的参数组织成一个对象来替换掉这些参数。</li>\n</ul>\n</li>\n<li><p>Divergent Change（发散式变化）</p>\n<ul>\n<li>因为不同的原因，在不同的方向上，修改同一个类。应该分解成更小的类，每个类只因一种原因而修改。</li>\n<li>这个深有体会，多层结构系统，开发人员往往容易把全部逻辑都放在Service层，导致Service类非常庞大且不断被修改。</li>\n</ul>\n</li>\n<li><p>Shotgun Surgery（霰弹式修改）</p>\n<ul>\n<li>每遇到变化，需要修改多个类，容易遗漏。应该把需要修改的部分放到一个类里。</li>\n</ul>\n</li>\n<li><p>Feature Envy（依恋情结）</p>\n<ul>\n<li>函数大量地使用了另外类的数据。这种情况下最好将此函数移动到那个类中</li>\n</ul>\n</li>\n<li><p>Data Clumps（数据泥团）</p>\n<ul>\n<li>两个类中相同的字段、函数签名中相同的参数等，都适合提取成一个单独的数据类</li>\n</ul>\n</li>\n<li><p>Primitive Obsession（基本类型偏执）</p>\n<ul>\n<li>如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 以类取代类型码(Replace Type Code with Class) 。</li>\n<li>如果基本数据类型字段的值是用于方法的参数，可以使用 引入参数对象(Introduce Parameter Object) 或 保持对象完整(Preserve Whole Object) 。</li>\n<li>如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 以类取代类型码(Replace Type Code with Class) 将它替换掉。如果你有与类型码相关的条件表达式，可运用 以子类取代类型码(Replace Type Code with Subclass) 或 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 加以处理。</li>\n<li>如果你发现自己正从数组中挑选数据，可运用 以对象取代数组(Replace Array with Object) 。</li>\n</ul>\n</li>\n<li><p>Switch Statements（switch惊悚现身）</p>\n<ul>\n<li>先将switch语句提炼成独立的函数，然后再将此函数搬移到需要多态的类里。</li>\n</ul>\n</li>\n<li><p>Parallel Inheritance（平行继承体系）</p>\n<ul>\n<li>是Shortgun Surgery的一种特殊情况，每当为某个类增加一个子类，必须也为另外一个类相应增加一个子类。</li>\n</ul>\n</li>\n<li><p>Lazy Class（冗赘类）</p>\n<ul>\n<li>如果一个类不值得存在，那么它就应该消失。</li>\n</ul>\n</li>\n<li><p>Speculative Generality（夸夸其谈未来性）</p>\n<ul>\n<li>如果你的抽象类、委托、方法的参数没有实际的作用，那么就应当被移除掉。</li>\n</ul>\n</li>\n<li><p>Temporary Field（令人迷惑的暂时字段）</p>\n<ul>\n<li>类中某个字段只为某些特殊情况而设置。</li>\n</ul>\n</li>\n<li><p>Message Chains（过度耦合的消息链）</p>\n<ul>\n<li>常常是因为数据结构的层次很深，需要层层调用getter获取内层数据。个人认为Message Chains如果频繁出现，考虑这个字段是否应该移到较外层的类，或者把调用链封装在较外层类的方法。</li>\n</ul>\n</li>\n<li><p>Middle Man（中间人）</p>\n<ul>\n<li>如果一个类的很多功能都通过委托给其他类来完成，那么就不如去掉这些中间人直接和真正负责的对象打交道。</li>\n</ul>\n</li>\n<li><p>Inappropriate Intimacy（两个类过度亲密）</p>\n<ul>\n<li>将双向关联改为单向关联（Change Bidirectional Association to Unidirectional）。</li>\n<li>提炼类，将两个类的共同点提炼到新类中，让它们共同使用新类。</li>\n<li>继承往往造成过度亲密，运用以委托取代继承（Replace Inheritance with Delegate）。</li>\n</ul>\n</li>\n<li><p>Alternative Classes（异曲同工的类）</p>\n</li>\n<li><p>Incomplete Lib Class（不完美的类库）</p>\n<ul>\n<li>修改类库的一两个函数 - 引入外部函数（Introduce Foreign Method）</li>\n<li>添加一大堆额外行为 - 添加本地扩展（Introduce Local Extension）</li>\n</ul>\n</li>\n<li><p>Data Class（纯稚的数据类）</p>\n<ul>\n<li>数据类不应该把全部字段单纯的通过getter/setter暴露出来（我们在多层结构系统开发时经常这么做），</li>\n<li>而应该暴露抽象接口，封装内部结构。</li>\n</ul>\n</li>\n<li><p>Refused Bequest（被拒绝的遗赠）</p>\n<ul>\n<li>子类继承父类的所有函数和数据，子类只挑选几样来使用。</li>\n<li>为子类新建一个兄弟类，再运用下移方法（Push Down Method）和下移字段（Push Down Field）把用不到的函数下推个兄弟类。</li>\n<li>子类只复用了父类的行为，却不想支持父类的接口。</li>\n<li>运用委托替代继承（Replace Inheritance with Delegation）来达到目的。</li>\n</ul>\n</li>\n<li>Comments（过多的注释）<ul>\n<li>注释不是用来补救劣质代码的，事实上如果我们去除了代码中的所有坏味道，当劣质代码都被移除的时候，注释已经变得多余，因为代码已经讲清楚了一切。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、构筑测试体系\"><a href=\"#四、构筑测试体系\" class=\"headerlink\" title=\"四、构筑测试体系\"></a>四、构筑测试体系</h2><p>测试是安全重构的前提。在项目开发工作中，我们要求添加新代码必须有单元测试，重构旧代码也要先加单元测试。</p>\n<h2 id=\"五、重构列表\"><a href=\"#五、重构列表\" class=\"headerlink\" title=\"五、重构列表\"></a>五、重构列表</h2><p>Java开发，由于IDE（Intellij Idea）能够很好的支持大多数情况下的重构，有各种的自动提示，所以感觉暂时不需要用到重构列表。</p>\n<h2 id=\"六、重新组织函数\"><a href=\"#六、重新组织函数\" class=\"headerlink\" title=\"六、重新组织函数\"></a>六、重新组织函数</h2><ol>\n<li><p>Extract Method 提炼函数</p>\n<ul>\n<li>将一段代码放进一个独立函数中，并让函数名称解释该函数的用途。</li>\n<li>增加可读性，函数粒度小更容易被复用和覆写。</li>\n</ul>\n</li>\n<li><p>Inline Method（内联函数）</p>\n<ul>\n<li>在函数调用点插入函数本体，然后移除该函数。</li>\n<li>函数的本体与名称同样清楚易懂，间接层太多反而不易理解。</li>\n</ul>\n</li>\n<li><p>Inline Temp（内联临时变量）</p>\n<ul>\n<li>将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。</li>\n</ul>\n</li>\n<li><p>Replace Temp with Query（以查询取代临时变量）</p>\n<ul>\n<li>将一个表达式提炼到一个独立函数中，并将临时变量的引用点替换为对函数的调用。</li>\n<li>临时变量扩展为查询函数，就可以将使用范围扩展到整个类。</li>\n<li>减少临时变量，使函数更短更易维护。</li>\n</ul>\n</li>\n<li><p>Introduce Explaining Variable（引入解释性变量）</p>\n<ul>\n<li>将该复杂表达式的结果放进一个临时变量，以变量名来解释其用途。</li>\n</ul>\n</li>\n<li><p>Split Temporary Variable（分解临时变量）</p>\n<ul>\n<li>针对每次赋值，创造一个独立、对应的临时变量。</li>\n<li>临时变量会被多次赋值，容易产生理解歧义。</li>\n<li>如果变量被多次赋值（除了“循环变量”和“结果收集变量”），说明承担了多个职责，应该分解。</li>\n</ul>\n</li>\n<li><p>Remove Assignments to Parameters（移除对参数的赋值）</p>\n<ul>\n<li>以一个临时变量取代该参数的位置。</li>\n<li>对参数赋值容易降低代码的清晰度；</li>\n<li>容易混淆按值传递和按引用传递的方式 ；</li>\n</ul>\n</li>\n<li><p>Replace Method with Method object 函数对象取代函数</p>\n<ul>\n<li>一个大型函数如果包含了很多临时变量，用Extract Method很难拆解，</li>\n<li>可以把函数放到一个新创建的类中，把临时变量变成类的实体变量，再用Extract Method拆解。</li>\n</ul>\n</li>\n<li><p>Substitute Algorithm 替换算法</p>\n<ul>\n<li>复杂的算法会增加维护的成本，替换成较简单的算法实现，往往能明显提高代码的可读性和可维护性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"七、在对象之间搬移特性\"><a href=\"#七、在对象之间搬移特性\" class=\"headerlink\" title=\"七、在对象之间搬移特性\"></a>七、在对象之间搬移特性</h2><p>在面向对象的设计过程中，“决定把责任放在哪儿”是最重要的事之一。最常见的烦恼是：你不可能一开始就保证把事情做对。在这种情况下，就可以大胆使用重构，改变自己原先的设计。</p>\n<ol>\n<li><p>Move Method 移动函数</p>\n<ul>\n<li>类的行为做到单一职责，不要越俎代庖。</li>\n<li>如果一个类有太多行为，或一个类与另一个类有太多合作而形成高度耦合，就需要搬移函数。</li>\n<li>观察调用它的那一端、它调用的那一端，已经继承体系中它的任何一个重定义函数。</li>\n<li>根据“这个函数不哪个对象的交流比较多”，决定其移动路径。</li>\n</ul>\n</li>\n<li><p>Move Field（搬移字段）</p>\n<ul>\n<li>如果一个类的字段在另一个类中使用更频繁，就考虑搬移它。</li>\n</ul>\n</li>\n<li><p>Extract Class提炼类</p>\n<ul>\n<li>一个类应该是一个清楚地抽象，处理一些明确的责仸。</li>\n</ul>\n</li>\n<li><p>Inline Class 将类内联化</p>\n<ul>\n<li>Inline Class （将类内联化）正好于Extract Class （提炼类）相反。如果一个类丌再承担足够责仸、丌再有单独存在的理由。将这个类的所有特性搬移到另一个类中，然后移除原类。</li>\n</ul>\n</li>\n<li><p>Hide Delegate 隐藏委托关系</p>\n<ul>\n<li>在服务类上建立客户所需的所有函数，用以隐藏委托关系</li>\n</ul>\n</li>\n<li><p>Remove Middle Man（移除中间人）</p>\n<ul>\n<li>封装委托对象也是要付出代价的：每当客户要使用受托类的新特性时，就必须在服务端添加一个委托函数。</li>\n<li>随着委托类的特性（功能）越来越多，服务类完全变成了“中间人”，此时就应该让客户直接调用受托类。</li>\n<li>很难说什么程度的隐藏才是合适的，随着系统不断变化，使用Hide Delegate和Remove Middle Man不断调整。</li>\n</ul>\n</li>\n<li><p>Introduce Foreign Method 引入外加函数</p>\n<ul>\n<li>你需要为提供服务的类增加一个函数，但你无法修改这个类。</li>\n<li>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</li>\n</ul>\n</li>\n<li><p>Introduce Local Extension 引入本地扩展</p>\n<ul>\n<li>你需要为服务类提供一些额外函数，但你无法修改这个类。</li>\n<li>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类戒包装类。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"重新组织数据\"><a href=\"#重新组织数据\" class=\"headerlink\" title=\"重新组织数据\"></a>重新组织数据</h2><ol>\n<li><p>Self Encapsulate Field自封装字段</p>\n<ul>\n<li>为这个字段建立getter/setter函数，并且只以这些函数访问字段。</li>\n<li>直接访问一个字段，导致出现强耦合关系；</li>\n<li>直接访问的好处是易阅读，间接访问的好处是好管理，子类好覆写。</li>\n</ul>\n</li>\n<li><p>Replace Data Value with Object 对象取代数据值</p>\n<ul>\n<li>一个数据项，需要与其他数据和行为一起使用才有意义。将数据项改成对象。</li>\n<li>随着设计深入，数据之间的关系逐渐显现出来，就需要将相关数据及其操作封装成对象。</li>\n</ul>\n</li>\n<li><p>Change value to Reference 将值对象改为引用对象</p>\n<ul>\n<li>如果希望修改某个值对象的数据，并且影响到所有引用此对象的地方。</li>\n<li>将这个值对象变成引用对象。</li>\n<li>组合改为关联</li>\n</ul>\n</li>\n<li><p>Change Reference to Value 将引用对象改为值对象</p>\n<ul>\n<li>引用对象很小且不可变，将它改成一个值对象。</li>\n</ul>\n</li>\n<li><p>Replace Array with Object 以对象取代数组</p>\n<ul>\n<li>数组中的元素各自代表不同的东西。</li>\n<li>以对象替换数组，对于数组中的每个元素，以一个字段来表示。</li>\n</ul>\n</li>\n<li><p>Change Unidirection Association to Bidirectional 将单向关联改为双向关联</p>\n<ul>\n<li>两个类都需要使用对方特性，但其间只有一条单向连接。</li>\n<li>添加一个反向指针，并使修改函数能够同时更新2条连接。</li>\n</ul>\n</li>\n<li><p>Change Bidirectional Association to Unidirection将双向关联改为单向关联</p>\n<ul>\n<li>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。</li>\n</ul>\n</li>\n<li><p>Replace Magic Number with Symbolic Constant字面常量取代魔法数</p>\n<ul>\n<li>你有一个字面数值，带有特别含义。</li>\n<li>创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。</li>\n</ul>\n</li>\n<li><p>Encapsulate Field 封装字段</p>\n<ul>\n<li>你的类中存在一个public字段。将它声明为private，并提供相应的访问函数。</li>\n</ul>\n</li>\n<li><p>Encapsulate Coolection 封装集合</p>\n<ul>\n<li>如果一个函数返回一个集合，应改为返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</li>\n</ul>\n</li>\n<li><p>Replace Record with Data Class 以数据类取代记录</p>\n</li>\n<li><p>Replace Type Code with Class 以类来取代类型码</p>\n<ul>\n<li>类中有一个数值类型码，但它并不影响类的行为。以一个新的类替换该数值类型码。</li>\n</ul>\n</li>\n<li><p>Replace Type Code with Subclasses 以子类来取代类型码</p>\n<ul>\n<li>如果类型码不会影响宿主类的行为，可以使用Replace Type Code with Class （以类取代类型码）来处理。</li>\n<li>但如果类型码会影响宿主类的行为，最好的办法是多态来处理变化行为。</li>\n</ul>\n</li>\n<li><p>Replace Type Code with State/Strategy 以状态/策略取代类型码</p>\n<ul>\n<li>你有一个类型码，它会影响类的行为，但你无法提供继承手法消除它。以状态对象替代类型码。</li>\n</ul>\n</li>\n<li><p>Replace Subclass with Fieldls 以字段取代子类</p>\n<ul>\n<li>你的各个子类的唯一差别只在“返回常量数据”的函数身上。</li>\n<li>修改这些函数，使它们返回超类中的某个字段（新增），然后销毁子类。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"简化表达式\"><a href=\"#简化表达式\" class=\"headerlink\" title=\"简化表达式\"></a>简化表达式</h2><p>在面向对象的设计过程中，表达式的使用通常较少，因为很多条件行为都被多态机制处理掉了，所以条件的扩展更为容易。有时候条件逻辑可能十分复杂，可以使用本章提供的一些重构手法来简化它们。</p>\n<ol>\n<li><p>Decompose Conditional 分解条件表达式</p>\n<ul>\n<li>程序中，复杂的条件逻辑是最常导致复杂度上升的地点之一。</li>\n<li>可以将它分解为多个独立函数，根据每个小块代码的用途，为分解的新函数命名，从而更清楚的表达意图。</li>\n</ul>\n</li>\n<li><p>Consolidate Conditional Expression 合并条件表达式</p>\n<ul>\n<li>一系列条件测试，都得到相同结果。</li>\n<li>将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立函数。</li>\n</ul>\n</li>\n<li><p>Consolodate Duplicate Conditional Fragments 合并重复的条件片段</p>\n<ul>\n<li>在条件表达式的每个分支上有着相同的一段代码。将这段重复代码移到条件表达式之外。</li>\n</ul>\n</li>\n<li><p>Remove Control Flag 移除控制标记</p>\n<ul>\n<li>以break或return语句取代控制标记。</li>\n</ul>\n</li>\n<li><p>Replace Nested Conditional with Guard Clauses 以卫语句取代嵌套条件表达式</p>\n</li>\n<li><p>Replace Conditional with Polymorphism 以多态取代条件表达式</p>\n<ul>\n<li>一个条件表达式，它根据对象类型的丌同而选择丌同的行为。</li>\n<li>将这个条件表达式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。</li>\n</ul>\n</li>\n<li><p>Introduce Assertion 引入断言</p>\n<ul>\n<li>某一段代码需要对程序状态做出某种假设。以断言明确表现这种假设。</li>\n<li>使用断言明确标明对输入条件的严格要求和限制；</li>\n<li>断言可以辅助交流和调试。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"十、简化函数调用\"><a href=\"#十、简化函数调用\" class=\"headerlink\" title=\"十、简化函数调用\"></a>十、简化函数调用</h2><p>在面向对象的设计技术中，最重要的概念莫过于“接口”（interface）。容易被理解和被使用的接口，是开发良好面向对象软件的关键。</p>\n<ol>\n<li><p>Rename Method 函数改名</p>\n</li>\n<li><p>Add Parameter 添加参数</p>\n<ul>\n<li>某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带进函数所需信息。</li>\n</ul>\n</li>\n<li><p>Remove Parameter（移除参数）</p>\n<ul>\n<li>函数不再需要某个参数时，将其移除</li>\n</ul>\n</li>\n<li><p>Separate Query from Modifier 将查询函数和修改函数分离</p>\n</li>\n<li><p>Parameterize Method 令函数携带参数</p>\n<ul>\n<li>若干函数做了类似的工作，但在函数本体中却包含了不同的值。</li>\n<li>建立一个单一函数，以参数表达那些不同的值。</li>\n</ul>\n</li>\n<li><p>Replace Parameter with Explicit Methods 以明确函数取代参数</p>\n<ul>\n<li>某个函数完全取决于参数值而采取不同行为，为了获得一个清晰的接口，</li>\n<li>针对该参数的每一个可能值，建立一个独立函数。</li>\n</ul>\n</li>\n<li><p>Preserve whole object 保持对象完整</p>\n<ul>\n<li>如果从对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。</li>\n<li>除了可以使参数列更稳固外，还能简化参数列表，提高代码的可读性。</li>\n<li>此外，使用完整对象，被调用函数可以利用完整对象中的函数来计算某些中间值。</li>\n<li>不过事情总有2面：如果你传的是数值，被调用函数就叧依赖于这些数值。但如果你传递的是整个对象，被调用函数所在的对象就需要依赖参数对象。如果这会使你的依赖结构恶化，那么就不该使用。</li>\n<li>有的观点认为：如果被调用函数只需要参数对象的其中一项数值，那么只传递那个数值会更好。这个观点不能被认同：因为传递一项数值和传递一个对象，至少在代码清晰度上是一致的。更重要的考量应该放在对象之间的依赖关系上。</li>\n</ul>\n</li>\n<li><p>Replace Parameter with Methods 以函数取代参数</p>\n<ul>\n<li>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。</li>\n<li>而接受该参数的函数本身也能够调用前一个函数。</li>\n<li>让参数接受者去除该项参数，并直接调用前一个函数。</li>\n</ul>\n</li>\n<li><p>Introduce Parameter Object 引入参数对象</p>\n<ul>\n<li>如果一组参数总是一起被传递，以一个对象取代这些参数。</li>\n</ul>\n</li>\n<li><p>Replace Error Code with Exception 以异常取代错误码</p>\n</li>\n<li><p>Replace Exception with Test 以测试取代异常</p>\n<ul>\n<li>面对调用者可以预先检查的条件，在调用函数之前应该先做检查，而不是直接捕获异常。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"十一、处理概况关系\"><a href=\"#十一、处理概况关系\" class=\"headerlink\" title=\"十一、处理概况关系\"></a>十一、处理概况关系</h2><p>在面向对象的设计过程中，概括（继承）关系是其核心特性。良好的继承体系可以显著地提高程序的易读性和易理解性，增加了未来修改和扩展的灵活性。</p>\n<ol>\n<li><p>Pull Up Field 字段上移</p>\n<ul>\n<li>两个子类拥有相同的字段。将该字段移至超类。</li>\n</ul>\n</li>\n<li><p>Pull up Method 函数上移</p>\n<ul>\n<li>有些函数，在各个子类中产生完全相同的结果。将该函数移至超类。</li>\n</ul>\n</li>\n<li><p>Pull up Constructor Body 构造函数本体上移</p>\n<ul>\n<li>各个子类中拥有一些极造函数，它们的本体几乎完全一致。</li>\n<li>在超类中新建一个构造函数，并在子类构造函数中调用它。</li>\n</ul>\n</li>\n<li><p>Push down Method 函数下移</p>\n<ul>\n<li>超类中的某个函数只与部分子类有关。将这个函数移到相关的那些子类去。</li>\n</ul>\n</li>\n<li><p>Push down Fiedld 字段下移</p>\n<ul>\n<li>超类中的某个字段只被部分子类用到，将这个字段移到需要它的那些子类去。</li>\n</ul>\n</li>\n<li><p>Extract Subclass 提炼子类</p>\n<ul>\n<li>类中的某些特性只被某些实例用到。新建一个子类，将这部分特性移到子类中。</li>\n</ul>\n</li>\n<li><p>Extract Superclass 提炼超类</p>\n<ul>\n<li>两个类有相似特性。为这2个类建立一个超类，将相同特性移至超类。</li>\n</ul>\n</li>\n<li><p>From TemPlate Method 塑造模板函数</p>\n<ul>\n<li>一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节不同。</li>\n<li>将这些操作分别放迚独立的函数中，并保持它们都有相同的签名，于是原函数也就变得相同了，然后将原函数上移至超类。</li>\n</ul>\n</li>\n<li><p>Replace Inheritance with delegation 以委托取代继承</p>\n<ul>\n<li>某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。</li>\n<li>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉2者之间的继承关系。</li>\n</ul>\n</li>\n<li><p>Replace delegation with Inheritance 以继承代替委托</p>\n<ul>\n<li>两个类之间使用委托关系，并经常为整个接口编写许多简单的委托函数。让委托类继承受托类。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"十二、大型重构\"><a href=\"#十二、大型重构\" class=\"headerlink\" title=\"十二、大型重构\"></a>十二、大型重构</h2><p>在一知半解的情况下做出的设计决策，一旦堆积起来，也会使你的程序陷于瘫痪。通过重构，可以保证随时在程序中反映出完整的设计思路。</p>\n<ol>\n<li><p>Tease apart Inheritance 梳理并分解继承体系</p>\n<ul>\n<li>某个继承体系同时承担两项责任。</li>\n<li>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。</li>\n</ul>\n</li>\n<li><p>Convert Procedural design to Objects 将过程化设计转化为对象设计</p>\n<ul>\n<li>你手上有一些传统过程风格的代码 。</li>\n<li>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。</li>\n</ul>\n</li>\n<li><p>Separate Domain from from Presention 将领域和表述/显示分离</p>\n<ul>\n<li>某些GUI类之中包含了领域逻辑 ,将领域逻辑分离出来，为它们建立独立的领域类</li>\n</ul>\n</li>\n<li><p>Extract Hierarchy 提炼继承体系</p>\n<ul>\n<li>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的 ,</li>\n<li>建立继承体系，以一个子类表示一种特殊情况</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"十三、重构、复用与现实\"><a href=\"#十三、重构、复用与现实\" class=\"headerlink\" title=\"十三、重构、复用与现实\"></a>十三、重构、复用与现实</h2><ol>\n<li><p>项目开始时的选择</p>\n<ul>\n<li>重写整个程序</li>\n<li>可以依赖自己的经验纠正程序中的错误，但谁来付钱呢？你又如何保证新的系统能够完成旧系统所做的每一件事呢？</li>\n<li>复制、修改、扩展</li>\n<li>随着时间流逝，错误会不断地被复制、被传播，程序变得臃肿，当初的设计开始腐败变质，修改的整体成本逐渐上升。</li>\n<li>重构是两个极端之间的中庸之道</li>\n<li>通过重新组织软件结构，重构使得设计思路更详尽明确，抽取可复用组件，使得软件架构更清晰，增加新功能更容易，使程序更简洁有力。</li>\n</ul>\n</li>\n<li><p>为什么开发者不愿意重构他们的程序？</p>\n<ul>\n<li>不知道如何重构？</li>\n<li>重构的收益是长远的，也许那时你已经离开当初的职位了，所以没有动力去实施重构。</li>\n<li>代码重构是一项额外工作，老板并不会为此付钱。</li>\n<li>重构有可能破坏现有程序。</li>\n</ul>\n</li>\n<li><p>重构以获得短期收益</p>\n<ul>\n<li>重构可以带来短期利益，让软件更易修改、更易维护。重构只是一种手段，不是目的。</li>\n<li>它是“程序员或程序开发团队如何开发并维护自己的软件”这一更宽广场景的一部分。</li>\n</ul>\n</li>\n<li><p>重构为设计模式</p>\n<ul>\n<li>设计模式</li>\n<li>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</li>\n<li>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</li>\n<li>每种模式在现在中都有相应的原理来与之对应，并且描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</li>\n<li>重构为设计模式</li>\n<li>在很多时候，将代码重构为符合设计模式的要求也是重构的一个最佳目标。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本书主要涉及重构中的各种细节问题，从如何识别代码的坏味道，到重新组织函数、对象、数据，再到简化表达式、简化函数调用，再到更高层级的处理概况（继承）关系、大型重构。熟练掌握重构技巧，需要在学习工作中反复的练习，并不断思考为什么要这么做（违反面向对象原则、坏味道等等）。</p>\n","categories":["read"],"tags":["note","software"]},{"title":"An Extensive Guide To Progressive Web Applications","url":"/2018/12/03/js/note-an-extensive-guide-to-progressive-web-applications/","content":"<p>In this article, we’ll look at the pain points of users who are browsing old non-PWA websites and the promise of PWAs to make the web great. You’ll learn most of the important technologies that make for cool PWAs, like service workers, web push notifications and IndexedDB.<br><a id=\"more\"></a></p>\n<p>It was my dad’s birthday, and I wanted to order a chocolate cake and a shirt for him. I headed over to Google to search for chocolate cakes and clicked on the first link in the search results. There was a blank screen for a few seconds; I didn’t understand what was happening. After a few seconds of staring patiently, my mobile screen filled with delicious-looking cakes. As soon as I clicked on one of them to check its details, I got an ugly fat popup, asking me to install an Android application so that I could get a silky smooth experience while ordering a cake.</p>\n<p>That was disappointing. My conscience didn’t allow me to click on the “Install” button. All I wanted to do was order a small cake and be on my way.</p>\n<p>I clicked on the cross icon at the very right of the popup to get out of it as soon as I could. But then the installation popup sat at the bottom of the screen, occupying one-fourth of the space. And with the flaky UI, scrolling down was a challenge. I somehow managed to order a Dutch cake.</p>\n<p>After this terrible experience, my next challenge was to order a shirt for my dad. As before, I search Google for shirts. I clicked on the first link, and in a blink, the entire content was right in front of me. Scrolling was smooth. No installation banner. I felt as if I was browsing a native application. There was a moment when my terrible internet connection gave up, but I was still able to see the content instead of a dinosaur game. Even with my janky internet, I managed to order a shirt and jeans for my dad. Most surprising of all, I was getting notifications about my order.</p>\n<p>I would call this a silky smooth experience. These people were doing something right. Every website should do it for their users. It’s called a progressive web app.</p>\n<p>As Alex Russell states in one of <span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbmZyZXF1ZW50bHkub3JnLzIwMTUvMDYvcHJvZ3Jlc3NpdmUtYXBwcy1lc2NhcGluZy10YWJzLXdpdGhvdXQtbG9zaW5nLW91ci1zb3VsLw==\">his blog posts<i class=\"fa fa-external-link-alt\"></i></span>:</p>\n<blockquote>\n<p>“It happens on the web from time to time that powerful technologies come to exist without the benefit of marketing departments or slick packaging. They linger and grow at the peripheries, becoming old-hat to a tiny group while remaining nearly invisible to everyone else. Until someone names them.”</p>\n</blockquote>\n<h2 id=\"A-Silky-Smooth-Experience-On-The-Web-Sometimes-Known-As-A-Progressive-Web-Application\"><a href=\"#A-Silky-Smooth-Experience-On-The-Web-Sometimes-Known-As-A-Progressive-Web-Application\" class=\"headerlink\" title=\"A Silky Smooth Experience On The Web, Sometimes Known As A Progressive Web Application\"></a>A Silky Smooth Experience On The Web, Sometimes Known As A Progressive Web Application</h2><p>Progressive web applications (PWAs) are more of a methodology that involves a combination of technologies to make powerful web applications. With an improved user experience, people will spend more time on websites and see more advertisements. They tend to buy more, and with notification updates, they are more likely to visit often. The Financial Times abandoned its native apps in 2011 and built a web app using the best technologies available at the time. Now, the product has grown into a full-fledged PWA.</p>\n<p>But why, after all this time, would you build a web app when a native app does the job well enough?</p>\n<p>Let’s look into some of the metrics shared in Google IO 17.</p>\n<p>Five billion devices are connected to the web, making the web the biggest platform in the history of computing. On the mobile web, 11.4 million monthly unique visitors go to the top 1000 web properties, and 4 million go to the top thousand apps. The mobile web garners around four times as many users as native applications. But this number drops sharply when it comes to engagement.</p>\n<p>A user spends an average of 188.6 minutes in native apps and only 9.3 minutes on the mobile web. Native applications leverage the power of operating systems to send push notifications to give users important updates. They deliver a better user experience and boot more quickly than websites in a browser. Instead of typing a URL in the web browser, users just have to tap an app’s icon on the home screen.</p>\n<p>Most visitors on the web are unlikely to come back, so developers came up with the workaround of showing them banners to install native applications, in an attempt to keep them deeply engaged. But then, users would have to go through the tiresome procedure of installing the binary of a native application. Forcing users to install an application is annoying and reduces further the chance that they will install it in the first place. The opportunity for the web is clear.</p>\n<p>Recommended reading: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc21hc2hpbmdtYWdhemluZS5jb20vMjAxOC8wMi9uYXRpdmUtYW5kLXB3YS1jaG9pY2VzLW5vdC1jaGFsbGVuZ2Vycy8=\">Native And PWA: Choices, Not Challengers!<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>If web applications come with a rich user experience, push notifications, offline support and instant loading, they can conquer the world. This is what a progressive web application does.</p>\n<p>A PWA delivers a rich user experience because it has several strengths:</p>\n<ul>\n<li><p>Fast<br>The UI is not flaky. Scrolling is smooth. And the app responds quickly to user interaction.</p>\n</li>\n<li><p>Reliable<br>A normal website forces users to wait, doing nothing, while it is busy making rides to the server. A PWA, meanwhile, loads data instantaneously from the cache. A PWA works seamlessly, even on a 2G connection. Every network request to fetch an asset or piece of data goes through a service worker (more on that later), which first verifies whether the response for a particular request is already in the cache. When users get real content almost instantly, even on a poor connection, they trust the app more and view it as more reliable.</p>\n</li>\n<li><p>Engaging<br>A PWA can earn a place on the user’s home screen. It offers a native app-like experience by providing a full-screen work area. It makes use of push notifications to keep users engaged.</p>\n</li>\n</ul>\n<p>Now that we know what PWAs bring to the table, let’s get into the details of what gives PWAs an edge over native applications. PWAs are built with technologies such as <strong>service workers, web app manifests, push notifications and IndexedDB/local data structure</strong> for caching. Let’s look into each in detail.</p>\n<h3 id=\"Service-Workers\"><a href=\"#Service-Workers\" class=\"headerlink\" title=\"Service Workers\"></a>Service Workers</h3><p>A service worker is a JavaScript file that runs in the background without interfering with the user’s interactions. All GET requests to the server go through a service worker. It acts like a client-side proxy. By intercepting network requests, it takes complete control over the response being sent back to the client. A PWA loads instantly because service workers eliminate the dependency on the network by responding with data from the cache.</p>\n<p>A service worker can only intercept a network request that is in its scope. For example, a root-scoped service worker can intercept all of the fetch requests coming from a web page. A service worker operates as an event-driven system. It goes into a dormant state when it is not needed, thereby conserving memory. To use a service worker in a web application, we first have to register it on the page with JavaScript.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(function main () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   &#x2F;* navigator is a WEB API that allows scripts to register themselves and carry out their activities. *&#x2F;</span><br><span class=\"line\">    if (&#39;serviceWorker&#39; in navigator) &#123;</span><br><span class=\"line\">        console.log(&#39;Service Worker is supported in your browser&#39;)</span><br><span class=\"line\">        &#x2F;* register method takes in the path of service worker file and returns a promises, which returns the registration object *&#x2F;</span><br><span class=\"line\">        navigator.serviceWorker.register(&#39;.&#x2F;service-worker.js&#39;).then (registration &#x3D;&gt; &#123;</span><br><span class=\"line\">            console.log(&#39;Service Worker is registered!&#39;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        console.log(&#39;Service Worker is not supported in your browser&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<p>We first check whether the browser supports service workers. To register a service worker in a web application, we provide its URL as a parameter to the <code>register</code> function, available in <code>navigator.serviceWorker</code> (<code>navigator</code> is a web API that allows scripts to register themselves and carry out their activities). A service worker is registered only once. Registration does not happen on every page load. The browser downloads the service worker file (<code>./service-worker.js</code>) only if there is a byte difference between the existing activated service worker and the newer one or if its URL has changed.</p>\n<p>The above service worker will intercept all requests coming from the root (<code>/</code>). To limit the scope of a service worker, we would pass an optional parameter with one of the keys as the scope.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (&#39;serviceWorker&#39; in navigator) &#123;</span><br><span class=\"line\">    &#x2F;* register method takes in an optional second parameter as an object. To restrict the scope of a service worker, the scope should be provided.</span><br><span class=\"line\">        scope: &#39;&#x2F;books&#39; will intercept requests with &#39;&#x2F;books&#39; in the url. *&#x2F;</span><br><span class=\"line\">    navigator.serviceWorker.register(&#39;.&#x2F;service-worker.js&#39;, &#123; scope: &#39;&#x2F;books&#39; &#125;).then(registration &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(&#39;Service Worker for scope &#x2F;books is registered&#39;, registration)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The service worker above will intercept requests that have <code>/books</code> in the URL. For example, it will not intercept request with <code>/products</code>, but it could very well intercept requests with <code>/books/products</code>.</p>\n<p>As mentioned, a service worker operates as an event-driven system. It listens for events (install, activate, fetch, push) and accordingly calls the respective event handler. Some of these events are a part of the life cycle of a service worker, which goes through these events in sequence to get activated.</p>\n<h4 id=\"INSTALLATION\"><a href=\"#INSTALLATION\" class=\"headerlink\" title=\"INSTALLATION\"></a>INSTALLATION</h4><p>Once a service worker has been registered successfully, an installation event is fired. This is a good place to do the initialization work, like setting up the cache or creating object stores in IndexedDB. (IndexedDB will make more sense to you once we get into its details. For now, we can just say that it’s a key-value pair structure.)<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;install&#39;, (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    let CACHE_NAME &#x3D; &#39;xyz-cache&#39;</span><br><span class=\"line\">    let urlsToCache &#x3D; [</span><br><span class=\"line\">        &#39;&#x2F;&#39;,</span><br><span class=\"line\">        &#39;&#x2F;styles&#x2F;main.css&#39;,</span><br><span class=\"line\">        &#39;&#x2F;scripts&#x2F;bundle.js&#39;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        &#x2F;* open method available on caches, takes in the name of cache as the first parameter. It returns a promise that resolves to the instance of cache</span><br><span class=\"line\">        All the URLS above can be added to cache using the addAll method. *&#x2F;</span><br><span class=\"line\">        caches.open(CACHE_NAME)</span><br><span class=\"line\">        .then (cache &#x3D;&gt; cache.addAll(urlsToCache))</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Here, we’re caching some of the files so that the next load is instant. <code>self</code> refers to the service worker instance. <code>event.waitUntil</code> makes the service worker wait until all of the code inside it has finished execution.</p>\n<h4 id=\"ACTIVATION\"><a href=\"#ACTIVATION\" class=\"headerlink\" title=\"ACTIVATION\"></a>ACTIVATION</h4><p>Once a service worker has been installed, it cannot yet listen for fetch requests. Rather, an <code>activate</code> event is fired. If no active service worker is operating on the website in the same scope, then the installed service worker gets activated immediately. However, if a website already has an active service worker, then the activation of a new service worker is delayed until all of the tabs operating on the old service worker are closed. This makes sense because the old service worker might be using the instance of the cache that is now modified in the newer one. So, the activation step is a good place to get rid of old caches.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;activate&#39;, (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    let cacheWhitelist &#x3D; [&#39;products-v2&#39;] &#x2F;&#x2F; products-v2 is the name of the new cache</span><br><span class=\"line\"></span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        caches.keys().then (cacheNames &#x3D;&gt; &#123;</span><br><span class=\"line\">            return Promise.all(</span><br><span class=\"line\">                cacheNames.map( cacheName &#x3D;&gt; &#123;</span><br><span class=\"line\">                    &#x2F;* Deleting all the caches except the ones that are in cacheWhitelist array *&#x2F;</span><br><span class=\"line\">                    if (cacheWhitelist.indexOf(cacheName) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class=\"line\">                        return caches.delete(cacheName)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>In the code above, we’re deleting the old cache. If the name of a cache doesn’t match with the <code>cacheWhitelist</code>, then it is deleted. To skip the waiting phase and immediately activate the service worker, we use <code>skip.waiting()</code>.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;activate&#39;, (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    self.skipWaiting()</span><br><span class=\"line\">    &#x2F;&#x2F; The usual stuff</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Once service worker is activated, it can listen for fetch requests and push events.</p>\n<h4 id=\"FETCH-EVENT-HANDLER\"><a href=\"#FETCH-EVENT-HANDLER\" class=\"headerlink\" title=\"FETCH EVENT HANDLER\"></a>FETCH EVENT HANDLER</h4><p>Whenever a web page fires a fetch request for a resource over the network, the fetch event from the service worker gets called. The fetch event handler first looks for the requested resource in the cache. If it is present in the cache, then it returns the response with the cached resource. Otherwise, it initiates a fetch request to the server, and when the server sends back the response with the requested resource, it puts it to the cache for subsequent requests.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;* Fetch event handler for responding to GET requests with the cached assets *&#x2F;</span><br><span class=\"line\">self.addEventListener(&#39;fetch&#39;, (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    event.respondWith(</span><br><span class=\"line\">        caches.open(&#39;products-v2&#39;)</span><br><span class=\"line\">            .then (cache &#x3D;&gt; &#123;</span><br><span class=\"line\">                &#x2F;* Checking if the request is already present in the cache. If it is present, sending it directly to the client *&#x2F;</span><br><span class=\"line\">                return cache.match(event.request).then (response &#x3D;&gt; &#123;</span><br><span class=\"line\">                    if (response) &#123;</span><br><span class=\"line\">                        console.log(&#39;Cache hit! Fetching response from cache&#39;, event.request.url)</span><br><span class=\"line\">                        return response</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    &#x2F;* If the request is not present in the cache, we fetch it from the server and then put it in cache for subsequent requests. *&#x2F;</span><br><span class=\"line\">                    fetch(event.request).then (response &#x3D;&gt; &#123;</span><br><span class=\"line\">                        cache.put(event.request, response.clone())</span><br><span class=\"line\">                        return response</span><br><span class=\"line\">                    &#125;)</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>event.respondWith</code> lets the service worker send a customized response to the client.</p>\n<p>Offline-first is now a thing. For any non-critical request, we must serve the response from the cache, instead of making a ride to the server. If any asset is not present in the cache, we get it from the server and then cache it for subsequent requests.</p>\n<p>Service workers only work on HTTPS websites because they have the power to manipulate the response of any fetch request. Someone with malicious intent might tamper the response for a request on an HTTP website. So, hosting a PWA on HTTPS is mandatory. Service workers do not interrupt the normal functioning of the DOM. They cannot communicate directly with the web page. To send any message to a web page, it makes use of post messages.</p>\n<h3 id=\"Web-Push-Notifications\"><a href=\"#Web-Push-Notifications\" class=\"headerlink\" title=\"Web Push Notifications\"></a>Web Push Notifications</h3><p>Let’s suppose you’re busy playing a game on your mobile, and a notification pops up telling you of a 30% discount on your favorite brand. Without any further ado, you click on the notification and shop your breath out. Getting live updates on, say, a cricket or football match or getting important emails and reminders as notifications is a big deal when it comes to engaging users with a product. This feature was only available in native applications until PWA came along. A PWA makes use of web push notifications to compete with this powerful feature that native apps provide out of the box. A user would still receive a web push notification even if the PWA is not open in any of the browser tabs and even if the browser is not open.</p>\n<p>A web application has to ask permission of the user to send them push notifications.</p>\n<p>Once the user confirms by clicking the “Allow” button, a unique subscription token is generated by the browser. This token is unique for this device. The format of the subscription token generated by Chrome is as follows:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">     &quot;endpoint&quot;: &quot;https:&#x2F;&#x2F;fcm.googleapis.com&#x2F;fcm&#x2F;send&#x2F;c7Veb8VpyM0:APA91bGnMFx8GIxf__UVy6vJ-n9i728CUJSR1UHBPAKOCE_SrwgyP2N8jL4MBXf8NxIqW6NCCBg01u8c5fcY0kIZvxpDjSBA75sVz64OocQ-DisAWoW7PpTge3SwvQAx5zl_45aAXuvS&quot;,</span><br><span class=\"line\">     &quot;expirationTime&quot;: null,</span><br><span class=\"line\">     &quot;keys&quot;: &#123;</span><br><span class=\"line\">          &quot;p256dh&quot;: &quot;BJsj63kz8RPZe8Lv1uu-6VSzT12RjxtWyWCzfa18RZ0-8sc5j80pmSF1YXAj0HnnrkyIimRgLo8ohhkzNA7lX4w&quot;,</span><br><span class=\"line\">          &quot;auth&quot;: &quot;TJXqKozSJxcWvtQasEUZpQ&quot;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The <code>endpoint</code> contained in the token above will be unique for every subscription. On an average website, thousands of users would agree to receive push notifications, and for each of them, this <code>endpoint</code> would be unique. So, with the help of this <code>endpoint</code>, the application is able to target these users in the future by sending them push notifications. The <code>expirationTime</code> is the amount of time that the subscription is valid for a particular device. If the <code>expirationTime</code> is 20 days, it means that the push subscription of the user will expire after 20 days and the user won’t be able to receive push notifications on the older subscription. In this case, the browser will generate a new subscription token for that device. The <code>auth</code> and <code>p256dh</code> keys are used for encryption.</p>\n<p>Now, to send push notifications to these thousands of users in the future, we first have to save their respective subscription tokens. It’s the job of the application server (the back-end server, maybe a Node.js script) to send push notifications to these users. This might sound as simple as making a <code>POST</code> request to the endpoint URL with the notification data in the request payload. However, it should be noted that if a user is not online when a push notification intended for them is triggered by the server, they should still get that notification once they come back online. The server would have to take care of such scenarios, along with sending thousands of requests to the users. A server keeping track of the user’s connection sounds complicated. So, something in the middle would be responsible for routing web push notifications from the server to the client. This is called a push service, and every browser has its own implementation of a push service. The browser has to tell the following information to the push service in order to send any notification:</p>\n<ol>\n<li><p><strong>The time to live</strong><br>This is how long a message should be queued, in case it is not delivered to the user. Once this time has elapsed, the message will be removed from the queue.</p>\n</li>\n<li><p><strong>Urgency of the message</strong><br>This is so that the push service preserves the user’s battery by sending only high-priority messages.</p>\n</li>\n</ol>\n<p>The push service routes the messages to the client. Because push has to be received by the client even if its respective web application is not open in the browser, push events have to be listened to by something that continuously monitors in the background. You guessed it: That’s the job of the service worker. The service worker listens for push events and does the job of showing notifications to the user.</p>\n<p>So, now we know that the browser, push service, service worker and application server work in harmony to send push notifications to the user. Let’s look into the implementation details.</p>\n<h4 id=\"WEB-PUSH-CLIENT\"><a href=\"#WEB-PUSH-CLIENT\" class=\"headerlink\" title=\"WEB PUSH CLIENT\"></a>WEB PUSH CLIENT</h4><p>Asking permission of the user is a one-time thing. If a user has already granted permission to receive push notifications, we shouldn’t ask again. The permission value is saved in <code>Notification.permission</code>.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;* Notification.permission can have one of these three values: default, granted or denied. *&#x2F;</span><br><span class=\"line\">if (Notification.permission &#x3D;&#x3D;&#x3D; &#39;default&#39;) &#123;</span><br><span class=\"line\">    &#x2F;* The Notification.requestPermission() method shows a notification permission prompt to the user. It returns a promise that resolves to the value of permission*&#x2F;</span><br><span class=\"line\">    Notification.requestPermission().then (result &#x3D;&gt; &#123;</span><br><span class=\"line\">        if (result &#x3D;&#x3D;&#x3D; &#39;denied&#39;) &#123;</span><br><span class=\"line\">            console.log(&#39;Permission denied&#39;)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (result &#x3D;&#x3D;&#x3D; &#39;granted&#39;) &#123;</span><br><span class=\"line\">            console.log(&#39;Permission granted&#39;)</span><br><span class=\"line\">            &#x2F;* This means the user has clicked the Allow button. We’re to get the subscription token generated by the browser and store it in our database.</span><br><span class=\"line\"></span><br><span class=\"line\">            The subscription token can be fetched using the getSubscription method available on pushManager of the serviceWorkerRegistration object. If subscription is not available, we subscribe using the subscribe method available on pushManager. The subscribe method takes in an object.</span><br><span class=\"line\">            *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">            serviceWorkerRegistration.pushManager.getSubscription()</span><br><span class=\"line\">                .then (subscription &#x3D;&gt; &#123;</span><br><span class=\"line\">                    if (!subscription) &#123;</span><br><span class=\"line\">                        const applicationServerKey &#x3D; &#39;&#39;</span><br><span class=\"line\">                        serviceWorkerRegistration.pushManager.subscribe(&#123;</span><br><span class=\"line\">                            userVisibleOnly: true, &#x2F;&#x2F; All push notifications from server should be displayed to the user</span><br><span class=\"line\">                            applicationServerKey &#x2F;&#x2F; VAPID Public key</span><br><span class=\"line\">                        &#125;)</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        saveSubscriptionInDB(subscription, userId) &#x2F;&#x2F; A method to save subscription token in the database</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>In the <code>subscribe</code> method above, we’re passing <code>userVisibleOnly</code> and <code>applicationServerKey</code> to generate a subscription token. The <code>userVisibleOnly</code> property should always be true because it tells the browser that any push notification sent by the server will be shown to the client. To understand the purpose of <code>applicationServerKey</code>, let’s consider a scenario.</p>\n<p>If some person gets ahold of your thousands of subscription tokens, they could very well send notifications to the endpoints contained in these subscriptions. There is no way for the endpoint to be linked to your unique identity. To provide a unique identity to the subscription tokens generated on your web application, we make use of the VAPID protocol. With VAPID, the application server voluntarily identifies itself to the push service while sending push notifications. We generate two keys like so:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const webpush &#x3D; require(&#39;web-push&#39;)</span><br><span class=\"line\">const vapidKeys &#x3D; webpush.generateVAPIDKeys()</span><br></pre></td></tr></table></figure></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2ViLXB1c2g=\">web-push<i class=\"fa fa-external-link-alt\"></i></span> is an npm module. <code>vapidKeys</code> will have one public key and one private key. The application server key used above is the public key.</p>\n<h3 id=\"Web-Push-Server\"><a href=\"#Web-Push-Server\" class=\"headerlink\" title=\"Web Push Server\"></a>Web Push Server</h3><p>The job of the web push server (application server) is straightforward. It sends a notification payload to the subscription tokens.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const options &#x3D; &#123;</span><br><span class=\"line\">    TTL: 24*60*60, &#x2F;&#x2F;TTL is the time to live, the time that the notification will be queued in the push service</span><br><span class=\"line\">    vapidDetails: &#123;</span><br><span class=\"line\">        subject: &#39;email@example.com&#39;,</span><br><span class=\"line\">        publicKey: &#39;&#39;,</span><br><span class=\"line\">        privateKey: &#39;&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const data &#x3D; &#123;</span><br><span class=\"line\">    title: &#39;Update&#39;,</span><br><span class=\"line\">    body: &#39;Notification sent by the server&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">webpush.sendNotification(subscription, data, options)</span><br></pre></td></tr></table></figure></p>\n<p>It uses the <code>sendNotification</code> method from the web push library.</p>\n<h3 id=\"Service-Workers-1\"><a href=\"#Service-Workers-1\" class=\"headerlink\" title=\"Service Workers\"></a>Service Workers</h3><p>The service worker shows the notification to the user as such:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">self.addEventListener(&#39;push&#39;, (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    let options &#x3D; &#123;</span><br><span class=\"line\">        body: event.data.body,</span><br><span class=\"line\">        icon: &#39;images&#x2F;example.png&#39;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    event.waitUntil(</span><br><span class=\"line\">        &#x2F;* The showNotification method is available on the registration object of the service worker.</span><br><span class=\"line\">        The first parameter to showNotification method is the title of notification, and the second parameter is an object *&#x2F;</span><br><span class=\"line\">        self.registration.showNotification(event.data.title, options)</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Till now, we’ve seen how a service worker makes use of the cache to store requests and makes a PWA fast and reliable, and we’ve seen how web push notifications keep users engaged.</p>\n<p>To store a bunch of data on the client side for offline support, we need a giant data structure. Let’s look into the Financial Times PWA. You’ve got to witness the power of this data structure for yourself. Load the URL in your browser, and then switch off your internet connection. Reload the page. Gah! Is it still working? It is. (Like I said, offline is the new black.) Data is not coming from the wires. It is being served from the house. Head over to the “Applications” tab of Chrome Developer Tools. Under “Storage”, you’ll find “IndexedDB”.</p>\n<p>Check out the “Articles” object store, and expand any of the items to see the magic for yourself. The Financial Times has stored this data for offline support. This data structure that lets us store a massive amount of data is called IndexedDB. IndexedDB is a JavaScript-based object-oriented database for storing structured data. We can create different object stores in this database for various purposes. For example, as we can see in the image above that “Resources”, “ArticleImages” and “Articles” are called as object stores. Each record in an object store is uniquely identified with a key. IndexedDB can even be used to store files and blobs.</p>\n<p>Let’s try to understand IndexedDB by creating a database for storing books.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let openIdbRequest &#x3D; window.indexedDB.open(&#39;booksdb&#39;, 1)</span><br></pre></td></tr></table></figure><br>If the database <code>booksdb</code> doesn’t already exist, the code above will create a <code>booksdb</code> database. The second parameter to the open method is the version of the database. Specifying a version takes care of the schema-related changes that might happen in future. For example, booksdb now has only one table, but when the application grows, we intend to add two more tables to it. To make sure our database is in sync with the updated schema, we’ll specify a higher version than the previous one.</p>\n<p>Calling the <code>open</code> method doesn’t open the database right away. It’s an asynchronous request that returns an <code>IDBOpenDBRequest</code> object. This object has success and error properties; we’ll have to write appropriate handlers for these properties to manage the state of our connection.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let dbInstance</span><br><span class=\"line\">openIdbRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    dbInstance &#x3D; event.target.result</span><br><span class=\"line\">    console.log(&#39;booksdb is opened successfully&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">openIdbRequest.onerror &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(’There was an error in opening booksdb database&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">openIdbRequest.onupgradeneeded &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    let db &#x3D; event.target.result</span><br><span class=\"line\">    let objectstore &#x3D; db.createObjectStore(&#39;books&#39;, &#123; keyPath: &#39;id&#39; &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>To manage the creation or modification of object stores (object stores are analogous to SQL-based tables — they have a key-value structure), the <code>onupgradeneeded</code> method is called on the <code>openIdbRequest</code> object. The <code>onupgradeneeded</code> method will be invoked whenever the version changes. In the code snippet above, we’re creating a books object store with unique key as the ID.</p>\n<p>Let’s say that, after deploying this piece of code, we have to create one more object store, called as <code>users</code>. So, now the version of our database will be <code>2</code>.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let openIdbRequest &#x3D; window.indexedDB.open(&#39;booksdb&#39;, 2) &#x2F;&#x2F; New Version - 2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;* Success and error event handlers remain the same.</span><br><span class=\"line\">The onupgradeneeded method gets called when the version of the database changes. *&#x2F;</span><br><span class=\"line\">openIdbRequest.onupgradeneeded &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    let db &#x3D; event.target.result</span><br><span class=\"line\">    if (!db.objectStoreNames.contains(&#39;books&#39;)) &#123;</span><br><span class=\"line\">        let objectstore &#x3D; db.createObjectStore(&#39;books&#39;, &#123; keyPath: &#39;id&#39; &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    let oldVersion &#x3D; event.oldVersion</span><br><span class=\"line\">    let newVersion &#x3D; event.newVersion</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* The users tables should be added for version 2. If the existing version is 1, it will be upgraded to 2, and the users object store will be created. *&#x2F;</span><br><span class=\"line\">    if (oldVersion &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class=\"line\">        db.createObjectStore(&#39;users&#39;, &#123; keyPath: &#39;id&#39; &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>We’ve cached <code>dbInstance</code> in the success event handler of the open request. To retrieve or add data in IndexedDB, we’ll make use of <code>dbInstance</code>. Lets add some book records in our books object store.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let transaction &#x3D; dbInstance.transaction(&#39;books&#39;)</span><br><span class=\"line\">let objectstore &#x3D; dbInstance.objectstore(&#39;books&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">let bookRecord &#x3D; &#123;</span><br><span class=\"line\">    id: &#39;1&#39;,</span><br><span class=\"line\">    name: ’The Alchemist&#39;,</span><br><span class=\"line\">    author: &#39;Paulo Coelho&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let addBookRequest &#x3D; objectstore.add(bookRecord)</span><br><span class=\"line\"></span><br><span class=\"line\">addBookRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;Book record added successfully&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addBookRequest.onerror &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(’There was an error in adding book record&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>We make use of <code>transactions</code>, especially while writing records on object stores. A transaction is simply a wrapper around an operation to ensure data integrity. If any of the actions in a transaction fails, then no action is performed on the database.</p>\n<p>Let’s modify a book record with the <code>put</code> method:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let modifyBookRequest &#x3D; objectstore.put(bookRecord) &#x2F;&#x2F; put method takes in an object as the parameter</span><br><span class=\"line\">modifyBookRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;Book record updated successfully&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Let’s retrieve a book record with the <code>get</code> method:<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let transaction &#x3D; dbInstance.transaction(&#39;books&#39;)</span><br><span class=\"line\">let objectstore &#x3D; dbInstance.objectstore(&#39;books&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;* get method takes in the id of the record *&#x2F;</span><br><span class=\"line\">let getBookRequest &#x3D; objectstore.get(1)</span><br><span class=\"line\"></span><br><span class=\"line\">getBookRequest.onsuccess &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    &#x2F;* event.target.result contains the matched record *&#x2F;</span><br><span class=\"line\">    console.log(&#39;Book record&#39;, event.target.result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getBookRequest.onerror &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;Error while retrieving the book record.&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Adding-Icon-On-Home-Screen\"><a href=\"#Adding-Icon-On-Home-Screen\" class=\"headerlink\" title=\"Adding Icon On Home Screen\"></a>Adding Icon On Home Screen</h3><p>Now that there is hardly any distinction between a PWA and a native application, it makes sense to offer a prime position to the PWA. If your website fulfills the basic criteria of a PWA (hosted on HTTPS, integrates with service workers and has a <code>manifest.json</code>) and after the user has spent some time on the web page, the browser will invoke a prompt at the bottom, asking the user to add the app to their home screen, as shown below:</p>\n<p>When a user clicks on “Add FT to Home screen”, the PWA gets to set its foot on the home screen, as well as in the app drawer. When a user searches for any application on their phone, any PWAs that match the search query will be listed. They will also be seen in the system settings, which makes it easy for users to manage them. In this sense, a PWA behaves like a native application.</p>\n<p>PWAs make use of <code>manifest.json</code> to provide this feature. Let’s look into a simple <code>manifest.json</code> file.<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;name&quot;: &quot;Demo PWA&quot;,</span><br><span class=\"line\">     &quot;short_name&quot;: &quot;Demo&quot;,</span><br><span class=\"line\">     &quot;start_url&quot;: &quot;&#x2F;?standalone&quot;,</span><br><span class=\"line\">     &quot;background_color&quot;: &quot;#9F0C3F&quot;,</span><br><span class=\"line\">     &quot;theme_color&quot;: &quot;#fff1e0&quot;,</span><br><span class=\"line\">     &quot;display&quot;: &quot;standalone&quot;,</span><br><span class=\"line\">     &quot;icons&quot;: [&#123;</span><br><span class=\"line\">          &quot;src&quot;: &quot;&#x2F;lib&#x2F;img&#x2F;icons&#x2F;xxhdpi.png?v2&quot;,</span><br><span class=\"line\">          &quot;sizes&quot;: &quot;192x192&quot;</span><br><span class=\"line\">     &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>The <code>short_name</code> appears on the user’s home screen and in the system settings. The <code>name</code> appears in the chrome prompt and on the splash screen. The splash screen is what the user sees when the app is getting ready to launch. The <code>start_url</code> is the main screen of your app. It’s what users get when they tap an icon on the home screen. The <code>background_color</code> is used on the splash screen. The <code>theme_color</code> sets the color of the toolbar. The <code>standalone</code> value for <code>display</code> mode says that the app is to be operated in full-screen mode (hiding the browser’s toolbar). When a user installs a PWA, its size is merely in kilobytes, rather than the megabytes of native applications.</p>\n<p>Service workers, web push notifications, IndexedDB, and the home screen position make up for offline support, reliability, and engagement. It should be noted that a service worker doesn’t come to life and start doing its work on the very first load. The first load will still be slow until all of the static assets and other resources have been cached. We can implement some strategies to optimize the first load.</p>\n<h4 id=\"Bundling-Assets\"><a href=\"#Bundling-Assets\" class=\"headerlink\" title=\"Bundling Assets\"></a>Bundling Assets</h4><p>All of the resources, including the HTML, style sheets, images and JavaScript, are to be fetched from the server. The more files, the more HTTPS requests needed to fetch them. We can use bundlers like WebPack to bundle our static assets, hence reducing the number of HTTP requests to the server. WebPack does a great job of further optimizing the bundle by using techniques such as code-splitting (i.e. bundling only those files that are required for the current page load, instead of bundling all of them together) and tree shaking (i.e. removing duplicate dependencies or dependencies that are imported but not used in the code).</p>\n<h4 id=\"Reducing-Round-Trips\"><a href=\"#Reducing-Round-Trips\" class=\"headerlink\" title=\"Reducing Round Trips\"></a>Reducing Round Trips</h4><p>One of the main reasons for slowness on the web is network latency. The time it takes for a byte to travel from A to B varies with the network connection. For example, a particular round trip over Wi-Fi takes 50 milliseconds and 500 milliseconds on a 3G connection, but 2500 milliseconds on a 2G connection. These requests are sent using the HTTP protocol, which means that while a particular connection is being used for a request, it cannot be used for any other requests until the response of the previous request is served. A website can make six asynchronous HTTP requests at a time because six connections are available to a website to make HTTP requests. An average website makes roughly 100 requests; so, with a maximum of six connections available, a user might end up spending around 833 milliseconds in a single round trip. (The calculation is 833 milliseconds - 100⁄6 = 1666. We have to divide 1666 by 2 because we’re calculating the time spend on a round trip.) With HTTP2 in place, the turnaround time is drastically reduced. HTTP2 doesn’t block the connection head, so multiple requests can be sent simultaneously.</p>\n<p>Most HTTP responses contain <code>last-modified</code> and <code>etag</code> headers. The <code>last-modified</code> header is the date when the file was last modified, and an <code>etag</code> is a unique value based on the contents of the file. It will only be changed when the contents of a file are changed. Both of these headers can be used to avoid downloading the file again if a cached version is already locally available. If the browser has a version of this file locally available, it can add any of these two headers in the request as such:</p>\n<p>The server can check whether the contents of the file have changed. If the contents of the file have not changed, then it responds with a status code of 304 (<em>not modified</em>).</p>\n<p>This indicates to the browser to use the locally available cached version of the file. By doing all of this, we’ve prevented the file from being downloaded.</p>\n<p>Faster responses are in now place, but our job is not done yet. We still have to parse the HTML, load the style sheets and make the web page interactive. It makes sense to show some empty boxes with a loader to the user, instead of a blank screen. While the HTML document is getting parsed, when it comes across <code>&lt;script src=&#39;asset.js&#39;&gt;&lt;/script&gt;</code>, it will make a synchronous HTTP request to the server to fetch asset.js, and the whole parsing process will be paused until the response comes back. Imagine having a dozen of synchronous static asset references. These could very well be managed just by making use of the async keyword in script references, like <code>&lt;script src=&#39;asset.js&#39; async&gt;&lt;/script&gt;</code>. With the introduction of the async keyword here, the browser will make an asynchronous request to fetch asset.js without hindering the parsing of the HTML. If a script file is required at a later stage, we can defer the downloading of that file until the entire HTML has been parsed. A script file can be deferred by using the <code>defer</code> keyword, like <code>&lt;script src=&#39;asset.js&#39; defer&gt;&lt;/script&gt;</code>.</p>\n<h3 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h3><p>We’ve learned a lot of many new things that make for a cool web application. Here’s a summary of all of the things we’ve explored in this article:</p>\n<ol>\n<li><p>Service workers make good use of the cache to speed up the loading of assets.</p>\n</li>\n<li><p>Web push notifications work under the hood.</p>\n</li>\n<li><p>We use IndexedDB to store a massive amount of data.</p>\n</li>\n<li><p>Some of the optimizations for instant first load, like using HTTP2 and adding headers like <code>Etag</code>, <code>last-modified</code> and <code>If-None-Match</code>, prevent the downloading of valid cached assets.</p>\n</li>\n</ol>\n<p>That’s all, folks!</p>\n","categories":["javascript"],"tags":["note","javascript","pwa"]},{"title":"HTTP协议总结","url":"/2018/05/13/frontend/http-protocal-summary/","content":"<p>HTTP协议是web开发中每天都要接触到的协议，内容众多。本文做个总结，以作理解查询。如果需要技术细节请查询相关技术手册。<br><a id=\"more\"></a></p>\n<h2 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h2><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>\n<p>HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>\n<p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>\n<p>HTTP是一个<strong>应用层协议</strong>，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个<strong>无状态的协议</strong>。</p>\n<p><strong>在Internet中所有的传输都是通过TCP/IP进行的。</strong>HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：</p>\n<p><img data-src=\"/images/http-protocal-summary/1.jpg\" alt=\"\"></p>\n<p>HTTP默认的端口号为80，HTTPS的端口号为443。</p>\n<p>浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。</p>\n<h2 id=\"二、简史\"><a href=\"#二、简史\" class=\"headerlink\" title=\"二、简史\"></a>二、简史</h2><p>它的发展是万维网协会（World Wide Web Consortium）和Internet工作小组IETF（Internet Engineering Task Force）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p>\n<h2 id=\"三、特点\"><a href=\"#三、特点\" class=\"headerlink\" title=\"三、特点\"></a>三、特点</h2><p>HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。</p>\n<p>HTTP协议的主要特点可概括如下：</p>\n<ol>\n<li><strong>支持客户/服务器模式</strong>：支持基本认证和安全认证。</li>\n<li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>\n<li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>\n<li><strong>HTTP 0.9和1.0使用非持续连接</strong>：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。<strong>HTTP 1.1使用持续连接</strong>：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。</li>\n<li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</li>\n</ol>\n<h3 id=\"无状态协议\"><a href=\"#无状态协议\" class=\"headerlink\" title=\"无状态协议\"></a>无状态协议</h3><p>协议的状态是指下一次传输可以“记住”这次传输信息的能力。</p>\n<p>http是不会为了下一次连接而维护这次连接所传输的信息,为了保证服务器内存。<br>比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。</p>\n<p>由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议（Stateless Protocol）。</p>\n<h3 id=\"HTTP协议是无状态的和Connection-keep-alive的区别\"><a href=\"#HTTP协议是无状态的和Connection-keep-alive的区别\" class=\"headerlink\" title=\"HTTP协议是无状态的和Connection: keep-alive的区别\"></a>HTTP协议是无状态的和<code>Connection: keep-alive</code>的区别</h3><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p>\n<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。</p>\n<p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。<br>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p>\n<h2 id=\"四、工作流程\"><a href=\"#四、工作流程\" class=\"headerlink\" title=\"四、工作流程\"></a>四、工作流程</h2><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p>\n<ol>\n<li>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</li>\n<li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li>\n<li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li>\n<li>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</li>\n</ol>\n<p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p>\n<p><img data-src=\"/images/http-protocal-summary/2.jpg\" alt=\"\"></p>\n<p>HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。下图所示TCP连接的三次握手。</p>\n<p>在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。</p>\n<p><img data-src=\"/images/http-protocal-summary/3.jpg\" alt=\"\"></p>\n<h2 id=\"五、头域-header\"><a href=\"#五、头域-header\" class=\"headerlink\" title=\"五、头域(header)\"></a>五、头域(header)</h2><p>每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p>\n<h3 id=\"请求信息\"><a href=\"#请求信息\" class=\"headerlink\" title=\"请求信息\"></a>请求信息</h3><p>发出的请求信息格式如下：</p>\n<ul>\n<li>请求行，例如GET /images/logo.gif HTTP/1.1，表示从/images目录下请求logo.gif这个文件。</li>\n<li>（请求）头，例如Accept-Language: en</li>\n<li>空行</li>\n<li>可选的消息体：请求行和标题必须以<CR><LF>作为结尾（也就是，回车然后换行）。空行内必须只有<CR><LF>而无其他空格。在HTTP/1.1协议中，所有的请求头，除post外，都是可选的。</li>\n</ul>\n<p><img data-src=\"/images/http-protocal-summary/4.jpg\" alt=\"\"></p>\n<p>三个部分分别是：请求行、消息报头、请求正文。</p>\n<h4 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h4><p>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：</p>\n<ul>\n<li>OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送&#39;*&#39;的请求来测试服务器的功能性。</li>\n<li>HEAD - 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。</li>\n<li>GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</li>\n<li>POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>\n<li>PUT - 向指定资源位置上传其最新内容。</li>\n<li>DELETE - 请求服务器删除Request-URI所标识的资源。</li>\n<li>TRACE - 回显服务器收到的请求，主要用于测试或诊断。</li>\n<li>CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li>\n<li>PATCH - 用来将局部修改应用于某一资源，添加于规范RFC5789。</li>\n</ul>\n<p>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</p>\n<p>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。</p>\n<h4 id=\"GET和POST的区别：\"><a href=\"#GET和POST的区别：\" class=\"headerlink\" title=\"GET和POST的区别：\"></a>GET和POST的区别：</h4><ol>\n<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。</li>\n<li>GET提交的数据大小有限制，<strong>最多只能有1024字节</strong>（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li>\n<li>GET方式需要使用<code>Request.QueryString</code>来取得变量的值，而POST方式通过<code>Request.Form</code>来获取变量的值。</li>\n<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li>\n</ol>\n<h3 id=\"响应消息\"><a href=\"#响应消息\" class=\"headerlink\" title=\"响应消息\"></a>响应消息</h3><p>客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误编码、服务器信息、实体元信息以及必要的实体内容。根据响应类别的类别，服务器响应里可以含实体内容，但不是所有的响应都有实体内容。</p>\n<p>响应头第一行也称为状态行，格式如下（下图中红线标出的那行）：</p>\n<p>HTTP-Version 空格 Status-Code 空格 Reason-Phrase CRLF</p>\n<p>HTTP-Version表示HTTP版本，例如为HTTP/1.1。Status-Code是结果代码，用三个数字表示。Reason-Phrase是个简单的文本描述，解释Status-Code的具体原因。Status-Code用于机器自动识别，Reason-Phrase用于人工理解。Status-Code的第一个数字代表响应类别，可能取5个不同的值。后两个数字没有分类作用。Status-Code的第一个数字代表响应的类别，后续两位描述在该类响应下发生的具体状况，具体请参见：HTTP状态码。</p>\n<p><img data-src=\"/images/http-protocal-summary/5.jpg\" alt=\"\"></p>\n<p>响应消息的结构：</p>\n<p><img data-src=\"/images/http-protocal-summary/6.jpg\" alt=\"\"></p>\n<p>三个部分分别是：状态行、消息报头、响应正文。</p>\n<p>无论你何时浏览一个网页，你的电脑都会通过一个使用HTTP协议的服务器来获取所请求的数据。在你请求的网页显示在浏览器之前，支配网页的网站服务器会返回一个包含有状态码的HTTP头文件。这个状态码提供了有关所请求网页的相关条件信息。如果一切正常，一个标准网页会收到一条诸如200的状态码。当然我们的目的不是去研究200响应码，而是去探讨那些代表出现错误信息的服务器头文件响应码，例如表示“未找到指定网页”的404码。</p>\n<h4 id=\"响应头域\"><a href=\"#响应头域\" class=\"headerlink\" title=\"响应头域\"></a>响应头域</h4><p>服务器需要传递许多附加信息，这些信息不能全放在状态行里。因此，需要另行定义响应头域，用来描述这些附加信息。响应头域主要描述服务器的信息和Request-URI的信息。</p>\n<h3 id=\"HTTP常见的请求头\"><a href=\"#HTTP常见的请求头\" class=\"headerlink\" title=\"HTTP常见的请求头\"></a>HTTP常见的请求头</h3><p>在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的</p>\n<p><strong>If-Modified-Since</strong>：把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</p>\n<p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT</p>\n<p><strong>If-None-Match</strong>：If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能。</p>\n<p>例如: If-None-Match: &quot;03f2b33c0bfcc1:0&quot;。</p>\n<p><strong>Pragma</strong>：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；在HTTP/1.1版本中，它和<code>Cache-Control:no-cache</code>作用一模一样。</p>\n<p>Pargma只有一个用法， 例如： <code>Pragma: no-cache</code></p>\n<blockquote>\n<p>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p>\n</blockquote>\n<p><strong>Cache-Control</strong>：指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（在请求消息或响应消息中设置<code>Cache-Control</code>并不会修改另一个消息处理过程中的缓存处理过程）。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage。</p>\n<ul>\n<li>Cache-Control:Public 可以被任何缓存所缓存</li>\n<li>Cache-Control:Private 内容只缓存到私有缓存中</li>\n<li>Cache-Control:no-cache 所有内容都不会被缓存</li>\n<li>Cache-Control:no-store 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>\n<li>Cache-Control:max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>\n<li>Cache-Control:min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>\n<li>Cache-Control:max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>\n</ul>\n<p><strong>Accept</strong>：浏览器端可以接受的MIME类型。例如：<code>Accept: text/html</code> 代表浏览器可以接受服务器回发的类型为 <code>text/html</code> 也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。通配符 <em> 代表任意类型，例如 `Accept: </em>/*` 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)。</p>\n<p><strong>Accept-Encoding</strong>：浏览器申明自己可接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）;Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。例如： <code>Accept-Encoding: gzip, deflate</code>。如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可以接受。</p>\n<p><strong>Accept-Language</strong>：浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；例如：<code>Accept-Language: en-us</code>。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</p>\n<p><strong>Accept-Charset</strong>：浏览器可接受的字符集。如果在请求消息中没有设置这个域，缺省表示任何字符集都可以接受。</p>\n<p><strong>User-Agent</strong>：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本。<br>例如： <code>User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</code>。</p>\n<p><strong>Content-Type</strong>：例如：Content-Type: <code>application/x-www-form-urlencoded</code>。</p>\n<p><strong>Referer</strong>：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。<br>例如: <code>Referer:http://translate.google.cn/?hl=zh-cn&amp;tab=wT</code></p>\n<p><strong>Connection</strong>：<br>例如：<code>Connection: keep-alive</code> 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。HTTP 1.1默认进行持久连接。利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。<br><code>Connection: close</code> 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接。</p>\n<p><strong>Host</strong>：（发送请求时，该头域是必需的）主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。<br>例如: 我们在浏览器中输入：<code>http://www.guet.edu.cn/index.html</code>，浏览器发送的请求消息中，就会包含Host请求头域：Host：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ndWV0LmVkdS5jbu+8jOatpOWkhOS9v+eUqOe8uuecgeerr+WPo+WPtzgw77yM6Iul5oyH5a6a5LqG56uv5Y+j5Y+377yM5YiZ5Y+Y5oiQ77yaSG9zdO+8muaMh+Wumuerr+WPo+WPt+OAgg==\">http://www.guet.edu.cn，此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号。<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><code>Cookie</code>：最重要的请求头之一, 将cookie的值发送给HTTP服务器。</p>\n<p><code>Content-Length</code>：表示请求消息正文的长度。例如：Content-Length: 38。</p>\n<p><code>Authorization</code>：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含<code>Authorization</code>请求报头域的请求，要求服务器对其进行验证。<br>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p>\n<p><code>From</code>：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</p>\n<p><code>Range</code>：可以请求实体的一个或者多个子范围。例如，</p>\n<ul>\n<li>表示头500个字节：bytes=0-499</li>\n<li>表示第二个500字节：bytes=500-999</li>\n<li>表示最后500个字节：bytes=-500</li>\n<li>表示500字节以后的范围：bytes=500-</li>\n<li>第一个和最后一个字节：bytes=0-0,-1</li>\n<li>同时指定几个范围：bytes=500-600,601-999</li>\n</ul>\n<p>但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200（OK）。</p>\n<h3 id=\"HTTP常见的响应头\"><a href=\"#HTTP常见的响应头\" class=\"headerlink\" title=\"HTTP常见的响应头\"></a>HTTP常见的响应头</h3><p><strong>Allow</strong>：服务器支持哪些请求方法（如GET、POST等）。</p>\n<p><strong>Date</strong>：表示消息发送的时间，时间的描述格式由rfc822定义。例如，<code>Date:Mon,31Dec200104:25:57GMT</code>。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦</p>\n<p><strong>Expires</strong>：指明应该在什么时候认为文档已经过期，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。HTTP1.1的客户端和缓存会将非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以将Expires实体报头域，设置为0。<br>例如: <code>Expires: Tue, 08 Feb 2022 11:35:14 GMT</code></p>\n<p><strong>P3P</strong>：用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题<br>例如: <code>P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</code></p>\n<p><strong>Set-Cookie</strong>：非常重要的header, 用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie。<br>例如: <code>Set-Cookie: sc=4c31523a; path=/; domain=.http://acookie.taobao.com</code></p>\n<p><strong>ETag</strong>：和If-None-Match 配合使用。</p>\n<p><strong>Last-Modified</strong>：用于指示资源的最后修改日期和时间。Last-Modified也可用setDateHeader方法来设置。</p>\n<p><strong>Content-Type</strong>：WEB服务器告诉浏览器自己响应的对象的类型和字符集。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。可在web.xml文件中配置扩展名和MIME类型的对应关系。<br>例如:<br><code>Content-Type: text/html;charset=utf-8</code>,<br><code>Content-Type:text/html;charset=GB2312</code>,<br><code>Content-Type: image/jpeg</code><br>媒体类型的格式为：大类/小类，比如text/html。</p>\n<p>IANA(The Internet Assigned Numbers Authority，互联网数字分配机构)定义了8个大类的媒体类型，分别是:</p>\n<ul>\n<li>application— (比如: application/vnd.ms-excel.)</li>\n<li>audio (比如: audio/mpeg.)</li>\n<li>image (比如: image/png.)</li>\n<li>message (比如,:message/http.)</li>\n<li>model(比如:model/vrml.)</li>\n<li>multipart (比如:multipart/form-data.)</li>\n<li>text(比如:text/html.)</li>\n<li>video(比如:video/quicktime.)</li>\n</ul>\n<p><strong>Content-Range</strong>：用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：<code>Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-length</code>。</p>\n<p>例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响 应或对一系列范围的重叠请求），Content-Range表示传送的范围。</p>\n<p><strong>Content-Length</strong>：指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，<code>Content-Length</code>的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入<code>Content-Length</code>头，最后通过<code>byteArrayStream.writeTo(response.getOutputStream()</code>发送内容。<br>例如: <code>Content-Length: 19847</code></p>\n<p><strong>Content-Encoding</strong>：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。只有在解码之后才可以得到<code>Content-Type</code>头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看<code>Accept-Encoding</code>头（即<code>request.getHeader(&quot;Accept-Encoding&quot;)</code>）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。<br>例如：<code>Content-Encoding：gzip</code></p>\n<p><strong>Content-Language</strong>：WEB服务器告诉浏览器自己响应的对象所用的自然语言。例如： <code>Content-Language:da</code>。没有设置该域则认为实体内容将提供给所有的语言阅读。</p>\n<p><strong>Server</strong>：指明HTTP服务器用来处理请求的软件信息。例如：<code>Server: Microsoft-IIS/7.5</code>、<code>Server：Apache-Coyote/1.1</code>。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。</p>\n<p><strong>X-AspNet-Version</strong>：如果网站是用<span class=\"exturl\" data-url=\"aHR0cDovL0FTUC5ORVTlvIDlj5HnmoTvvIzov5nkuKpoZWFkZXLnlKjmnaXooajnpLpodHRwOi8vQVNQLk5FVOeahOeJiOacrOOAgg==\">http://ASP.NET开发的，这个header用来表示http://ASP.NET的版本。<i class=\"fa fa-external-link-alt\"></i></span><br>例如: <code>X-AspNet-Version: 4.0.30319</code></p>\n<p><strong>X-Powered-By</strong>：表示网站是用什么技术开发的。<br>例如： <code>X-Powered-By: http://ASP.NET</code></p>\n<p><strong>Connection</strong>：例如：<code>Connection: keep-alive</code> 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p>\n<p><strong>Connection</strong>: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接。</p>\n<p><strong>Location</strong>：用于重定向一个新的位置，包含新的URL地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过<code>HttpServletResponse</code>的<code>sendRedirect</code>方法，该方法同时设置状态代码为302。Location响应报头域常用在更换域名的时候。</p>\n<p><strong>Refresh</strong>：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过<code>setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)</code>让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的<code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;</code>实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是<code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; ...&gt;</code>。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</p>\n<p><strong>WWW-Authenticate</strong>：该响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。</p>\n<h2 id=\"六、解决HTTP无状态的问题\"><a href=\"#六、解决HTTP无状态的问题\" class=\"headerlink\" title=\"六、解决HTTP无状态的问题\"></a>六、解决HTTP无状态的问题</h2><h3 id=\"通过Cookies保存状态信息\"><a href=\"#通过Cookies保存状态信息\" class=\"headerlink\" title=\"通过Cookies保存状态信息\"></a>通过Cookies保存状态信息</h3><p>通过Cookies，服务器就可以清楚的知道请求2和请求1来自同一个客户端。</p>\n<h3 id=\"通过Session保存状态信息\"><a href=\"#通过Session保存状态信息\" class=\"headerlink\" title=\"通过Session保存状态信息\"></a>通过Session保存状态信息</h3><p>Session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。</p>\n<p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为 session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个 session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p>\n<h4 id=\"Session的实现方式：\"><a href=\"#Session的实现方式：\" class=\"headerlink\" title=\"Session的实现方式：\"></a>Session的实现方式：</h4><ol>\n<li>使用Cookie来实现。服务器给每个Session分配一个唯一的<code>JSESSIONID</code>，并通过Cookie发送给客户端。<br>当客户端发起新的请求的时候，将在Cookie头中携带这个<code>JSESSIONID</code>。这样服务器能够找到这个客户端对应的<code>Session</code>。</li>\n</ol>\n<p><img data-src=\"/images/http-protocal-summary/7.jpg\" alt=\"\"></p>\n<ol>\n<li>使用URL回写来实现。URL回写是指服务器在发送给浏览器页面的所有链接中都携带JSESSIONID的参数，这样客户端点击任何一个链接都会把JSESSIONID带会服务器。如果直接在浏览器输入服务端资源的url来请求该资源，那么Session是匹配不到的。<br>Tomcat对Session的实现，是一开始同时使用Cookie和URL回写机制，如果发现客户端支持Cookie，就继续使用Cookie，停止使用URL回写。如果发现Cookie被禁用，就一直使用URL回写。jsp开发处理到Session的时候，对页面中的链接记得使用<code>response.encodeURL()</code>。</li>\n</ol>\n<p>Cookie和Session有以下明显的不同点：</p>\n<ol>\n<li>Cookie将状态保存在客户端，Session将状态保存在服务器端；</li>\n<li>Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；</li>\n<li>Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；</li>\n<li>就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些。因为它不会任意读取客户存储的信息。</li>\n</ol>\n<h4 id=\"通过表单变量保持状态\"><a href=\"#通过表单变量保持状态\" class=\"headerlink\" title=\"通过表单变量保持状态\"></a>通过表单变量保持状态</h4><p>除了Cookies之外，还可以使用表单变量来保持状态，比如<span class=\"exturl\" data-url=\"aHR0cDovL0FzcC5uZXTlsLHpgJrov4fkuIDkuKrlj6tWaWV3U3RhdGXnmoRJbnB1dD3igJxoaWRkZW7igJ3nmoTmoYbmnaXkv53mjIHnirbmgIEs5q+U5aaC\">http://Asp.net就通过一个叫ViewState的Input=“hidden”的框来保持状态,比如<i class=\"fa fa-external-link-alt\"></i></span>:<br><code>&lt;input type=&quot;hidden&quot; name=&quot;__VIEWSTATE&quot; id=&quot;__VIEWSTATE&quot; value=&quot;/wEPDwUKMjA0OTM4MTAwNGRkXUfhlDv1Cs7/qhBlyZROCzlvf5U=&quot; /&gt;</code>这个原理和Cookies大同小异，只是每次请求和响应所附带的信息变成了表单变量。</p>\n<h4 id=\"通过QueryString保持状态\"><a href=\"#通过QueryString保持状态\" class=\"headerlink\" title=\"通过QueryString保持状态\"></a>通过QueryString保持状态</h4><p>QueryString通过将信息保存在所请求地址的末尾来向服务器传送信息，通常和表单结合使用。</p>\n<h2 id=\"七、缓存的实现原理\"><a href=\"#七、缓存的实现原理\" class=\"headerlink\" title=\"七、缓存的实现原理\"></a>七、缓存的实现原理</h2><p>WEB缓存(cache)位于Web服务器和客户端之间。</p>\n<p>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p>\n<p>HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。</p>\n<h3 id=\"缓存的优点\"><a href=\"#缓存的优点\" class=\"headerlink\" title=\"缓存的优点\"></a>缓存的优点</h3><p>减少相应延迟：因为请求从缓存服务器（离客户端更近）而不是源服务器被相应，这个过程耗时更少，让web服务器看上去相应更快。</p>\n<p>减少网络带宽消耗：当副本被重用时会减低客户端的带宽消耗；客户可以节省带宽费用，控制带宽的需求的增长并更易于管理。</p>\n<h3 id=\"客户端缓存生效的常见流程\"><a href=\"#客户端缓存生效的常见流程\" class=\"headerlink\" title=\"客户端缓存生效的常见流程\"></a>客户端缓存生效的常见流程</h3><p>服务器收到请求时，会在200OK中回送该资源的<code>Last-Modified</code>和<code>ETag</code>头，客户端将该资源保存在cache中，并记录这两个属性。当客户端需要发送相同的请求时，会在请求中携带<code>If-Modified-Since</code>和<code>If-None-Match</code>两个头。两个头的值分别是响应中<code>Last-Modified</code>和<code>ETag</code>头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。</p>\n<h3 id=\"Web缓存机制\"><a href=\"#Web缓存机制\" class=\"headerlink\" title=\"Web缓存机制\"></a>Web缓存机制</h3><p>HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来为此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来为此目的。</p>\n<p>HTTP定义了3种缓存机制：</p>\n<ol>\n<li>Freshness：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间；</li>\n<li>Validation：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个Last-Modified回应头，缓存能够使用If-Modified-Since来判断是否已改变，以便判断根据情况发送请求；</li>\n<li>Invalidation：在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。</li>\n</ol>\n<h2 id=\"八、HTTP应用\"><a href=\"#八、HTTP应用\" class=\"headerlink\" title=\"八、HTTP应用\"></a>八、HTTP应用</h2><h3 id=\"断点续传的实现原理\"><a href=\"#断点续传的实现原理\" class=\"headerlink\" title=\"断点续传的实现原理\"></a>断点续传的实现原理</h3><p>HTTP协议的GET方法，支持只请求某个资源的某一部分；</p>\n<ul>\n<li><code>206 Partial Content</code> 部分内容响应；</li>\n<li><code>Range</code> 请求的资源范围；</li>\n<li><code>Content-Range</code> 响应的资源范围；</li>\n</ul>\n<p>在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。</p>\n<p>分块请求资源实例：</p>\n<ul>\n<li><code>Range: bytes=306302-</code> ：请求这个资源从306302个字节到末尾的部分；</li>\n<li><code>Content-Range: bytes 306302-604047/604048</code>：响应中指示携带的是该资源的第306302-604047的字节，该资源共604048个字节；</li>\n</ul>\n<p>客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的FlashGet和迅雷基本都是这个原理。</p>\n<h3 id=\"多线程下载的原理\"><a href=\"#多线程下载的原理\" class=\"headerlink\" title=\"多线程下载的原理\"></a>多线程下载的原理</h3><ul>\n<li>下载工具开启多个发出HTTP请求的线程；</li>\n<li>每个http请求只请求资源文件的一部分：<code>Content-Range: bytes 20000-40000/47000</code>；</li>\n<li>合并每个线程下载的文件。</li>\n</ul>\n<h3 id=\"http代理\"><a href=\"#http代理\" class=\"headerlink\" title=\"http代理\"></a>http代理</h3><h4 id=\"http代理服务器\"><a href=\"#http代理服务器\" class=\"headerlink\" title=\"http代理服务器\"></a>http代理服务器</h4><p>代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。</p>\n<p>代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。<br>而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。更重要的是：Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。</p>\n<p>http代理服务器的主要功能：</p>\n<ol>\n<li>突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站；</li>\n<li>访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类FTP下载上传，以及各类资料查询共享等服务；</li>\n<li>突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试；</li>\n<li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度；</li>\n<li>隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。对于客户端浏览器而言，http代理服务器相当于服务器。而对于Web服务器而言，http代理服务器又担当了客户端的角色。</li>\n</ol>\n<h3 id=\"虚拟主机\"><a href=\"#虚拟主机\" class=\"headerlink\" title=\"虚拟主机\"></a>虚拟主机</h3><p>所谓虚拟主机，也叫“网站空间”就是把一台运行在互联网上的服务器划分成多个“虚拟”的服务器，每一个虚拟主机都具有独立的域名和完整的Internet服务器（支持WWW、FTP、E-mail等）功能。一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。</p>\n<h4 id=\"虚拟主机的实现原理\"><a href=\"#虚拟主机的实现原理\" class=\"headerlink\" title=\"虚拟主机的实现原理\"></a>虚拟主机的实现原理</h4><p>虚拟主机是用同一个WEB服务器，为不同域名网站提供服务的技术。Apache、Tomcat等均可通过配置实现这个功能。相关的HTTP消息头：Host。例如：Host: <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb23jgILlrqLmiLfnq6/lj5HpgIFIVFRQ6K+35rGC55qE5pe25YCZ77yM5Lya5pC65bimSG9zdOWktO+8jEhvc3TlpLTorrDlvZXnmoTmmK/lrqLmiLfnq6/ovpPlhaXnmoTln5/lkI3jgILov5nmoLfmnI3liqHlmajlj6/ku6XmoLnmja5Ib3N05aS056Gu6K6k5a6i5oi36KaB6K6/6Zeu55qE5piv5ZOq5LiA5Liq5Z+f5ZCN44CC\">http://www.baidu.com。客户端发送HTTP请求的时候，会携带Host头，Host头记录的是客户端输入的域名。这样服务器可以根据Host头确认客户要访问的是哪一个域名。<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"HTTPS传输协议原理\"><a href=\"#HTTPS传输协议原理\" class=\"headerlink\" title=\"HTTPS传输协议原理\"></a>HTTPS传输协议原理</h2><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。</p>\n<h3 id=\"两种基本的加解密算法类型\"><a href=\"#两种基本的加解密算法类型\" class=\"headerlink\" title=\"两种基本的加解密算法类型\"></a>两种基本的加解密算法类型</h3><ul>\n<li><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。</p>\n</li>\n<li><p>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p>\n</li>\n</ul>\n<h3 id=\"HTTPS通信过程\"><a href=\"#HTTPS通信过程\" class=\"headerlink\" title=\"HTTPS通信过程\"></a>HTTPS通信过程</h3><p><img data-src=\"/images/http-protocal-summary/8.jpg\" alt=\"\"></p>\n<h3 id=\"HTTPS通信的优点\"><a href=\"#HTTPS通信的优点\" class=\"headerlink\" title=\"HTTPS通信的优点\"></a>HTTPS通信的优点</h3><ul>\n<li>客户端产生的密钥只有客户端和服务器端能得到；</li>\n<li>加密的数据只有客户端和服务器端才能得到明文；</li>\n<li>客户端到服务端的通信是安全的。</li>\n</ul>\n<h2 id=\"http的状态响应码\"><a href=\"#http的状态响应码\" class=\"headerlink\" title=\"http的状态响应码\"></a>http的状态响应码</h2><ul>\n<li>1**(信息类)：表示接收到请求并且继续处理<ul>\n<li>100——客户必须继续发出请求</li>\n<li>101——客户要求服务器根据请求转换HTTP协议版本</li>\n</ul>\n</li>\n<li>2**(响应成功)：表示动作被成功接收、理解和接受<ul>\n<li>200——表明该请求被成功地完成，所请求的资源发送回客户端</li>\n<li>201——提示知道新文件的URL</li>\n<li>202——接受和处理、但处理未完成</li>\n<li>203——返回信息不确定或不完整</li>\n<li>204——请求收到，但返回信息为空</li>\n<li>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</li>\n<li>206——服务器已经完成了部分用户的GET请求</li>\n</ul>\n</li>\n<li>3**(重定向类)：为了完成指定的动作，必须接受进一步处理<ul>\n<li>300——请求的资源可在多处得到</li>\n<li>301——本网页被永久性转移到另一个URL</li>\n<li>302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</li>\n<li>303——建议客户访问其他URL或访问方式</li>\n<li>304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</li>\n<li>305——请求的资源必须从服务器指定的地址得到</li>\n<li>306——前一版本HTTP中使用的代码，现行版本中不再使用</li>\n<li>307——申明请求的资源临时性删除</li>\n</ul>\n</li>\n<li>4**(客户端错误类)：请求包含错误语法或不能正确执行<ul>\n<li>400——客户端请求有语法错误，不能被服务器所理解</li>\n<li>401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<ul>\n<li>HTTP 401.1 - 未授权：登录失败</li>\n<li>HTTP 401.2 - 未授权：服务器配置问题导致登录失败</li>\n<li>HTTP 401.3 - ACL 禁止访问资源</li>\n<li>HTTP 401.4 - 未授权：授权被筛选器拒绝</li>\n<li>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败</li>\n</ul>\n</li>\n<li>402——保留有效ChargeTo头响应</li>\n<li>403——禁止访问，服务器收到请求，但是拒绝提供服务<ul>\n<li>HTTP 403.1 禁止访问：禁止可执行访问</li>\n<li>HTTP 403.2 - 禁止访问：禁止读访问</li>\n<li>HTTP 403.3 - 禁止访问：禁止写访问</li>\n<li>HTTP 403.4 - 禁止访问：要求 SSL</li>\n<li>HTTP 403.5 - 禁止访问：要求 SSL 128</li>\n<li>HTTP 403.6 - 禁止访问：IP 地址被拒绝</li>\n<li>HTTP 403.7 - 禁止访问：要求客户证书</li>\n<li>HTTP 403.8 - 禁止访问：禁止站点访问</li>\n<li>HTTP 403.9 - 禁止访问：连接的用户过多</li>\n<li>HTTP 403.10 - 禁止访问：配置无效</li>\n<li>HTTP 403.11 - 禁止访问：密码更改</li>\n<li>HTTP 403.12 - 禁止访问：映射器拒绝访问</li>\n<li>HTTP 403.13 - 禁止访问：客户证书已被吊销</li>\n<li>HTTP 403.15 - 禁止访问：客户访问许可过多</li>\n<li>HTTP 403.16 - 禁止访问：客户证书不可信或者无效</li>\n<li>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</li>\n</ul>\n</li>\n<li>404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</li>\n<li>405——用户在Request-Line字段定义的方法不允许</li>\n<li>406——根据用户发送的Accept拖，请求资源不可访问</li>\n<li>407——类似401，用户必须首先在代理服务器上得到授权</li>\n<li>408——客户端没有在用户指定的饿时间内完成请求</li>\n<li>409——对当前资源状态，请求不能完成</li>\n<li>410——服务器上不再有此资源且无进一步的参考地址</li>\n<li>411——服务器拒绝用户定义的Content-Length属性请求</li>\n<li>412——一个或多个请求头字段在当前请求中错误</li>\n<li>413——请求的资源大于服务器允许的大小</li>\n<li>414——请求的资源URL长于服务器允许的长度</li>\n<li>415——请求资源不支持请求项目格式</li>\n<li>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</li>\n<li>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</li>\n</ul>\n</li>\n<li>5**(服务端错误类)：服务器不能正确执行一个正确的请求<ul>\n<li>HTTP 500 - 服务器遇到错误，无法完成请求</li>\n<li>HTTP 500.100 - 内部服务器错误 - ASP 错误</li>\n<li>HTTP 500-11 服务器关闭</li>\n<li>HTTP 500-12 应用程序重新启动</li>\n<li>HTTP 500-13 - 服务器太忙</li>\n<li>HTTP 500-14 - 应用程序无效</li>\n<li>HTTP 500-15 - 不允许请求 global.asa</li>\n<li>Error 501 - 未实现</li>\n<li>HTTP 502 - 网关错误</li>\n<li>HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</li>\n</ul>\n</li>\n</ul>\n","categories":["FrontEnd","http"],"tags":["http"]},{"title":"The Nature of Lisp","url":"/2024/02/07/computer/the-nature-of-lisp/","content":"<p>That very second I became a member of the Lisp cult. I felt something a ninjitsu master must feel: I had to spread my newfound knowledge to at least ten lost souls in the course of my lifetime. I took the usual path. I was rehashing the same arguments that were given to me for years (only now they actually made sense!), hoping to convert unsuspecting bystanders. It didn&#39;t work. My persistence sparked a few people&#39;s interest but their curiosity dwindled at the mere sight of sample Lisp code. Perhaps years of advocacy would forge a few new Lispers, but I wasn&#39;t satisfied. There had to be a better way.<br><a id=\"more\"></a></p>\n<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>When I first stumbled into Lisp advocacy on various corners of the web I was already an experienced programmer. At that point I had grokked what seemed at the time a wide range of programming languages. I was proud to have the usual suspects (C++, Java, C#, etc.) on my service record and was under impression that I knew everything there is to know about programming languages. I couldn&#39;t have possibly been more wrong.</p>\n<p>My initial attempt to learn Lisp came to a crashing halt as soon as I saw some sample code. I suppose the same thought ran through my mind that ran through thousands of other minds who were ever in my shoes: &quot;Why on Earth would anyone want to use a language with such horrific syntax?!&quot; I couldn&#39;t be bothered to learn a language if its creators couldn&#39;t be bothered to give it a pleasant syntax. After all, I was almost blinded by the infamous Lisp parentheses!</p>\n<p>The moment I regained my sight I communicated my frustrations to some members of the Lisp sect. Almost immediately I was bombarded by a standard set of responses: Lisp&#39;s parentheses are only a superficial matter, Lisp has a huge benefit of code and data being expressed in the same manner (which, obviously, is a huge improvement over XML), Lisp has tremendously powerful metaprogramming facilities that allow programs to write code and modify themselves, Lisp allows for creation of mini-languages specific to the problem at hand, Lisp blurs the distinction between run time and compile time, Lisp, Lisp, Lisp... The list was very impressive. Needless to say none of it made sense. Nobody could illustrate the usefulness of these features with specific examples because these techniques are supposedly only useful in large software systems. After many hours of debating that conventional programming languages do the job just fine, I gave up. I wasn&#39;t about to invest months into learning a language with a terrible syntax in order to understand obscure features that had no useful examples. My time has not yet come.</p>\n<p>For many months the Lisp advocates pressed on. I was baffled. Many extremely intelligent people I knew and had much respect for were praising Lisp with almost religious dedication. There had to be something there, something I couldn&#39;t afford not to get my hands on! Eventually my thirst for knowledge won me over. I took the plunge, bit the bullet, got my hands dirty, and began months of mind bending exercises. It was a journey on an endless lake of frustration. I turned my mind inside out, rinsed it, and put it back in place. I went through seven rings of hell and came back. And then I got it.</p>\n<p>The enlightenment came instantaneously. One moment I understood nothing, and the next moment everything clicked into place. I&#39;ve achieved nirvana. Dozens of times I heard Eric Raymond&#39;s statement quoted by different people: &quot;Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot.&quot; I never understood this statement. I never believed it could be true. And finally, after all the pain, it made sense! There was more truth to it than I ever could have imagined. I&#39;ve achieved an almost divine state of mind, an instantaneous enlightenment experience that turned my view of computer science on its head in less than a single second.</p>\n<p>That very second I became a member of the Lisp cult. I felt something a ninjitsu master must feel: I had to spread my newfound knowledge to at least ten lost souls in the course of my lifetime. I took the usual path. I was rehashing the same arguments that were given to me for years (only now they actually made sense!), hoping to convert unsuspecting bystanders. It didn&#39;t work. My persistence sparked a few people&#39;s interest but their curiosity dwindled at the mere sight of sample Lisp code. Perhaps years of advocacy would forge a few new Lispers, but I wasn&#39;t satisfied. There had to be a better way.</p>\n<p>I gave the matter careful thought. Is there something inherently hard about Lisp that prevents very intelligent, experienced programmers from understanding it? No, there isn&#39;t. After all, I got it, and if I can do it, anybody can. Then what is it that makes Lisp so hard to understand? The answer, as such things usually do, came unexpectedly. Of course! Teaching anybody anything involves building advanced concepts on top of concepts they already understand! If the process is made interesting and the matter is explained properly the new concepts become as intuitive as the original building blocks that aided their understanding. That was the problem! Metaprogramming, code and data in one representation, self-modifying programs, domain specific mini-languages, none of the explanations for these concepts referenced familiar territory. How could I expect anyone to understand them! No wonder people wanted specific examples. I could as well have been speaking in Martian!</p>\n<p>I shared my ideas with fellow Lispers. &quot;Well, of course these concepts aren&#39;t explained in terms of familiar territory&quot;, they said. &quot;They are so different, they&#39;re unlike anything these people have learned before.&quot; This was a poor excuse. &quot;I do not believe this to be true&quot;, I said. The response was unanimous: &quot;Why don&#39;t you give it a try?&quot; So I did. This article is a product of my efforts. It is my attempt to explain Lisp in familiar, intuitive concepts. I urge brave souls to read on. Grab your favorite drink. Take a deep breath. Prepare to be blown away. Oh, and may the Force be with you.</p>\n<h2 id=\"XML-Reloaded\"><a href=\"#XML-Reloaded\" class=\"headerlink\" title=\"XML Reloaded\"></a>XML Reloaded</h2><p>A thousand mile journey starts with a single step. A journey to enlightenment is no exception and our first step just happens to be XML. What more could possibly be said about XML that hasn&#39;t already been said? It turns out, quite a bit. While there&#39;s nothing particularly interesting about XML itself, its relationship to Lisp is fascinating. XML is the all too familiar concept that Lisp advocates need so much. It is our bridge to conveying understanding to regular programmers. So let&#39;s revive the dead horse, take out the stick, and venture into XML wilderness that no one dared venture into before us. It&#39;s time to see the all too familiar moon from the other side.</p>\n<p>Superficially XML is nothing more than a standardized syntax used to express arbitrary hierarchical data in human readable form. To-do lists, web pages, medical records, auto insurance claims, configuration files are all examples of potential XML use. Let&#39;s use a simple to-do list as an example (in a couple of sections you&#39;ll see it in a whole new light):<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">todo</span> <span class=\"attr\">name</span>=<span class=\"string\">\"housework\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">priority</span>=<span class=\"string\">\"high\"</span>&gt;</span>Clean the house.<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">priority</span>=<span class=\"string\">\"medium\"</span>&gt;</span>Wash the dishes.<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">priority</span>=<span class=\"string\">\"medium\"</span>&gt;</span>Buy more soap.<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">todo</span>&gt;</span></span><br></pre></td></tr></table></figure><br>What happens if we unleash our favorite XML parser on this to-do list? Once the data is parsed, how is it represented in memory? The most natural representation is, of course, a tree - a perfect data structure for hierarchical data. After all is said and done, XML is really just a tree serialized to a human readable form. Anything that can be represented in a tree can be represented in XML and vice versa. I hope you understand this idea. It&#39;s very important for what&#39;s coming next.</p>\n<p>Let&#39;s take this a little further. What other type of data is often represented as a tree? At this point the list is as good as infinite so I&#39;ll give you a hint at what I&#39;m getting at - try to remember your old compiler course. If you have a vague recollection that source code is stored in a tree after it&#39;s parsed, you&#39;re on the right track. Any compiler inevitably parses the source code into an abstract syntax tree. This isn&#39;t surprising since source code is hierarchical: functions contain arguments and blocks of code. Blocks of code contain expressions and statements. Expressions contain variables and operators. And so it goes.</p>\n<p>Let&#39;s apply our corollary that any tree can easily be serialized into XML to this idea. If all source code is eventually represented as a tree, and any tree can be serialized into XML, then all source code can be converted to XML, right? Let&#39;s illustrate this interesting property by a simple example. Consider the function below:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> arg1, <span class=\"keyword\">int</span> arg2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg1 + arg2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Can you convert this function definition to its XML equivalent? Turns out, it&#39;s reasonably simple. Naturally there are many ways to do this. Here is one way the resulting XML can look like:<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">define-function</span> <span class=\"attr\">return-type</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"add\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">arguments</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">argument</span> <span class=\"attr\">type</span>=<span class=\"string\">\"int\"</span>&gt;</span>arg1<span class=\"tag\">&lt;/<span class=\"name\">argument</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">argument</span> <span class=\"attr\">type</span>=<span class=\"string\">\"int\"</span>&gt;</span>arg2<span class=\"tag\">&lt;/<span class=\"name\">argument</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">arguments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">return</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">add</span> <span class=\"attr\">value1</span>=<span class=\"string\">\"arg1\"</span> <span class=\"attr\">value2</span>=<span class=\"string\">\"arg2\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">return</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">define</span>&gt;</span></span><br></pre></td></tr></table></figure><br>We can go through this relatively simple exercise with any language. We can turn any source code into XML, and we can transform the resulting XML back to original source code. We can write a converter that turns Java into XML and a converter that turns XML back to Java. We could do the same for C++. (In case you&#39;re wondering if anyone is crazy enough to do it, take a look at GCC-XML). Furthermore, for languages that share common features but use different syntax (which to some extent is true about most mainstream languages) we could convert source code from one language to another using XML as an intermediary representation. We could use our Java2XML converter to convert a Java program to XML. We could then run an XML2CPP converter on the resulting XML and turn it into C++ code. With any luck (if we avoid using features of Java that don&#39;t exist in C++) we&#39;ll get a working C++ program. Neat, eh?</p>\n<p>All this effectively means that we can use XML for generic storage of source code. We&#39;d be able to create a whole class of programming languages that use uniform syntax, as well as write transformers that convert existing source code to XML. If we were to actually adopt this idea, compilers for different languages wouldn&#39;t need to implement parsers for their specific grammars - they&#39;d simply use an XML parser to turn XML directly into an abstract syntax tree.</p>\n<p>By now you&#39;re probably wondering why I&#39;ve embarked on the XML crusade and what it has to do with Lisp (after all, Lisp was created about thirty years before XML). I promise that everything will become clear soon enough. But before we take our second step, let&#39;s go through a small philosophical exercise. Take a good look at the XML version of our &quot;add&quot; function above. How would you classify it? Is it data or code? If you think about it for a moment you&#39;ll realize that there are good reasons to put this XML snippet into both categories. It&#39;s XML and it&#39;s just information encoded in a standardized format. We&#39;ve already determined that it can be generated from a tree data structure in memory (that&#39;s effectively what GCC-XML does). It&#39;s lying around in a file with no apparent way to execute it. We can parse it into a tree of XML nodes and do various transformations on it. It&#39;s data. But wait a moment! When all is said and done it&#39;s the same &quot;add&quot; function written with a different syntax, right? Once parsed, its tree could be fed into a compiler and we could execute it. We could easily write a small interpreter for this XML code and we could execute it directly. Alternatively, we could transform it into Java or C++ code, compile it, and run it. It&#39;s code.</p>\n<p>So, where are we? Looks like we&#39;ve just arrived to an interesting point. A concept that has traditionally been so hard to understand is now amazingly simple and intuitive. Code is also always data! Does it mean that data is also always code? As crazy as this sounds this very well might be the case. Remember how I promised that you&#39;ll see our to-do list in a whole new light? Let me reiterate on that promise. But we aren&#39;t ready to discuss this just yet. For now let&#39;s continue walking down our path.</p>\n<p>A little earlier I mentioned that we could easily write an interpreter to execute our XML snippet of the add function. Of course this sounds like a purely theoretical exercise. Who in their right mind would want to do that for practical purposes? Well, it turns out quite a few people would disagree. You&#39;ve likely encountered and used their work at least once in your career, too. Do I have you out on the edge of your seat? If so, let&#39;s move on!</p>\n<h2 id=\"Ant-Reloaded\"><a href=\"#Ant-Reloaded\" class=\"headerlink\" title=\"Ant Reloaded\"></a>Ant Reloaded</h2><p>Now that we&#39;ve made the trip to the dark side of the moon, let&#39;s not leave quite yet. We may still learn something by exploring it a little more, so let&#39;s take another step. We begin by closing our eyes and remembering a cold rainy night in the winter of 2000. A prominent developer by the name of James Duncan Davidson was hacking his way through Tomcat servlet container. As the time came to build the changes he carefully saved all his files and ran make. Errors. Lots of errors. Something was wrong. After careful examination James exclaimed: &quot;Is my command not executing because I have a space in front of my tab?!&quot; Indeed, this was the problem. Again. James has had enough. He could sense the full moon through the clouds and it made him adventurous. He created a fresh Java project and quickly hacked together a simple but surprisingly useful utility. This spark of genius used Java property files for information on how to build the project. James could now write the equivalent of the makefile in a nice format without worrying about the damned spaces ever again. His utility did all the hard work by interpreting the property file and taking appropriate actions to build the project. It was neat. Another Neat Tool. Ant.</p>\n<p>After using Ant to build Tomcat for a few months it became clear that Java property files are not sufficient to express complicated build instructions. Files needed to be checked out, copied, compiled, sent to another machine, and unit tested. In case of failure e-mails needed to be sent out to appropriate people. In case of success &quot;Bad to the Bone&quot; needed to be played at the highest possible volume. At the end of the track volume had to be restored to its original level. Yes, Java property files didn&#39;t cut it anymore. James needed a more flexible solution. He didn&#39;t feel like writing his own parser (especially since he wanted an industry standard solution). XML seemed like a reasonable alternative. In a couple of days Ant was ported to XML. It was the best thing since sliced bread.</p>\n<p>So how does Ant work? It&#39;s pretty simple. It takes an XML file with specific build instructions (you decide if they&#39;re data or code) and interprets them by running specialized Java code for each XML element. It&#39;s actually much simpler than it sounds. A simple XML instruction like the one below causes a Java class with an equivalent name to be loaded and its code to be executed.<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"../new/dir\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src_dir\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></span><br></pre></td></tr></table></figure><br>The snippet above copies a source directory to a destination directory. Ant locates a &quot;copy&quot; task (a Java class, really), sets appropriate parameters (todir and fileset) by calling appropriate Java methods and then executes the task. Ant comes with a set of core tasks and anyone can extend it with tasks of their own simply by writing Java classes that follow certain conventions. Ant finds these classes and executes them whenever XML elements with appropriate names are encountered. Pretty simple. Effectively Ant accomplishes what we were talking about in the previous section: it acts as an interpreter for a language that uses XML as its syntax by translating XML elements to appropriate Java instructions. We could write an &quot;add&quot; task and have Ant execute it when it encounters the XML snippet for addition presented in the previous section! Considering that Ant is an extremely popular project, the ideas presented in the previous section start looking more sane. After all, they&#39;re being used every day in what probably amounts to thousands of companies!</p>\n<p>So far I&#39;ve said nothing about why Ant actually goes through all the trouble of interpreting XML. Don&#39;t try to look for the answer on its website either - you&#39;ll find nothing of value. Nothing relevant to our discussion, anyway. Let&#39;s take another step. It&#39;s time to find out why.</p>\n<h2 id=\"Why-XML\"><a href=\"#Why-XML\" class=\"headerlink\" title=\"Why XML?\"></a>Why XML?</h2><p>Sometimes right decisions are made without full conscious understanding of all the issues involved. I&#39;m not sure if James knew why he chose XML - it was likely a subconscious decision. At the very least, the reasons I saw on Ant&#39;s website for using XML are all the wrong reasons. It appears that the main concerns revolved around portability and extensibility. I fail to see how XML helps advance these goals in Ant&#39;s case. What is the advantage of using interpreted XML over simple Java source code? Why not create a set of classes with a nice API for commonly used tasks (copying directories, compiling, etc.) and using those directly from Java source code? This would run on every platform that runs Java (which Ant requires anyway), it&#39;s infinitely extensible, and it has the benefit of having a more pleasant, familiar syntax. So why XML? Can we find a good reason for using it?</p>\n<p>It turns out that we can (although as I mentioned earlier I&#39;m not sure if James was consciously aware of it). XML has the property of being far more flexible in terms of introduction of semantic constructs than Java could ever hope to be. Don&#39;t worry, I&#39;m not falling into the trap of using big words to describe incomprehensible concepts. This is actually a relatively simple idea, though it may take some effort to explain. Buckle your seat-belt. We&#39;re about to make a giant leap towards achieving nirvana.</p>\n<p>How can we represent &#39;copy&#39; example above in Java code? Here&#39;s one way to do it:<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CopyTask copy = <span class=\"keyword\">new</span> CopyTask();</span><br><span class=\"line\">Fileset fileset = <span class=\"keyword\">new</span> Fileset();</span><br><span class=\"line\"></span><br><span class=\"line\">fileset.setDir(<span class=\"string\">\"src_dir\"</span>);</span><br><span class=\"line\">copy.setToDir(<span class=\"string\">\"../new/dir\"</span>);</span><br><span class=\"line\">copy.setFileset(fileset);</span><br><span class=\"line\"></span><br><span class=\"line\">copy.execute();</span><br></pre></td></tr></table></figure><br>The code is almost the same, albeit a little longer than the original XML. So what&#39;s different? The answer is that the XML snippet introduces a special semantic construct for copying. If we could do it in Java it would look like this:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">copy(<span class=\"string\">\"../new/dir\"</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fileset(<span class=\"string\">\"src_dir\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Can you see the difference? The code above (if it were possible in Java) is a special operator for copying files - similar to a for loop or a new foreach construct introduced in Java 5. If we had an automatic converter from XML to Java it would likely produce the above gibberish. The reason for this is that Java&#39;s accepted syntax tree grammar is fixed by the language specification - we have no way of modifying it. We can add packages, classes, methods, but we cannot extend Java to make addition of new operators possible. Yet we can do it to our heart&#39;s content in XML - its syntax tree isn&#39;t restricted by anything except our interpreter! If the idea is still unclear, consider introducing a special operator &#39;unless&#39; to Java:<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">unless(someObject.canFly())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    someObject.transportByGround();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>In the previous two examples we extend the Java language to introduce an operator for copying files and a conditional operator unless. We would do this by modifying the abstract syntax tree grammar that Java compiler accepts. Naturally we cannot do it with standard Java facilities, but we can easily do it in XML. Because our XML interpreter parses the abstract syntax tree that results from it, we can extend it to include any operator we like.</p>\n<p>For complex operators this ability provides tremendous benefits. Can you imagine writing special operators for checking out source code, compiling files, running unit testing, sending email? Try to come up with some. If you&#39;re dealing with a specialized problem (in our case it&#39;s building projects) these operators can do wonders to decrease the amount of code you have to type and to increase clarity and code reuse. Interpreted XML makes this extremely easy to accomplish because it&#39;s a simple data file that stores hierarchical data. We do not have this option in Java because it&#39;s hierarchical structure is fixed (as you will soon find out, we do have this option in Lisp). Perhaps this is one of the reasons why Ant is so successful?</p>\n<p>I urge you to take a look at recent evolution of Java and C# (especially the recently released specification for C# 3.0). The languages are being evolved by abstracting away commonly used functionality and adding it in the form of operators. New C# operators for built-in queries is one example. This is accomplished by relatively traditional means: language creators modify the accepted abstract syntax tree and add implementations of certain features. Imagine the possibilities if the programmer could modify the abstract syntax tree himself! Whole new sub-languages could be built for specialized domains (for example a language for building projects, like Ant). Can you come up with other examples? Think about these concepts for a bit, but don&#39;t worry about them too much. We&#39;ll come back to these issues after introducing a few more ideas. By then things will be a little more clear.</p>\n<h2 id=\"Almost-Lisp\"><a href=\"#Almost-Lisp\" class=\"headerlink\" title=\"Almost Lisp\"></a>Almost Lisp</h2><p>Let&#39;s forget about the operator business for the moment and try to expand our horizons beyond the constraints of Ant&#39;s design. I mentioned earlier that Ant can be extended by writing conventional Java classes. Ant interpreter then attempts to match XML elements to appropriately named Java classes and if the match is found the task is executed. An interesting question begs to be asked. Why not extend Ant in Ant itself? After all, core tasks contain a lot of conventional programming language constructs (&#39;if&#39; being a perfect example). If Ant provided constructs to develop tasks in Ant itself we&#39;d reach a higher degree of portability. We&#39;d be dependent on a core set of tasks (a standard library, if you will) and we wouldn&#39;t care if Java runtime is present: the core set could be implemented in anything. The rest of the tasks would be built on top of the core using Ant-XML itself. Ant would then become a generic, extensible, XML-based programming language. Consider the possibilities:<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">task</span> <span class=\"attr\">name</span>=<span class=\"string\">\"Test\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">echo</span> <span class=\"attr\">message</span>=<span class=\"string\">\"Hello World!\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">task</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Test</span> /&gt;</span></span><br></pre></td></tr></table></figure><br>If ant supported the &quot;task&quot; construct, the example above would print &quot;Hello World!&quot;. In fact, we could write a &quot;task&quot; task in Java and make Ant able to extend itself using Ant-XML! Ant would then be able to build more complicated primitives on top of simple ones, just like any other programming language! This is an example of &quot;XML&quot; based programming language we were talking about in the beginning of this tutorial. Not very useful (can you tell why?) but pretty damn cool.</p>\n<p>By the way, take a look at our &#39;Test&#39; task once again. Congratulations. You&#39;re looking at Lisp code. What on Earth am I talking about? It doesn&#39;t look anything like Lisp? Don&#39;t worry, we&#39;ll fix that in a bit. Confused? Good. Let&#39;s clear it all up!</p>\n<h2 id=\"A-Better-XML\"><a href=\"#A-Better-XML\" class=\"headerlink\" title=\"A Better XML\"></a>A Better XML</h2><p>I mentioned in the previous section that self-extending Ant wouldn&#39;t be very useful. The reason for that is XML&#39;s verbosity. It&#39;s not too bad for data files but the moment you try writing reasonably complex code the amount of typing you have to do quickly starts to get in the way and progresses to becoming unusable for any real project. Have you ever tried writing Ant build scripts? I have, and once they get complex enough having to do it in XML becomes really annoying. Imagine having to type almost everything in Java twice because you have to close every element. Wouldn&#39;t that drive you nuts?</p>\n<p>The solution to this problem involves using a less verbose alternative to XML. Remember, XML is just a format for representing hierarchical data. We don&#39;t have to use XML&#39;s angle brackets to serialize trees. We could come up with many other formats. One such format (incidentally, the one Lisp uses) is called an s-expression. S-expressions accomplish the same goals as XML. They&#39;re just a lot less verbose, which makes them much better suited for typing code. I will explain s-expressions in a little while, but before I do I have to clear up a few things about XML. Let&#39;s consider our XML example for copying files:<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">copy</span> <span class=\"attr\">todir</span>=<span class=\"string\">\"../new/dir\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fileset</span> <span class=\"attr\">dir</span>=<span class=\"string\">\"src_dir\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></span><br></pre></td></tr></table></figure><br>Think of what the parse tree of this snippet would look like in memory. We&#39;d have a &#39;copy&#39; node that contains a fileset node. But what about attributes? How do they fit into our picture? If you&#39;ve ever used XML to describe data and wondered whether you should use an element or an attribute, you&#39;re not alone. Nobody can really figure this out and doing it right tends to be black magic rather than science. The reason for that is that attributes are really subsets of elements. Anything attributes can do, elements can do as well. The reason attributes were introduced is to curb XML&#39;s verbosity. Take a look at another version of our &#39;copy&#39; snippet:<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">copy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">todir</span>&gt;</span>../new/dir<span class=\"tag\">&lt;/<span class=\"name\">todir</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fileset</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dir</span>&gt;</span>src_dir<span class=\"tag\">&lt;/<span class=\"name\">dir</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">fileset</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">copy</span>&gt;</span></span><br></pre></td></tr></table></figure><br>The two snippets hold exactly the same information. However, we use attributes to avoid typing the same thing more than once. Imagine if attributes weren&#39;t part of XML specification. Writing anything in XML would drive us nuts!</p>\n<p>Now that we got attributes out of the way, let&#39;s look at s-expressions. The reason we took this detour is that s-expressions do not have attributes. Because they&#39;re a lot less verbose, attributes are simply unnecessary. This is one thing we need to keep in mind when transforming XML to s-expressions. Let&#39;s take a look at an example. We could translate above snippet to s-expressions like this:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">copy</span></span><br><span class=\"line\">    (<span class=\"name\">todir</span> <span class=\"string\">\"../new/dir\"</span>)</span><br><span class=\"line\">    (<span class=\"name\">fileset</span> (<span class=\"name\">dir</span> <span class=\"string\">\"src_dir\"</span>)))</span><br></pre></td></tr></table></figure><br>Take a good look at this representation. What&#39;s different? Angle brackets seem to be replaced by parentheses. Instead of enclosing each element into a pair of parentheses and then closing each element with a &quot;(/element)&quot; we simply skip the second parenthesis in &quot;(element&quot; and proceed. The element is then closed like this: &quot;)&quot;. That&#39;s it! The translation is natural and very simple. It&#39;s also a lot easier to type. Do parentheses blind first time users? Maybe, but now that we&#39;re understand the reasoning behind them they&#39;re a lot easier to handle. At the very least they&#39;re better than arthritis inducing verbosity of XML. After you get used to s-expressions writing code in them is not only doable but very pleasant. And they provide all the benefits of writing code in XML (many of which we&#39;re yet to explore). Let&#39;s take a look at our &#39;task&#39; code in something that looks a lot more like lisp:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">task</span> (<span class=\"name\">name</span> <span class=\"string\">\"Test\"</span>)</span><br><span class=\"line\">    (<span class=\"name\">echo</span> (<span class=\"name\">message</span> <span class=\"string\">\"Hello World!\"</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\">Test</span>)</span><br></pre></td></tr></table></figure><br>S-expressions are called lists in Lisp lingo. Consider our &#39;task&#39; element above. If we rewrite it without a line break and with comas instead of spaces it&#39;s starting to look surprisingly like a list of elements and other lists (the formatting is added to make it easier to see nested lists):<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">task</span>, (<span class=\"name\">name</span>, <span class=\"string\">\"test\"</span>), (<span class=\"name\">echo</span>, (<span class=\"name\">message</span>, <span class=\"string\">\"Hello World!\"</span>)))</span><br></pre></td></tr></table></figure><br>We could do the same with XML. Of course the line above isn&#39;t really a list, it&#39;s a tree, just like its XML-alternative. Don&#39;t let references to lists confuse you, it&#39;s just that lists that contain other lists and trees are effectively the same thing. Lisp may stand for List Processing, but it&#39;s really tree processing - no different than processing XML nodes.</p>\n<p>Whew. After much rambling we finally got to something that looks like Lisp (and is Lisp, really). By now the mysterious Lisp parentheses as well as some claims made by Lisp advocates should become more clear. But we still have a lot of ground to cover. Ready? Let&#39;s move on!</p>\n<h2 id=\"C-Macros-Reloaded\"><a href=\"#C-Macros-Reloaded\" class=\"headerlink\" title=\"C Macros Reloaded\"></a>C Macros Reloaded</h2><p>By now you must be tired of all the XML talk. I&#39;m tired of it as well. It&#39;s time to take a break from all the trees, s-expressions, and Ant business. Instead, let&#39;s go back to every programmer&#39;s roots. It&#39;s time to talk about C preprocessor. What&#39;s C got to do with anything, I hear you ask? Well, we now know enough to get into metaprogramming and discuss code that writes other code. Understanding this tends to be hard since all tutorials discuss it in terms of languages that you don&#39;t know. But there is nothing hard about the concept. I believe that a metaprogramming discussion based on C will make the whole thing much easier to understand. So, let&#39;s see (pun intended).</p>\n<p>Why would anyone want to write a program that writes programs? How can we use something like this in the real world? What on Earth is metaprogramming, anyway? You already know all the answers, you just don&#39;t know it yet. In order to unlock the hidden vault of divine knowledge let&#39;s consider a rather mundane task of simple database access from code. We&#39;ve all been there. Writing SQL queries all over the code to modify data within tables turns into repetitive hell soon enough. Even with the new C# 3.0 LINQ stuff this is a huge pain. Writing a full SQL query (albeit with a nice built in syntax) to get someone&#39;s name or to modify someone&#39;s address isn&#39;t exactly a programmer&#39;s idea of comfort. What do we do to solve these problems? Enter data access layers.</p>\n<p>The idea is simple enough. You abstract database access (at least trivial queries, anyway) by creating a set of classes that mirror the tables in the database and use accessor methods to execute actual queries. This simplifies development tremendously - instead of writing SQL queries we make simple method calls (or property assignments, depending on your language of choice). Anyone who has ever used even the simplest of data access layers knows how much time it can save. Of course anyone who has ever written one knows how much time it can kill - writing a set of classes that mirror tables and convert accessors to SQL queries takes a considerable chunk of time. This seems especially silly since most of the work is manual: once you figure out the design and develop a template for your typical data access class you don&#39;t need to do any thinking. You just write code based on the same template over and over and over and over again. Many people figured out that there is a better way - there are plenty of tools that connect to the database, grab the schema, and write code for you based on a predefined (or a custom) template.</p>\n<p>Anyone who has ever used such a tool knows what an amazing time saver it can be. In a few clicks you connect the tool to the database, get it to generate the data access layer source code, add the files to your project and voilà - ten minutes worth of work do a better job than hundreds of man-hours that were required previously. What happens if your database schema changes? Well, you just have to go through this short process again. Of course some of the best tools let you automate this - you simply add them as a part of your build step and every time you compile your project everything is done for you automatically. This is perfect! You barely have to do anything at all. If the schema ever changes your data access layer code updates automatically at compile time and any obsolete access in your code will result in compiler errors!</p>\n<p>Data access layers are one good example, but there are plenty of others. From boilerplate GUI code, to web code, to COM and CORBA stubs, to MFC and ATL, - there are plenty of examples where the same code is written over and over again. Since writing this code is a task that can be automated completely and a programmer&#39;s time is far more expensive than CPU time, plenty of tools have been created that generate this boilerplate code automatically. What are these tools, exactly? Well, they are programs that write programs. They perform a simple task that has a mysterious name of metaprogramming. That&#39;s all there is to it.</p>\n<p>We could create and use such tools in millions of scenarios but more often than not we don&#39;t. What it boils down to is a subconscious calculation - is it worth it for me to create a separate project, write a whole tool to generate something, and then use it, if I only have to write these very similar pieces about seven times? Of course not. Data access layers and COM stubs are written hundreds, thousands of times. This is why there are tools for them. For similar pieces of code that repeat only a few times, or even a few dozen times, writing code generation tools isn&#39;t even considered. The trouble to create such a tool more often than not far outweighs the benefit of using one. If only creating such tools was much easier, we could use them more often, and perhaps save many hours of our time. Let&#39;s see if we can accomplish this in a reasonable manner.</p>\n<p>Surprisingly C preprocessor comes to the rescue. We&#39;ve all used it in C and C++. On occasion we all wish Java had it. We use it to execute simple instructions at compile time to make small changes to our code (like selectively removing debug statements). Let&#39;s look at a quick example:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> triple(X)    X + X + X</span></span><br></pre></td></tr></table></figure><br>What does this line do? It&#39;s a simple instruction written in the preprocessor language that instructs it to replace all instances of triple(X) with X + X + X. For example all instances of &#39;triple(5)&#39; will be replaced with &#39;5 + 5 + 5&#39; and the resulting code will be compiled by the C compiler. We&#39;re really doing a very primitive version of code generation here. If only C preprocessor was a little more powerful and included ways to connect to the database and a few more simple constructs, we could use it to develop our data access layer right there, from within our program! Consider the following example that uses an imaginary extension of the C preprocessor:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#get-db-schema(<span class=\"meta-string\">\"127.0.0.1, un, pwd\"</span>);</span></span><br><span class=\"line\"><span class=\"meta\">#iterate-through-tables</span></span><br><span class=\"line\"><span class=\"meta\">#for-each-table</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> #<span class=\"title\">table</span>-<span class=\"title\">name</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"meta\">#end-for-each</span></span><br></pre></td></tr></table></figure><br>We&#39;ve just connected to the database schema, iterated through all the tables, and created an empty class for each. All in a couple of lines right within our source code! Now every time we recompile the file where above code appears we&#39;ll get a freshly built set of classes that automatically update based on the schema. With a little imagination you can see how we could build a full data access layer straight from within our program, without the use of any external tools! Of course this has a certain disadvantage (aside from the fact that such an advanced version of C preprocessor doesn&#39;t exist) - we&#39;d have to learn a whole new &quot;compile-time language&quot; to do this sort of work. For complex code generation this language would have to be very complex as well, it would have to support many libraries and language constructs. For example, if our generated code depended on some file located at some ftp server the preprocessor would have to be able to connect to ftp. It&#39;s a shame to create and learn a new language just to do this. Especially since there are so many nice languages already out there. Of course if we add a little creativity we can easily avoid this pitfall.</p>\n<p>Why not replace the preprocessor language with C/C++ itself? We&#39;d have full power of the language at compile time and we&#39;d only need to learn a few simple directives to differentiate between compile time and runtime code!<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Enter a number: \"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">%&gt;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; &lt;%= n %&gt;; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Can you see what happens here? Everything that&#39;s between &lt;% and %&gt; tags runs when the program is compiled. Anything outside of these tags is normal code. In the example above you&#39;d start compiling your program in the development environment. The code between the tags would be compiled and then ran. You&#39;d get a prompt to enter a number. You&#39;d enter one and it would be placed inside the for loop. The for loop would then be compiled as usual and you&#39;d be able to execute it. For example, if you&#39;d enter 5 during the compilation of your program, the resulting code would look like this:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Simple and effective. No need for a special preprocessor language. We get full power of our host language (in this case C/C++) at compile time. We could easily connect to a database and generate our data access layer source code at compile time in the same way JSP or ASP generate HTML! Creating such tools would also be tremendously quick and simple. We&#39;d never have to create new projects with specialized GUIs. We could inline our tools right into our programs. We wouldn&#39;t have to worry about whether writing such tools is worth it because writing them would be so fast - we could save tremendous amounts of time by creating simple bits of code that do mundane code generation for us!</p>\n<h2 id=\"Hello-Lisp\"><a href=\"#Hello-Lisp\" class=\"headerlink\" title=\"Hello, Lisp!\"></a>Hello, Lisp!</h2><p>Everything we&#39;ve learned about Lisp so far can be summarized by a single statement: Lisp is executable XML with a friendlier syntax. We haven&#39;t said a single word about how Lisp actually operates. It&#39;s time to fill this gap.</p>\n<p>Lisp has a number of built in data types. Integers and strings, for example, aren&#39;t much different from what you&#39;re used to. The meaning of 71 or &quot;hello&quot; is roughly the same in Lisp as in C++ or Java. What is of more interest to us are symbols, lists, and functions. I will spend the rest of this section describing these data types as well as how a Lisp environment compiles and executes the source code you type into it (this is called evaluation in Lisp lingo). Getting through this section in one piece is important for understanding true potential of Lisp&#39;s metaprogramming, the unity of code and data, and the notion of domain specific languages. Don&#39;t think of this section as a chore though, I&#39;ll try to make it fun and accessible. Hopefully you can pick up a few interesting ideas on the way. Ok. Let&#39;s start with Lisp&#39;s symbols.</p>\n<p>A symbol in Lisp is roughly equivalent to C++ or Java&#39;s notion of an identifier. It&#39;s a name you can use to access a variable (like currentTime, arrayCount, n, etc.) The difference is that a symbol in Lisp is a lot more liberal than its mainstream identifier alternative. In C++ or Java you&#39;re limited to alphanumeric characters and an underscore. In Lisp, you are not. For example + is a valid symbol. So is -, =, hello-world, hello+world, <em>, etc. (you can find the exact definition of valid Lisp symbols online). You can assign to these symbols any data-type you like. Let&#39;s ignore Lisp syntax and use pseudo-code for now. Assume that a function set assigns some value to a symbol (like = does in Java or C++). The following are all valid examples:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>(test, <span class=\"number\">5</span>)            <span class=\"comment\">// symbol 'test' will equal an integer 5</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(=, <span class=\"number\">5</span>)               <span class=\"comment\">// symbol '=' will equal an integer 5</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(test, <span class=\"string\">\"hello\"</span>)      <span class=\"comment\">// symbol 'test' will equal a string \"hello\"</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(test, =)            <span class=\"comment\">// at this point symbol '=' is equal to 5</span></span><br><span class=\"line\">                        <span class=\"comment\">// therefore symbol 'test' will equal to 5</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(*, <span class=\"string\">\"hello\"</span>)         <span class=\"comment\">// symbol '*' will equal a string \"hello\"</span></span><br></pre></td></tr></table></figure><br>At this point something must smell wrong. If we can assign strings and integers to symbols like </em>, how does Lisp do multiplication? After all, <em> means multiply, right? The answer is pretty simple. Functions in Lisp aren&#39;t special. There is a data-type, function, just like integer and string, that you assign to symbols. A multiplication function is built into Lisp and is assigned to a symbol </em>. You can reassign a different value to * and you&#39;d lose the multiplication function. Or you can store the value of the function in some other variable. Again, using pseudo-code:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">*(<span class=\"number\">3</span>, <span class=\"number\">4</span>)                 <span class=\"comment\">// multiplies 3 by 4, resulting in 12</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(temp, *)            <span class=\"comment\">// symbol '*' is equal to the multiply function</span></span><br><span class=\"line\">                        <span class=\"comment\">// so temp will equal to the multiply function</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(*, <span class=\"number\">3</span>)               <span class=\"comment\">// sets symbol '*' to equal to 3</span></span><br><span class=\"line\">*(<span class=\"number\">3</span>, <span class=\"number\">4</span>)                 <span class=\"comment\">// error, symbol '*' no longer equals to a function</span></span><br><span class=\"line\">                        <span class=\"comment\">// it's equal to 3</span></span><br><span class=\"line\">temp(<span class=\"number\">3</span>, <span class=\"number\">4</span>)              <span class=\"comment\">// temp equals to a multiply function</span></span><br><span class=\"line\">                        <span class=\"comment\">// so Lisp multiplies 3 by 4 resulting in 12</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(*, temp)            <span class=\"comment\">// symbol '*' equals multiply function again</span></span><br><span class=\"line\">*(<span class=\"number\">3</span>, <span class=\"number\">4</span>)                 <span class=\"comment\">// multiplies 3 by 4, resulting in 12</span></span><br></pre></td></tr></table></figure><br>You can even do wacky stuff like reassigning plus to minus:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>(+, -)               <span class=\"comment\">// the value of '-' is a built in minus function</span></span><br><span class=\"line\">                        <span class=\"comment\">// so now symbol '+' equals to a minus function</span></span><br><span class=\"line\">+(<span class=\"number\">5</span>, <span class=\"number\">4</span>)                 <span class=\"comment\">// since symbol '+' is equal to the minus function</span></span><br><span class=\"line\">                        <span class=\"comment\">// this results in 1</span></span><br></pre></td></tr></table></figure><br>I&#39;ve used functions quite liberally in these examples but I didn&#39;t describe them yet. A function in Lisp is just a data-type like an integer, a string, or a symbol. A function doesn&#39;t have a notion of a name like in Java or C++. Instead, it stands on its own. Effectively it is a pointer to a block of code along with some information (like a number of parameters it accepts). You only give the function a name by assigning it to a symbol, just like you assign an integer or a string. You can create a function by using a built in function for creating functions, assigned to a symbol &#39;fn&#39;. Using pseudo-code:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">fn [a]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(a, <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>This returns a function that takes a single parameter named &#39;a&#39; and doubles it. Note that the function has no name but you can assign it to a symbol:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>(times-two, fn [a] &#123; <span class=\"keyword\">return</span> *(a, <span class=\"number\">2</span>); &#125;)</span><br></pre></td></tr></table></figure><br>We can now call this function:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">times-two(<span class=\"number\">5</span>)             <span class=\"comment\">// returns 10</span></span><br></pre></td></tr></table></figure><br>Now that we went over symbols and functions, what about lists? Well, you already know a lot about them. Lists are simply pieces of XML written in s-expression form. A list is specified by parentheses and contains Lisp data-types (including other lists) separated by a space. For example (this is real Lisp, note that we use semicolons for comments now):<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">()                      <span class=\"comment\">; an empty list</span></span><br><span class=\"line\">(<span class=\"number\">1</span>)                     <span class=\"comment\">; a list with a single element, 1</span></span><br><span class=\"line\">(<span class=\"number\">1</span> <span class=\"string\">\"test\"</span>)              <span class=\"comment\">; a list with two elements</span></span><br><span class=\"line\">                        <span class=\"comment\">; an integer 1 and a string \"test\"</span></span><br><span class=\"line\">(<span class=\"name\">test</span> <span class=\"string\">\"hello\"</span>)          <span class=\"comment\">; a list with two elements</span></span><br><span class=\"line\">                        <span class=\"comment\">; a symbol test and a string \"hello\"</span></span><br><span class=\"line\">(<span class=\"name\">test</span> (<span class=\"number\">1</span> <span class=\"number\">2</span>) <span class=\"string\">\"hello\"</span>)    <span class=\"comment\">; a list with three elements, a symbol test</span></span><br><span class=\"line\">                        <span class=\"comment\">; a list of two integers 1 and 2</span></span><br><span class=\"line\">                        <span class=\"comment\">; and a string \"hello\"</span></span><br></pre></td></tr></table></figure><br>When a Lisp system encounters lists in the source code it acts exactly like Ant does when it encounters XML - it attempts to execute them. In fact, Lisp source code is only specified using lists, just like Ant source code is only specified using XML. Lisp executes lists in the following manner. The first element of the list is treated as the name of a function. The rest of the elements are treated as functions parameters. If one of the parameters is another list it is executed using the same principles and the result is passed as a parameter to the original function. That&#39;s it. We can write real code now:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">*</span> <span class=\"number\">3</span> <span class=\"number\">4</span>)                 <span class=\"comment\">; equivalent to pseudo-code *(3, 4).</span></span><br><span class=\"line\">                        <span class=\"comment\">; Symbol '*' is a function</span></span><br><span class=\"line\">                        <span class=\"comment\">; 3 and 4 are its parameters.</span></span><br><span class=\"line\">                        <span class=\"comment\">; Returns 12.</span></span><br><span class=\"line\">(<span class=\"name\">times-two</span> <span class=\"number\">5</span>)           <span class=\"comment\">; returns 10</span></span><br><span class=\"line\">(<span class=\"number\">3</span> <span class=\"number\">4</span>)                   <span class=\"comment\">; error: 3 is not a function</span></span><br><span class=\"line\">(<span class=\"name\">times-two</span>)              <span class=\"comment\">; error, times-two expects one parameter</span></span><br><span class=\"line\">(<span class=\"name\">times-two</span> <span class=\"number\">3</span> <span class=\"number\">4</span>)          <span class=\"comment\">; error, times-two expects one parameter</span></span><br><span class=\"line\">(<span class=\"name\">set</span> + -)               <span class=\"comment\">; sets symbol '+' to be equal to whatever symbol '-'</span></span><br><span class=\"line\">                        <span class=\"comment\">; equals to, which is a minus function</span></span><br><span class=\"line\">(<span class=\"name\">+</span> <span class=\"number\">5</span> <span class=\"number\">4</span>)                 <span class=\"comment\">; returns 1 since symbol '+' is now equal</span></span><br><span class=\"line\">                        <span class=\"comment\">; to the minus function</span></span><br><span class=\"line\">(<span class=\"name\">*</span> <span class=\"number\">3</span> (<span class=\"name\">*</span> <span class=\"number\">2</span> <span class=\"number\">2</span>))           <span class=\"comment\">; multiplies 3 by the second parameter</span></span><br><span class=\"line\">                        <span class=\"comment\">; (which is a function call that returns 4).</span></span><br><span class=\"line\">                        <span class=\"comment\">; Returns 12.</span></span><br></pre></td></tr></table></figure><br>Note that so far every list we&#39;ve specified was treated by a Lisp system as code. But how can we treat a list as data? Again, imagine an Ant task that accepts XML as one of its parameters. In Lisp we do this using a quote operator &#39; like so:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">set</span> test '(<span class=\"number\">1</span> <span class=\"number\">2</span>))       <span class=\"comment\">; test is equal to a list of two integers, 1 and 2</span></span><br><span class=\"line\">(<span class=\"name\">set</span> test (<span class=\"number\">1</span> <span class=\"number\">2</span>))        <span class=\"comment\">; error, 1 is not a function</span></span><br><span class=\"line\">(<span class=\"name\">set</span> test '(* 3 4))     ; sets test to a list of three elements,</span><br><span class=\"line\">                        ; a symbol *, an integer <span class=\"number\">3</span>, and an integer <span class=\"number\">4</span></span><br></pre></td></tr></table></figure><br>We can use a built in function head to return the first element of the list, and a built in function tail to return the rest of the list&#39;s elements:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">head</span> '(* 3 4))         ; returns a symbol '*'</span><br><span class=\"line\">(tail '(* <span class=\"number\">3</span> <span class=\"number\">4</span>))         ; returns a list (<span class=\"number\">3</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">(head (tail '( * <span class=\"number\">3</span> <span class=\"number\">4</span>))) ; (tail '(* <span class=\"number\">3</span> <span class=\"number\">4</span>)) returns a list (<span class=\"number\">3</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">                        ; and (head '(<span class=\"number\">3</span> <span class=\"number\">4</span>)) returns <span class=\"number\">3</span>.</span><br><span class=\"line\">(head test)             ; test was set to a list in previous example</span><br><span class=\"line\">                        ; returns a symbol '*'</span><br></pre></td></tr></table></figure><br>You can think of built in Lisp functions as you think of Ant tasks. The difference is that we don&#39;t have to extend Lisp in another language (although we can), we can extend it in Lisp itself as we did with the times-two example. Lisp comes with a very compact set of built in functions - the necessary minimum. The rest of the language is implemented as a standard library in Lisp itself.</p>\n<h2 id=\"Lisp-Macros\"><a href=\"#Lisp-Macros\" class=\"headerlink\" title=\"Lisp Macros\"></a>Lisp Macros</h2><p>So far we&#39;ve looked at metaprogramming in terms of a simple templating engine similar to JSP. We&#39;ve done code generation using simple string manipulations. This is generally how most code generation tools go about doing this task. But we can do much better. To get on the right track, let&#39;s start off with a question. How would we write a tool that automatically generates Ant build scripts by looking at source files in the directory structure?</p>\n<p>We could take the easy way out and generate Ant XML by manipulating strings. Of course a much more abstract, expressive and extensible way is to work with XML processing libraries to generate XML nodes directly in memory. The nodes can then be serialized to strings automatically. Furthermore, our tool would be able to analyze and transform existing Ant build scripts by loading them and dealing with the XML nodes directly. We would abstract ourselves from strings and deal with higher level concepts which let us get the job done faster and easier.</p>\n<p>Of course we could write Ant tasks that allow dealing with XML transformations and write our generation tool in Ant itself. Or we could just use Lisp. As we saw earlier, a list is a built in Lisp data structure and Lisp has a number of facilities for processing lists quickly and effectively (head and tail being the simplest ones). Additionally Lisp has no semantic constraints - you can have your code (and data) have any structure you want.</p>\n<p>Metaprogramming in Lisp is done using a construct called a &quot;macro&quot;. Let&#39;s try to develop a set of macros that transform data like, say, a to-do list (surprised?), into a language for dealing with to-do lists.</p>\n<p>Let&#39;s recall our to-do list example. The XML looks like this:<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">todo</span> <span class=\"attr\">name</span>=<span class=\"string\">\"housework\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">priority</span>=<span class=\"string\">\"high\"</span>&gt;</span>Clean the house.<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">priority</span>=<span class=\"string\">\"medium\"</span>&gt;</span>Wash the dishes.<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">priority</span>=<span class=\"string\">\"medium\"</span>&gt;</span>Buy more soap.<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">todo</span>&gt;</span></span><br></pre></td></tr></table></figure><br>The corresponding s-expression version looks like this:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">todo</span> <span class=\"string\">\"housework\"</span></span><br><span class=\"line\">    (<span class=\"name\">item</span> (<span class=\"name\">priority</span> high) <span class=\"string\">\"Clean the house.\"</span>)</span><br><span class=\"line\">    (<span class=\"name\">item</span> (<span class=\"name\">priority</span> medium) <span class=\"string\">\"Wash the dishes.\"</span>)</span><br><span class=\"line\">    (<span class=\"name\">item</span> (<span class=\"name\">priority</span> medium) <span class=\"string\">\"Buy more soap.\"</span>))</span><br></pre></td></tr></table></figure><br>Suppose we&#39;re writing a to-do manager application. We keep our to-do items serialized in a set of files and when the program starts up we want to read them and display them to the user. How would we do this with XML and some other language (say, Java)? We&#39;d parse our XML files with the to-do lists using some XML parser, write the code that walks the XML tree and converts it to a Java data structure (because frankly, processing DOM in Java is a pain in the neck), and then use this data structure to display the data. Now, how would we do the same thing in Lisp?</p>\n<p>If we were to adopt the same approach we&#39;d parse the files using Lisp libraries responsible for parsing XML. The XML would then be presented to us as a Lisp list (an s-expression) and we&#39;d walk the list and present relevant data to the user. Of course if we used Lisp it would make sense to persist the data as s-expressions directly as there&#39;s no reason to do an XML conversion. We wouldn&#39;t need special parsing libraries since data persisted as a set of s-expressions is valid Lisp and we could use Lisp compiler to parse it and store it in memory as a Lisp list. Note that Lisp compiler (much like .NET compiler) is available to a Lisp program at runtime.</p>\n<p>But we can do better. Instead of writing code to walk the s-expression that stores our data we could write a macro that allows us to treat data as code! How do macros work? Pretty simple, really. Recall that a Lisp function is called like this:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">function-name</span> arg1 arg2 arg3)</span><br></pre></td></tr></table></figure><br>Where each argument is a valid Lisp expression that&#39;s evaluated and passed to the function. For example if we replace arg1 above with (+ 4 5), it will be evaluated and 9 would be passed to the function. A macro works the same way as a function, except its arguments are not evaluated.<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">macro-name</span> (<span class=\"name\">+</span> <span class=\"number\">4</span> <span class=\"number\">5</span>))</span><br></pre></td></tr></table></figure><br>In this case, (+ 4 5) is not evaluated and is passed to the macro as a list. The macro is then free to do what it likes with it, including evaluating it. The return value of a macro is a Lisp list that&#39;s treated as code. The original place with the macro is replaced with this code. For example, we could define a macro plus that takes two arguments and puts in the code that adds them.</p>\n<p>What does it have to do with metaprogramming and our to-do list problem? Well, for one, macros are little bits of code that generate code using a list abstraction. Also, we could create macros named to-do and item that replace our data with whatever code we like, for instance code that displays the item to the user.</p>\n<p>What benefits does this approach offer? We don&#39;t have to walk the list. The compiler will do it for us and will invoke appropriate macros. All we need to do is create the macros that convert our data to appropriate code!</p>\n<p>For example, a macro similar to our triple C macro we showed earlier looks like this:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">defmacro</span> triple (<span class=\"name\">x</span>)</span><br><span class=\"line\">    '(+ ~x ~x ~x))</span><br></pre></td></tr></table></figure><br>The quote prevents evaluation while the tilde allows it. Now every time triple is encountered in lisp code:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">triple</span> <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure><br>it is replaced with the following code:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">+</span> <span class=\"number\">4</span> <span class=\"number\">4</span> <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure><br>We can create macros for our to-do list items that will get called by lisp compiler and will transform the to-do list into code. Now our to-do list will be treated as code and will be executed. Suppose all we want to do is print it to standard output for the user to read:<br><figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">defmacro</span> item (<span class=\"name\">priority</span> note)</span><br><span class=\"line\">    '(block</span><br><span class=\"line\">         (print stdout tab <span class=\"string\">\"Priority: \"</span></span><br><span class=\"line\">             ~(head (tail priority)) endl)</span><br><span class=\"line\">         (print stdout tab <span class=\"string\">\"Note: \"</span> ~note endl endl)))</span><br></pre></td></tr></table></figure><br>We&#39;ve just created a very small and limited language for managing to-do lists embedded in Lisp. Such languages are very specific to a particular problem domain and are often referred to as domain specific languages or DSLs.</p>\n<h2 id=\"Domain-Specific-Languages\"><a href=\"#Domain-Specific-Languages\" class=\"headerlink\" title=\"Domain Specific Languages\"></a>Domain Specific Languages</h2><p>In this article we&#39;ve already encountered two domain specific languages: Ant (specific to dealing with project builds) and our unnamed mini-language for dealing with to-do lists. The difference is that Ant was written from scratch using XML, an XML parser, and Java while our language is embedded into Lisp and is easily created within a couple of minutes.</p>\n<p>We&#39;ve already discussed the benefits of DSLs, mainly why Ant is using XML, not Java source code. Lisp lets us create as many DSLs as we need for our problem. We can create domain specific languages for creating web applications, writing massively multiplayer games, doing fixed income trading, solving the protein folding problem, dealing with transactions, etc. We can layer these languages on top of each other and create a language for writing web-based trading applications by taking advantage of our web application language and bond trading language. Every day we&#39;d reap the benefits of this approach, much like we reap the benefits of Ant.</p>\n<p>Using DSLs to solve problems results in much more compact, maintainable, flexible programs. In a way we create them in Java by creating classes that help us solve the problem. The difference is that Lisp allows us to take this abstraction to the next level: we&#39;re not limited by Java&#39;s parser. Think of writing build scripts in Java itself using some supporting library. Compare it to using Ant. Now apply this same comparison to every single problem you&#39;ve ever worked on and you&#39;ll begin to glimpse a small share of the benefits offered by Lisp.</p>\n<h2 id=\"What-39-s-next\"><a href=\"#What-39-s-next\" class=\"headerlink\" title=\"What&#39;s next?\"></a>What&#39;s next?</h2><p>Learning Lisp is an uphill battle. Even though in Computer Science terms Lisp is an ancient language, few people to date figured out how to teach it well enough to make it accessible. Despite great efforts by many Lisp advocates, learning Lisp today is still hard. The good news is that this won&#39;t remain the case forever since the amount of Lisp-related resources is rapidly increasing. Time is on Lisp&#39;s side.</p>\n<p>Lisp is a way to escape mediocrity and to get ahead of the pack. Learning Lisp means you can get a better job today, because you can impress any reasonably intelligent interviewer with fresh insight into most aspects of software engineering. It also means you&#39;re likely to get fired tomorrow because everyone is tired of you constantly mentioning how much better the company could be doing if only its software was written in Lisp. Is it worth the effort? Everyone who has ever learned Lisp says yes. The choice, of course, remains yours.</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZGVmbWFjcm8ub3JnL3JhbWJsaW5ncy9saXNwLmh0bWw=\">orgin page<i class=\"fa fa-external-link-alt\"></i></span></p>\n","tags":["lisp"]},{"title":"Javascript之禅","url":"/2012/10/01/note/note-depth-analysis-of-javascript-data-structures/","content":"<p>编程世界里只存在两种基本元素，一个是数据，一个是代码。编程世界就是在数据和代码千丝万缕的纠缠中呈现出无限的生机和活力。<br><a id=\"more\"></a></p>\n<p>数据天生就是文静的，总想保持自己固有的本色；而代码却天生活泼，总想改变这个世界。</p>\n<p>你看，数据代码间的关系与物质能量间的关系有着惊人的相似。数据也是有惯性的，如果没有代码来施加外力，她总保持自己原来的状态。而代码就象能量，他存在的唯一目的，就是要努力改变数据原来的状态。在代码改变数据的同时，也会因为数据的抗拒而反过来影响或改变代码原有的趋势。甚至在某些情况下，数据可以转变为代码，而代码却又有可能被转变为数据，或许还存在一个类似E=MC2形式的数码转换方程呢。然而，就是在数据和代码间这种即矛盾又统一的运转中，总能体现出计算机世界的规律，这些规律正是我们编写的程序逻辑。</p>\n<p>不过，由于不同程序员有着不同的世界观，这些数据和代码看起来也就不尽相同。于是，不同世界观的程序员们运用各自的方法论，推动着编程世界的进化和发展。</p>\n<p>众所周知，当今最流行的编程思想莫过于面向对象编程的思想。为什么面向对象的思想能迅速风靡编程世界呢？因为面向对象的思想首次把数据和代码结合成统一体，并以一个简单的对象概念呈现给编程者。这一下子就将原来那些杂乱的算法与子程序，以及纠缠不清的复杂数据结构，划分成清晰而有序的对象结构，从而理清了数据与代码在我们心中那团乱麻般的结。我们又可以有一个更清晰的思维，在另一个思想高度上去探索更加浩瀚的编程世界了。</p>\n<h2 id=\"回归简单\"><a href=\"#回归简单\" class=\"headerlink\" title=\"回归简单\"></a>回归简单</h2><p>要理解JavaScript，你得首先放下对象和类的概念，回到数据和代码的本原。前面说过，编程世界只有数据和代码两种基本元素，而这两种元素又有着纠缠不清的关系。JavaScript就是把数据和代码都简化到最原始的程度。</p>\n<p>JavaScript中的数据很简洁的。简单数据只有 undefined, null, boolean, number和string这五种，而复杂数据只有一种，即object。这就好比中国古典的朴素唯物思想，把世界最基本的元素归为金木水火土，其他复杂的物质都是由这五种基本元素组成。</p>\n<p>JavaScript中的代码只体现为一种形式，就是function。</p>\n<p>注意：以上单词都是小写的，不要和Number, String, Object, Function等JavaScript内置函数混淆了。要知道，JavaScript语言是区分大小写的呀!</p>\n<p>任何一个JavaScript的标识、常量、变量和参数都只是unfined, null, bool, number, string, object 和 function类型中的一种，也就typeof返回值表明的类型。除此之外没有其他类型了。</p>\n<p>先说说简单数据类型吧。</p>\n<p>undefined: 代表一切未知的事物，啥都没有，无法想象，代码也就更无法去处理了。<br>注意：typeof(undefined) 返回也是 undefined。<br>可以将undefined赋值给任何变量或属性，但并不意味了清除了该变量，反而会因此多了一个属性。</p>\n<p>null: 有那么一个概念，但没有东西。无中似有，有中还无。虽难以想象，但已经可以用代码来处理了。<br>注意：typeof(null)返回object，但null并非object，具有null值的变量也并非object。</p>\n<p>boolean: 是就是，非就非，没有疑义。对就对，错就错，绝对明确。既能被代码处理，也可以控制代码的流程。</p>\n<p>number: 线性的事物，大小和次序分明，多而不乱。便于代码进行批量处理，也控制代码的迭代和循环等。<br>注意：typeof(NaN)和typeof(Infinity)都返回number 。<br>NaN参与任何数值计算的结构都是NaN，而且 NaN != NaN 。<br>Infinity / Infinity = NaN 。</p>\n<p>string: 面向人类的理性事物，而不是机器信号。人机信息沟通，代码据此理解人的意图等等，都靠它了。</p>\n<p>简单类型都不是对象，JavaScript没有将对象化的能力赋予这些简单类型。直接被赋予简单类型常量值的标识符、变量和参数都不是一个对象。</p>\n<p>所谓“对象化”，就是可以将数据和代码组织成复杂结构的能力。JavaScript中只有object类型和function类型提供了对象化的能力。</p>\n<h4 id=\"没有类\"><a href=\"#没有类\" class=\"headerlink\" title=\"没有类\"></a>没有类</h4><p>object就是对象的类型。在JavaScript中不管多么复杂的数据和代码，都可以组织成object形式的对象。</p>\n<p>但JavaScript却没有 “类”的概念！</p>\n<p>对于许多面向对象的程序员来说，这恐怕是JavaScript中最难以理解的地方。是啊，几乎任何讲面向对象的书中，第一个要讲的就是“类”的概念，这可是面向对象的支柱。这突然没有了“类”，我们就象一下子没了精神支柱，感到六神无主。看来，要放下对象和类，达到“对象本无根，类型亦无形”的境界确实是件不容易的事情啊。</p>\n<p>这样，我们先来看一段JavaScript程序：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var life &#x3D; &#123;&#125;;  </span><br><span class=\"line\">for(life.age &#x3D; 1; life.age &lt;&#x3D; 3; life.age++)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">switch(life.age)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">case 1: life.body &#x3D; “卵细胞”;  </span><br><span class=\"line\">life.say &#x3D; function()&#123;alert(this.age+this.body)&#125;;  </span><br><span class=\"line\">break;  </span><br><span class=\"line\">case 2: life.tail &#x3D; “尾巴”;  </span><br><span class=\"line\">life.gill &#x3D; “腮”;  </span><br><span class=\"line\">life.body &#x3D; “蝌蚪”;  </span><br><span class=\"line\">life.say &#x3D; function()&#123;alert(this.age+this.body+”-”+this.tail+”,”+this.gill)&#125;;  </span><br><span class=\"line\">break;  </span><br><span class=\"line\">case 3: delete life.tail;  </span><br><span class=\"line\">delete life.gill;  </span><br><span class=\"line\">life.legs &#x3D; “四条腿”;  </span><br><span class=\"line\">life.lung &#x3D; “肺”;  </span><br><span class=\"line\">life.body &#x3D; “青蛙”;  </span><br><span class=\"line\">life.say &#x3D; function()&#123;alert(this.age+this.body+”-”+this.legs+”,”+this.lung)&#125;;  </span><br><span class=\"line\">break;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">life.say();  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>这段JavaScript程序一开始产生了一个生命对象life，life诞生时只是一个光溜溜的对象，没有任何属性和方法。在第一次生命过程中，它有了一个身体属性body，并有了一个say方法，看起来是一个“卵细胞”。在第二次生命过程中，它又长出了“尾巴”和“腮”，有了tail和gill属性，显然它是一个“蝌蚪”。在第三次生命过程中，它的tail和gill属性消失了，但又长出了“四条腿”和“肺”，有了legs和lung属性，从而最终变成了“青蛙”。如果，你的想像力丰富的话，或许还能让它变成英俊的“王子”，娶个美丽的“公主”什么的。不过，在看完这段程序之后，请你思考一个问题：</p>\n<p>我们一定需要类吗？</p>\n<p>还记得儿时那个“小蝌蚪找妈妈”的童话吗？也许就在昨天晚，你的孩子刚好是在这个美丽的童话中进入梦乡的吧。可爱的小蝌蚪也就是在其自身类型不断演化过程中，逐渐变成了和妈妈一样的“类”，从而找到了自己的妈妈。这个童话故事中蕴含的编程哲理就是：对象的“类”是从无到有，又不断演化，最终又消失于无形之中的…</p>\n<p>“类”，的确可以帮助我们理解复杂的现实世界，这纷乱的现实世界也的确需要进行分类。但如果我们的思想被“类”束缚住了，“类”也就变成了“累”。想象一下，如果一个生命对象开始的时就被规定了固定的“类”，那么它还能演化吗？蝌蚪还能变成青蛙吗？还可以给孩子们讲小蝌蚪找妈妈的故事吗？</p>\n<p>所以，JavaScript中没有“类”，类已化于无形，与对象融为一体。正是由于放下了“类”这个概念，JavaScript的对象才有了其他编程语言所没有的活力。</p>\n<p>如果，此时你的内心深处开始有所感悟，那么你已经逐渐开始理解JavaScript的禅机了。</p>\n<h4 id=\"函数的魔力\"><a href=\"#函数的魔力\" class=\"headerlink\" title=\"函数的魔力\"></a>函数的魔力</h4><p>接下来，我们再讨论一下JavaScript函数的魔力吧。</p>\n<p>JavaScript的代码就只有function一种形式，function就是函数的类型。也许其他编程语言还有procedure或 method等代码概念，但在JavaScript里只有function一种形式。当我们写下一个函数的时候，只不过是建立了一个function类型的实体而已。请看下面的程序：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myfunc()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”hello”);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">alert(typeof(myfunc));</span><br></pre></td></tr></table></figure><br>这个代码运行之后可以看到typeof(myfunc)返回的是function。以上的函数写法我们称之为“定义式”的，如果我们将其改写成下面的“变量式”的，就更容易理解了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var myfunc &#x3D; function ()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”hello”);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">alert(typeof(myfunc));</span><br></pre></td></tr></table></figure><br>这里明确定义了一个变量myfunc，它的初始值被赋予了一个function的实体。因此，typeof(myfunc)返回的也是function。其实，这两种函数的写法是等价的，除了一点细微差别，其内部实现完全相同。也就是说，我们写的这些JavaScript函数只是一个命了名的变量而已，其变量类型即为function，变量的值就是我们编写的函数代码体。</p>\n<p>聪明的你或许立即会进一步的追问：既然函数只是变量，那么变量就可以被随意赋值并用到任意地方啰？</p>\n<p>我们来看看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var myfunc &#x3D; function ()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”hello”);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">myfunc(); &#x2F;&#x2F;第一次调用myfunc，输出hello  </span><br><span class=\"line\">myfunc &#x3D; function ()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”yeah”);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">myfunc(); &#x2F;&#x2F;第二次调用myfunc，将输出yeah</span><br></pre></td></tr></table></figure><br>这个程序运行的结果告诉我们：答案是肯定的！在第一次调用函数之后，函数变量又被赋予了新的函数代码体，使得第二次调用该函数时，出现了不同的输出。</p>\n<p>好了，我们又来把上面的代码改成第一种定义式的函数形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function myfunc ()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”hello”);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">myfunc(); &#x2F;&#x2F;这里调用myfunc，输出yeah而不是hello  </span><br><span class=\"line\"></span><br><span class=\"line\">function myfunc ()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”yeah”);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">myfunc(); &#x2F;&#x2F;这里调用myfunc，当然输出yeah</span><br></pre></td></tr></table></figure><br>按理说，两个签名完全相同的函数，在其他编程语言中应该是非法的。但在JavaScript中，这没错。不过，程序运行之后却发现一个奇怪的现象：两次调用都只是最后那个函数里输出的值！显然第一个函数没有起到任何作用。这又是为什么呢？</p>\n<p>原来，JavaScript执行引擎并非一行一行地分析和执行程序，而是一段一段地分析执行的。而且，在同一段程序的分析执行中，定义式的函数语句会被提取出来优先执行。函数定义执行完之后，才会按顺序执行其他语句代码。也就是说，在第一次调用myfunc之前，第一个函数语句定义的代码逻辑，已被第二个函数定义语句覆盖了。所以，两次都调用都是执行最后一个函数逻辑了。</p>\n<p>如果把这个JavaScript代码分成两段，例如将它们写在一个html中，并用<code>&lt;script/&gt;</code>标签将其分成这样的两块：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">function myfunc ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">alert(”hello”);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myfunc(); &#x2F;&#x2F;这里调用myfunc，输出hello</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">function myfunc ()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">alert(”yeah”);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myfunc(); &#x2F;&#x2F;这里调用myfunc，输出yeah</span><br><span class=\"line\">&lt;&#x2F;script&gt;&#96;</span><br></pre></td></tr></table></figure><br>这时，输出才是各自按顺序来的，也证明了JavaScript的确是一段段地执行的。</p>\n<p>一段代码中的定义式函数语句会优先执行，这似乎有点象静态语言的编译概念。所以，这一特征也被有些人称为：JavaScript的“预编译”。</p>\n<p>大多数情况下，我们也没有必要去纠缠这些细节问题。只要你记住一点：JavaScript里的代码也是一种数据，同样可以被任意赋值和修改的，而它的值就是代码的逻辑。只是，与一般数据不同的是，函数是可以被调用执行的。</p>\n<p>不过，如果JavaScript函数仅仅只有这点道行的话，这与C++的函数指针，DELPHI的方法指针，C#的委托相比，又有啥稀奇嘛！然而， JavaScript函数的神奇之处还体现在另外两个方面：一是函数function类型本身也具有对象化的能力，二是函数function与对象 object超然的结合能力。</p>\n<h4 id=\"奇妙的对象\"><a href=\"#奇妙的对象\" class=\"headerlink\" title=\"奇妙的对象\"></a>奇妙的对象</h4><p>先来说说函数的对象化能力。</p>\n<p>任何一个函数都可以为其动态地添加或去除属性，这些属性可以是简单类型，可以是对象，也可以是其他函数。也就是说，函数具有对象的全部特征，你完全可以把函数当对象来用。其实，函数就是对象，只不过比一般的对象多了一个括号“()”操作符，这个操作符用来执行函数的逻辑。即，函数本身还可以被调用，一般对象却不可以被调用，除此之外完全相同。请看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Sing()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">with(arguments.callee)  </span><br><span class=\"line\">alert(author + “：” + poem);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">Sing.author &#x3D; “李白”;  </span><br><span class=\"line\">Sing.poem &#x3D; “汉家秦地月，流影照明妃。一上玉关道，天涯去不归”;  </span><br><span class=\"line\">Sing();  </span><br><span class=\"line\">Sing.author &#x3D; “李战”;  </span><br><span class=\"line\">Sing.poem &#x3D; “日出汉家天，月落阴山前。女儿琵琶怨，已唱三千年”;  </span><br><span class=\"line\">Sing();</span><br></pre></td></tr></table></figure><br>在这段代码中，Sing函数被定义后，又给Sing函数动态地增加了author和poem属性。将author和poem属性设为不同的作者和诗句，在调用Sing()时就能显示出不同的结果。这个示例用一种诗情画意的方式，让我们理解了JavaScript函数就是对象的本质，也感受到了 JavaScript语言的优美。</p>\n<p>好了，以上的讲述，我们应该算理解了function类型的东西都是和object类型一样的东西，这种东西被我们称为“对象”。我们的确可以这样去看待这些“对象”，因为它们既有“属性”也有“方法”嘛。但下面的代码又会让我们产生新的疑惑：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var anObject &#x3D; &#123;&#125;; &#x2F;&#x2F;一个对象  </span><br><span class=\"line\">anObject.aProperty &#x3D; “Property of object”; &#x2F;&#x2F;对象的一个属性  </span><br><span class=\"line\">anObject.aMethod &#x3D; function()&#123;alert(”Method of object”)&#125;; &#x2F;&#x2F;对象的一个方法  </span><br><span class=\"line\">&#x2F;&#x2F;主要看下面：  </span><br><span class=\"line\">alert(anObject[”aProperty”]); &#x2F;&#x2F;可以将对象当数组以属性名作为下标来访问属性  </span><br><span class=\"line\">&#96;anObject[”aMethod”]()&#96;; &#x2F;&#x2F;可以将对象当数组以方法名作为下标来调用方法  </span><br><span class=\"line\">for( var s in anObject) &#x2F;&#x2F;遍历对象的所有属性和方法进行迭代化处理  </span><br><span class=\"line\">alert(s + ” is a ” + typeof(anObject[s]));  </span><br><span class=\"line\">同样对于function类型的对象也是一样：  </span><br><span class=\"line\">var aFunction &#x3D; function() &#123;&#125;; &#x2F;&#x2F;一个函数  </span><br><span class=\"line\">aFunction.aProperty &#x3D; “Property of function”; &#x2F;&#x2F;函数的一个属性  </span><br><span class=\"line\">aFunction.aMethod &#x3D; function()&#123;alert(”Method of function”)&#125;; &#x2F;&#x2F;函数的一个方法  </span><br><span class=\"line\">&#x2F;&#x2F;主要看下面：</span><br><span class=\"line\">alert(aFunction[”aProperty”]); &#x2F;&#x2F;可以将函数当数组以属性名作为下标来访问属性  </span><br><span class=\"line\">&#96;aFunction[”aMethod”]()&#96;; &#x2F;&#x2F;可以将函数当数组以方法名作为下标来调用方法  </span><br><span class=\"line\">for( var s in aFunction) &#x2F;&#x2F;遍历函数的所有属性和方法进行迭代化处理  </span><br><span class=\"line\">alert(s + ” is a ” + typeof(aFunction[s]));</span><br></pre></td></tr></table></figure><br>是的，对象和函数可以象数组一样，用属性名或方法名作为下标来访问并处理。那么，它到底应该算是数组呢，还是算对象？</p>\n<p>我们知道，数组应该算是线性数据结构，线性数据结构一般有一定的规律，适合进行统一的批量迭代操作等，有点像波。而对象是离散数据结构，适合描述分散的和个性化的东西，有点像粒子。因此，我们也可以这样问：JavaScript里的对象到底是波还是粒子？</p>\n<p>如果存在对象量子论，那么答案一定是：波粒二象性！</p>\n<p>因此，JavaScript里的函数和对象既有对象的特征也有数组的特征。这里的数组被称为“字典”，一种可以任意伸缩的名称值对儿的集合。其实， object和function的内部实现就是一个字典结构，但这种字典结构却通过严谨而精巧的语法表现出了丰富的外观。正如量子力学在一些地方用粒子来解释和处理问题，而在另一些地方却用波来解释和处理问题。你也可以在需要的时候，自由选择用对象还是数组来解释和处理问题。只要善于把握 JavaScript的这些奇妙特性，就可以编写出很多简洁而强大的代码来。</p>\n<h4 id=\"放下对象\"><a href=\"#放下对象\" class=\"headerlink\" title=\"放下对象\"></a>放下对象</h4><p>我们再来看看function与object的超然结合吧。</p>\n<p>在面向对象的编程世界里，数据与代码的有机结合就构成了对象的概念。自从有了对象，编程世界就被划分成两部分，一个是对象内的世界，一个是对象外的世界。对象天生具有自私的一面，外面的世界未经允许是不可访问对象内部的。对象也有大方的一面，它对外提供属性和方法，也为他人服务。不过，在这里我们要谈到一个有趣的问题，就是“对象的自我意识”。</p>\n<p>什么？没听错吧？对象有自我意识？</p>\n<p>可能对许多程序员来说，这的确是第一次听说。不过，请君看看C++、C#和Java的this，DELPHI的self，还有VB的me，或许你会恍然大悟！当然，也可能只是说句“不过如此”而已。</p>\n<p>然而，就在对象将世界划分为内外两部分的同时，对象的“自我”也就随之产生。“自我意识”是生命的最基本特征！正是由于对象这种强大的生命力，才使得编程世界充满无限的生机和活力。</p>\n<p>但对象的“自我意识”在带给我们快乐的同时也带来了痛苦和烦恼。我们给对象赋予了太多欲望，总希望它们能做更多的事情。然而，对象的自私使得它们互相争抢系统资源，对象的自负让对象变得复杂和臃肿，对象的自欺也往往带来挥之不去的错误和异常。我们为什么会有这么多的痛苦和烦恼呢？</p>\n<p>为此，有一个人，在对象树下，整整想了九九八十一天，终于悟出了生命的痛苦来自于欲望，但究其欲望的根源是来自于自我意识。于是他放下了“自我”，在对象树下成了佛，从此他开始普度众生，传播真经。他的名字就叫释迦摩尼，而《JavaScript真经》正是他所传经书中的一本。</p>\n<p>JavaScript中也有this，但这个this却与C++、C#或Java等语言的this不同。一般编程语言的this就是对象自己，而 JavaScript的this却并不一定！this可能是我，也可能是你，可能是他，反正是我中有你，你中有我，这就不能用原来的那个“自我”来理解 JavaScript这个this的含义了。为此，我们必须首先放下原来对象的那个“自我”。</p>\n<p>我们来看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function WhoAmI() &#x2F;&#x2F;定义一个函数WhoAmI  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”I’m ” + this.name + ” of ” + typeof(this));  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">WhoAmI(); &#x2F;&#x2F;此时是this当前这段代码的全局对象，在浏览器中就是window对象，其name属性为空字符串。输出：I’m of object  </span><br><span class=\"line\">var BillGates &#x3D; &#123;name: “Bill Gates”&#125;;  </span><br><span class=\"line\">BillGates.WhoAmI &#x3D; WhoAmI; &#x2F;&#x2F;将函数WhoAmI作为BillGates的方法。  </span><br><span class=\"line\">BillGates.WhoAmI(); &#x2F;&#x2F;此时的this是BillGates。输出：I’m Bill Gates of object  </span><br><span class=\"line\">var SteveJobs &#x3D; &#123;name: “Steve Jobs”&#125;;  </span><br><span class=\"line\">SteveJobs.WhoAmI &#x3D; WhoAmI; &#x2F;&#x2F;将函数WhoAmI作为SteveJobs的方法。  </span><br><span class=\"line\">SteveJobs.WhoAmI(); &#x2F;&#x2F;此时的this是SteveJobs。输出：I’m Steve Jobs of object  </span><br><span class=\"line\">WhoAmI.call(BillGates); &#x2F;&#x2F;直接将BillGates作为this，调用WhoAmI。输出：I’m Bill Gates of object  </span><br><span class=\"line\">WhoAmI.call(SteveJobs); &#x2F;&#x2F;直接将SteveJobs作为this，调用WhoAmI。输出：I’m Steve Jobs of object  </span><br><span class=\"line\">BillGates.WhoAmI.call(SteveJobs); &#x2F;&#x2F;将SteveJobs作为this，却调用BillGates的WhoAmI方法。输出：I’m Steve Jobs of object  </span><br><span class=\"line\">SteveJobs.WhoAmI.call(BillGates); &#x2F;&#x2F;将BillGates作为this，却调用SteveJobs的WhoAmI方法。输出：I’m Bill Gates of object  </span><br><span class=\"line\">WhoAmI.WhoAmI &#x3D; WhoAmI; &#x2F;&#x2F;将WhoAmI函数设置为自身的方法。  </span><br><span class=\"line\">WhoAmI.name &#x3D; “WhoAmI”;  </span><br><span class=\"line\">WhoAmI.WhoAmI(); &#x2F;&#x2F;此时的this是WhoAmI函数自己。输出：I’m WhoAmI of function  </span><br><span class=\"line\">(&#123;name: “nobody”, WhoAmI: WhoAmI&#125;).WhoAmI(); &#x2F;&#x2F;临时创建一个匿名对象并设置属性后调用WhoAmI方法。输出：I’m nobody of object</span><br></pre></td></tr></table></figure><br>从上面的代码可以看出，同一个函数可以从不同的角度来调用，this并不一定是函数本身所属的对象。this只是在任意对象和function元素结合时的一个概念，是种结合比起一般对象语言的默认结合更加灵活，显得更加超然和洒脱。</p>\n<p>在JavaScript函数中，你只能把this看成当前要服务的“这个”对象。this是一个特殊的内置参数，根据this参数，您可以访问到“这个” 对象的属性和方法，但却不能给this参数赋值。在一般对象语言中，方法体代码中的this可以省略的，成员默认都首先是“自己”的。但 JavaScript却不同，由于不存在“自我”，当访问“这个”对象时，this不可省略！</p>\n<p>JavaScript提供了传递this参数的多种形式和手段，其中，象BillGates.WhoAmI()和SteveJobs.WhoAmI()这种形式，是传递this参数最正规的形式，此时的this就是函数所属的对象本身。而大多数情况下，我们也几乎很少去采用那些借花仙佛的调用形式。但只我们要明白JavaScript的这个“自我”与其他编程语言的“自我”是不同的，这是一个放下了的“自我”，这就是JavaScript特有的世界观。</p>\n<h4 id=\"对象素描\"><a href=\"#对象素描\" class=\"headerlink\" title=\"对象素描\"></a>对象素描</h4><p>已经说了许多了许多话题了，但有一个很基本的问题我们忘了讨论，那就是：怎样建立对象？</p>\n<p>在前面的示例中，我们已经涉及到了对象的建立了。我们使用了一种被称为JavaScript Object Notation(缩写JSON)的形式，翻译为中文就是“JavaScript对象表示法”。</p>\n<p>JSON为创建对象提供了非常简单的方法。例如，<br>创建一个没有任何属性的对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var o &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>创建一个对象并设置属性及初始值：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var person &#x3D; &#123;name: “Angel”, age: 18, married: false&#125;;</span><br></pre></td></tr></table></figure><br>创建一个对象并设置属性和方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var speaker &#x3D; &#123;text: “Hello World”, say: function()&#123;alert(this.text)&#125;&#125;;</span><br></pre></td></tr></table></figure><br>创建一个更复杂的对象，嵌套其他对象和对象数组等：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var company &#x3D;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">name: “Microsoft”,</span><br><span class=\"line\">product: “softwares”,</span><br><span class=\"line\">chairman: &#123;name: “Bill Gates”, age: 53, Married: true&#125;,</span><br><span class=\"line\">employees: [&#123;name: “Angel”, age: 26, Married: false&#125;, &#123;name: “Hanson”, age: 32, Marred: true&#125;],</span><br><span class=\"line\">readme: function() &#123;document.write(this.name + ” product ” + this.product);&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>JSON的形式就是用大括“{}”号包括起来的项目列表，每一个项目间并用逗号“,”分隔，而项目就是用冒号“:”分隔的属性名和属性值。这是典型的字典表示形式，也再次表明了 JavaScript里的对象就是字典结构。不管多么复杂的对象，都可以被一句JSON代码来创建并赋值。</p>\n<p>其实，JSON就是JavaScript对象最好的序列化形式，它比XML更简洁也更省空间。对象可以作为一个JSON形式的字符串，在网络间自由传递和交换信息。而当需要将这个JSON字符串变成一个JavaScript对象时，只需要使用eval函数这个强大的数码转换引擎，就立即能得到一个 JavaScript内存对象。正是由于JSON的这种简单朴素的天生丽质，才使得她在AJAX舞台上成为璀璨夺目的明星。</p>\n<p>JavaScript就是这样，把面向对象那些看似复杂的东西，用及其简洁的形式表达出来。卸下对象浮华的浓妆，还对象一个眉目清晰！</p>\n<h4 id=\"构造对象\"><a href=\"#构造对象\" class=\"headerlink\" title=\"构造对象\"></a>构造对象</h4><p>好了，接下我们来讨论一下对象的另一种创建方法。</p>\n<p>除JSON外，在JavaScript中我们可以使用new操作符结合一个函数的形式来创建对象。例如：<br>function MyFunc() {}; //定义一个空函数<br>var anObj = new MyFunc(); //使用new操作符，借助MyFun函数，就创建了一个对象</p>\n<p>JavaScript的这种创建对象的方式可真有意思，如何去理解这种写法呢？</p>\n<p>其实，可以把上面的代码改写成这种等价形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function MyFunc()&#123;&#125;;  </span><br><span class=\"line\">var anObj &#x3D; &#123;&#125;; &#x2F;&#x2F;创建一个对象  </span><br><span class=\"line\">MyFunc.call(anObj); &#x2F;&#x2F;将anObj对象作为this指针调用MyFunc函数</span><br></pre></td></tr></table></figure><br>我们就可以这样理解，JavaScript先用new操作符创建了一个对象，紧接着就将这个对象作为this参数调用了后面的函数。其实， JavaScript内部就是这么做的，而且任何函数都可以被这样调用！但从 “anObj = new MyFunc()” 这种形式，我们又看到一个熟悉的身影，C++和C#不就是这样创建对象的吗？原来，条条大路通灵山，殊途同归啊！</p>\n<p>君看到此处也许会想，我们为什么不可以把这个MyFunc当作构造函数呢？恭喜你，答对了！JavaScript也是这么想的！请看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(name) &#x2F;&#x2F;带参数的构造函数  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name; &#x2F;&#x2F;将参数值赋给给this对象的属性  </span><br><span class=\"line\">this.SayHello &#x3D; function() &#123;alert(”Hello, I’m ” + this.name);&#125;; &#x2F;&#x2F;给this对象定义一个SayHello方法。  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">function Employee(name, salary) &#x2F;&#x2F;子构造函数  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Person.call(this, name); &#x2F;&#x2F;将this传给父构造函数  </span><br><span class=\"line\">this.salary &#x3D; salary; &#x2F;&#x2F;设置一个this的salary属性  </span><br><span class=\"line\">this.ShowMeTheMoney &#x3D; function() &#123;alert(this.name + ” $” +   this.salary);&#125;; &#x2F;&#x2F;添加ShowMeTheMoney方法。  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;用Person构造函数创建BillGates对象  </span><br><span class=\"line\">var SteveJobs &#x3D; new Employee(”Steve Jobs”, 1234); &#x2F;&#x2F;用Empolyee构造函数创建SteveJobs对象  </span><br><span class=\"line\"></span><br><span class=\"line\">BillGates.SayHello(); &#x2F;&#x2F;显示：I’m Bill Gates  </span><br><span class=\"line\">SteveJobs.SayHello(); &#x2F;&#x2F;显示：I’m Steve Jobs  </span><br><span class=\"line\">SteveJobs.ShowMeTheMoney(); &#x2F;&#x2F;显示：Steve Jobs $1234  </span><br><span class=\"line\"></span><br><span class=\"line\">alert(BillGates.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;显示：true  </span><br><span class=\"line\">alert(SteveJobs.constructor &#x3D;&#x3D; Employee); &#x2F;&#x2F;显示：true  </span><br><span class=\"line\">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：false</span><br></pre></td></tr></table></figure><br>这段代码表明，函数不但可以当作构造函数，而且还可以带参数，还可以为对象添加成员和方法。其中的第9行，Employee构造函数又将自己接收的 this作为参数调用Person构造函数，这就是相当于调用基类的构造函数。第21、22行还表明这样一个意思：BillGates是由Person构造的，而SteveJobs是由Employee构造的。对象内置的constructor属性还指明了构造对象所用的具体函数！</p>\n<p>其实，如果你愿意把函数当作“类”的话，她就是“类”，因为她本来就有“类”的那些特征。难道不是吗？她生出的儿子各个都有相同的特征，而且构造函数也与类同名嘛！</p>\n<p>但要注意的是，用构造函数操作this对象创建出来的每一个对象，不但具有各自的成员数据，而且还具有各自的方法数据。换句话说，方法的代码体(体现函数逻辑的数据)在每一个对象中都存在一个副本。尽管每一个代码副本的逻辑是相同的，但对象们确实是各自保存了一份代码体。上例中的最后一句说明了这一实事，这也解释了JavaScript中的函数就是对象的概念。</p>\n<p>同一类的对象各自有一份方法代码显然是一种浪费。在传统的对象语言中，方法函数并不象JavaScript那样是个对象概念。即使也有象函数指针、方法指针或委托那样的变化形式，但其实质也是对同一份代码的引用。一般的对象语言很难遇到这种情况。</p>\n<p>不过，JavaScript语言有大的灵活性。我们可以先定义一份唯一的方法函数体，并在构造this对象时使用这唯一的函数对象作为其方法，就能共享方法逻辑。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function SayHello() &#x2F;&#x2F;先定义一份SayHello函数代码  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">function Person(name) &#x2F;&#x2F;带参数的构造函数  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name; &#x2F;&#x2F;将参数值赋给给this对象的属性  </span><br><span class=\"line\">this.SayHello &#x3D; SayHello; &#x2F;&#x2F;给this对象SayHello方法赋值为前面那份SayHello代码。</span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;创建BillGates对象  </span><br><span class=\"line\">var SteveJobs &#x3D; new Person(”Steve Jobs”); &#x2F;&#x2F;创建SteveJobs对象  </span><br><span class=\"line\">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：true</span><br></pre></td></tr></table></figure><br>其中，最后一行的输出结果表明两个对象确实共享了一个函数对象。虽然，这段程序达到了共享了一份方法代码的目的，但却不怎么优雅。因为，定义 SayHello方法时反映不出其与Person类的关系。“优雅”这个词用来形容代码，也不知道是谁先提出来的。不过，这个词反映了程序员已经从追求代码的正确、高效、可靠和易读等基础上，向着追求代码的美观感觉和艺术境界的层次发展，程序人生又多了些浪漫色彩。</p>\n<p>显然，JavaScript早想到了这一问题，她的设计者们为此提供了一个有趣的prototype概念。</p>\n<h4 id=\"初看原型\"><a href=\"#初看原型\" class=\"headerlink\" title=\"初看原型\"></a>初看原型</h4><p>prototype源自法语，软件界的标准翻译为“原型”，代表事物的初始形态，也含有模型和样板的意义。JavaScript中的prototype概念恰如其分地反映了这个词的内含，我们不能将其理解为C++的prototype那种预先声明的概念。</p>\n<p>JavaScript的所有function类型的对象都有一个prototype属性。这个prototype属性本身又是一个object类型的对象，因此我们也可以给这个prototype对象添加任意的属性和方法。既然prototype是对象的“原型”，那么由该函数构造出来的对象应该都会具有这个“原型”的特性。事实上，在构造函数的prototype上定义的所有属性和方法，都是可以通过其构造的对象直接访问和调用的。也可以这么说， prototype提供了一群同类对象共享属性和方法的机制。</p>\n<p>我们先来看看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(name)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name; &#x2F;&#x2F;设置对象属性，每个对象各自一份属性数据  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;给Person函数的prototype添加SayHello方法。  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;创建BillGates对象  </span><br><span class=\"line\">var SteveJobs &#x3D; new Person(”Steve Jobs”); &#x2F;&#x2F;创建SteveJobs对象</span><br><span class=\"line\"></span><br><span class=\"line\">BillGates.SayHello(); &#x2F;&#x2F;通过BillGates对象直接调用到SayHello方法  </span><br><span class=\"line\">SteveJobs.SayHello(); &#x2F;&#x2F;通过SteveJobs对象直接调用到SayHello方法</span><br><span class=\"line\"></span><br><span class=\"line\">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;因为两个对象是共享prototype的SayHello，所以显示：true</span><br></pre></td></tr></table></figure><br>程序运行的结果表明，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。显然，把方法设置到prototype的写法显得优雅多了，尽管调用形式没有变，但逻辑上却体现了方法与类的关系，相对前面的写法，更容易理解和组织代码。</p>\n<p>那么，对于多层次类型的构造函数情况又如何呢？</p>\n<p>我们再来看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(name) &#x2F;&#x2F;基类构造函数  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name;  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;给基类构造函数的prototype添加方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">function Employee(name, salary) &#x2F;&#x2F;子类构造函数  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Person.call(this, name); &#x2F;&#x2F;调用基类构造函数  </span><br><span class=\"line\">this.salary &#x3D; salary;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">Employee.prototype &#x3D; new Person(); &#x2F;&#x2F;建一个基类的对象作为子类原型的原型，这里很有意思</span><br><span class=\"line\"></span><br><span class=\"line\">Employee.prototype.ShowMeTheMoney &#x3D; function() &#x2F;&#x2F;给子类添构造函数的prototype添加方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(this.name + ” $” + this.salary);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;创建基类Person的BillGates对象  </span><br><span class=\"line\">var SteveJobs &#x3D; new Employee(”Steve Jobs”, 1234); &#x2F;&#x2F;创建子类Employee的SteveJobs对象</span><br><span class=\"line\"></span><br><span class=\"line\">BillGates.SayHello(); &#x2F;&#x2F;通过对象直接调用到prototype的方法    SteveJobs.SayHello(); &#x2F;&#x2F;通过子类对象直接调用基类prototype的方法，关注！  </span><br><span class=\"line\">SteveJobs.ShowMeTheMoney(); &#x2F;&#x2F;通过子类对象直接调用子类prototype的方法  </span><br><span class=\"line\"></span><br><span class=\"line\">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：true，表明prototype的方法是共享的</span><br></pre></td></tr></table></figure><br>这段代码的第17行，构造了一个基类的对象，并将其设为子类构造函数的prototype，这是很有意思的。这样做的目的就是为了第28行，通过子类对象也可以直接调用基类prototype的方法。为什么可以这样呢？</p>\n<p>原来，在JavaScript中，prototype不但能让对象共享自己财富，而且prototype还有寻根问祖的天性，从而使得先辈们的遗产可以代代相传。当从一个对象那里读取属性或调用方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找；如果 prototype没有，又会去prototype自己关联的前辈prototype那里寻找，直到找到或追溯过程结束为止。</p>\n<p>在JavaScript内部，对象的属性和方法追溯机制是通过所谓的prototype链来实现的。当用new操作符构造对象时，也会同时将构造函数的 prototype对象指派给新创建的对象，成为该对象内置的原型对象。对象内置的原型对象应该是对外不可见的，尽管有些浏览器(如Firefox)可以让我们访问这个内置原型对象，但并不建议这样做。内置的原型对象本身也是对象，也有自己关联的原型对象，这样就形成了所谓的原型链。</p>\n<p>在原型链的最末端，就是Object构造函数prototype属性指向的那一个原型对象。这个原型对象是所有对象的最老祖先，这个老祖宗实现了诸如 toString等所有对象天生就该具有的方法。其他内置构造函数，如Function, Boolean, String, Date和RegExp等的prototype都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些特征。</p>\n<p>这不就是“继承”吗？是的，这就是“继承”，是JavaScript特有的“原型继承”。</p>\n<p>“原型继承”是慈祥而又严厉的。原形对象将自己的属性和方法无私地贡献给孩子们使用，也并不强迫孩子们必须遵从，允许一些顽皮孩子按自己的兴趣和爱好独立行事。从这点上看，原型对象是一位慈祥的母亲。然而，任何一个孩子虽然可以我行我素，但却不能动原型对象既有的财产，因为那可能会影响到其他孩子的利益。从这一点上看，原型对象又象一位严厉的父亲。我们来看看下面的代码就可以理解这个意思了：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(name)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.company &#x3D; “Microsoft”; &#x2F;&#x2F;原型的属性  </span><br><span class=\"line\">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;原型的方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name + ” of ” + this.company);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill Gates”);  </span><br><span class=\"line\">BillGates.SayHello(); &#x2F;&#x2F;由于继承了原型的东西，规规矩矩输出：Hello, I’m Bill Gates</span><br><span class=\"line\"></span><br><span class=\"line\">var SteveJobs &#x3D; new Person(”Steve Jobs”);  </span><br><span class=\"line\">SteveJobs.company &#x3D; “Apple”; &#x2F;&#x2F;设置自己的company属性，掩盖了原型的company属性  </span><br><span class=\"line\">SteveJobs.SayHello &#x3D; function() &#x2F;&#x2F;实现了自己的SayHello方法，掩盖了原型的SayHello方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hi, ” + this.name + ” like ” + this.company + “, ha ha ha “);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">SteveJobs.SayHello(); &#x2F;&#x2F;都是自己覆盖的属性和方法，输出：Hi, Steve Jobs like Apple, ha ha ha  </span><br><span class=\"line\"></span><br><span class=\"line\">BillGates.SayHello(); &#x2F;&#x2F;SteveJobs的覆盖没有影响原型对象，BillGates还是按老样子输出</span><br></pre></td></tr></table></figure><br>对象可以掩盖原型对象的那些属性和方法，一个构造函数原型对象也可以掩盖上层构造函数原型对象既有的属性和方法。这种掩盖其实只是在对象自己身上创建了新的属性和方法，只不过这些属性和方法与原型对象的那些同名而已。JavaScript就是用这简单的掩盖机制实现了对象的“多态”性，与静态对象语言的虚函数和重载(override)概念不谋而合。</p>\n<p>然而，比静态对象语言更神奇的是，我们可以随时给原型对象动态添加新的属性和方法，从而动态地扩展基类的功能特性。这在静态对象语言中是很难想象的。我们来看下面的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(name)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;建立对象前定义的方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;建立对象  </span><br><span class=\"line\"></span><br><span class=\"line\">BillGates.SayHello();</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.Retire &#x3D; function() &#x2F;&#x2F;建立对象后再动态扩展原型的方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Poor ” + this.name + “, bye bye!”);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">BillGates.Retire(); &#x2F;&#x2F;动态扩展的方法即可被先前建立的对象立即调用</span><br></pre></td></tr></table></figure><br>阿弥佗佛，原型继承竟然可以玩出有这样的法术！</p>\n<h4 id=\"原型扩展\"><a href=\"#原型扩展\" class=\"headerlink\" title=\"原型扩展\"></a>原型扩展</h4><p>想必君的悟性极高，可能你会这样想：如果在JavaScript内置的那些如Object和Function等函数的prototype上添加些新的方法和属性，是不是就能扩展JavaScript的功能呢？</p>\n<p>那么，恭喜你，你得到了！</p>\n<p>在AJAX技术迅猛发展的今天，许多成功的AJAX项目的JavaScript运行库都大量扩展了内置函数的prototype功能。比如微软的 ASP.NET AJAX，就给这些内置函数及其prototype添加了大量的新特性，从而增强了JavaScript的功能。</p>\n<p>我们来看一段摘自MicrosoftAjax.debug.js中的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">String.prototype.trim &#x3D; function String$trim() &#123;  </span><br><span class=\"line\">if (arguments.length !&#x3D;&#x3D; 0) throw Error.parameterCount();  </span><br><span class=\"line\">return this.replace(&#x2F;^\\s+|\\s+$&#x2F;g, ”);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这段代码就是给内置String函数的prototype扩展了一个trim方法，于是所有的String类对象都有了trim方法了。有了这个扩展，今后要去除字符串两段的空白，就不用再分别处理了，因为任何字符串都有了这个扩展功能，只要调用即可，真的很方便。</p>\n<p>当然，几乎很少有人去给Object的prototype添加方法，因为那会影响到所有的对象，除非在你的架构中这种方法的确是所有对象都需要的。</p>\n<p>前两年，微软在设计AJAX类库的初期，用了一种被称为“闭包”(closure)的技术来模拟“类”。其大致模型如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Person(firstName, lastName, age)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">&#x2F;&#x2F;私有变量：  </span><br><span class=\"line\">var &#96;_firstName&#96; &#x3D; firstName;  </span><br><span class=\"line\">var &#96;_lastName&#96; &#x3D; lastName;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;公共变量:  </span><br><span class=\"line\">this.age &#x3D; age;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;方法：  </span><br><span class=\"line\">this.getName &#x3D; function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">return(firstName + ” ” + lastName);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">this.SayHello &#x3D; function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + firstName + ” ” + lastName);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill”, “Gates”, 53);  </span><br><span class=\"line\">var SteveJobs &#x3D; new Person(”Steve”, “Jobs”, 53);  </span><br><span class=\"line\"></span><br><span class=\"line\">BillGates.SayHello();  </span><br><span class=\"line\">SteveJobs.SayHello();  </span><br><span class=\"line\">alert(BillGates.getName() + ” ” + BillGates.age);  </span><br><span class=\"line\">alert(BillGates.firstName); &#x2F;&#x2F;这里不能访问到私有变量</span><br></pre></td></tr></table></figure><br>很显然，这种模型的类描述特别象C#语言的描述形式，在一个构造函数里依次定义了私有成员、公共属性和可用的方法，显得非常优雅嘛。特别是“闭包”机制可以模拟对私有成员的保护机制，做得非常漂亮。</p>\n<p>所谓的“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层外层函数体中的临时变量。这使得只要目标对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新的值，和上次那次调用的是各自独立的。的确很巧妙！</p>\n<p>但是前面我们说过，给每一个对象设置一份方法是一种很大的浪费。还有，“闭包”这种间接保持变量值的机制，往往会给JavaSript的垃圾回收器制造难题。特别是遇到对象间复杂的循环引用时，垃圾回收的判断逻辑非常复杂。无独有偶，IE浏览器早期版本确实存在JavaSript垃圾回收方面的内存泄漏问题。再加上“闭包”模型在性能测试方面的表现不佳，微软最终放弃了“闭包”模型，而改用“原型”模型。正所谓“有得必有失”嘛。</p>\n<p>原型模型需要一个构造函数来定义对象的成员，而方法却依附在该构造函数的原型上。大致写法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;定义构造函数  </span><br><span class=\"line\">function Person(name)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name; &#x2F;&#x2F;在构造函数中定义成员  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">&#x2F;&#x2F;方法定义到构造函数的prototype上  </span><br><span class=\"line\">Person.prototype.SayHello &#x3D; function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;子类构造函数  </span><br><span class=\"line\">function Employee(name, salary)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Person.call(this, name); &#x2F;&#x2F;调用上层构造函数  </span><br><span class=\"line\">this.salary &#x3D; salary; &#x2F;&#x2F;扩展的成员  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;子类构造函数首先需要用上层构造函数来建立prototype对象，实现继承的概念  </span><br><span class=\"line\">Employee.prototype &#x3D; new Person() &#x2F;&#x2F;只需要其prototype的方法，此对象的成员没有任何意义！</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;子类方法也定义到构造函数之上  </span><br><span class=\"line\">Employee.prototype.ShowMeTheMoney &#x3D; function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(this.name + ” $” + this.salary);  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; new Person(”Bill Gates”);  </span><br><span class=\"line\">BillGates.SayHello();  </span><br><span class=\"line\"></span><br><span class=\"line\">var SteveJobs &#x3D; new Employee(”Steve Jobs”, 1234);  </span><br><span class=\"line\">SteveJobs.SayHello();  </span><br><span class=\"line\">SteveJobs.ShowMeTheMoney();</span><br></pre></td></tr></table></figure><br>原型类模型虽然不能模拟真正的私有变量，而且也要分两部分来定义类，显得不怎么“优雅”。不过，对象间的方法是共享的，不会遇到垃圾回收问题，而且性能优于“闭包”模型。正所谓“有失必有得”嘛。</p>\n<p>在原型模型中，为了实现类继承，必须首先将子类构造函数的prototype设置为一个父类的对象实例。创建这个父类对象实例的目的就是为了构成原型链，以起到共享上层原型方法作用。但创建这个实例对象时，上层构造函数也会给它设置对象成员，这些对象成员对于继承来说是没有意义的。虽然，我们也没有给构造函数传递参数，但确实创建了若干没有用的成员，尽管其值是undefined，这也是一种浪费啊。</p>\n<p>唉！世界上没有完美的事情啊！</p>\n<h4 id=\"原型真谛\"><a href=\"#原型真谛\" class=\"headerlink\" title=\"原型真谛\"></a>原型真谛</h4><p>正当我们感概万分时，天空中一道红光闪过，祥云中出现了观音菩萨。只见她手持玉净瓶，轻拂翠柳枝，洒下几滴甘露，顿时让JavaScript又添新的灵气。</p>\n<p>观音洒下的甘露在JavaScript的世界里凝结成块，成为了一种称为“语法甘露”的东西。这种语法甘露可以让我们编写的代码看起来更象对象语言。</p>\n<p>要想知道这“语法甘露”为何物，就请君侧耳细听。</p>\n<p>在理解这些语法甘露之前，我们需要重新再回顾一下JavaScript构造对象的过程。</p>\n<p>我们已经知道，用 var anObject = new aFunction() 形式创建对象的过程实际上可以分为三步：第一步是建立一个新对象；第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象；第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。对象建立之后，对象上的任何访问和操作都只与对象自身及其原型链上的那串对象有关，与构造函数再扯不上关系了。换句话说，构造函数只是在创建对象时起到介绍原型对象和初始化对象两个作用。</p>\n<p>那么，我们能否自己定义一个对象来当作原型，并在这个原型上描述类，然后将这个原型设置给新创建的对象，将其当作对象的类呢？我们又能否将这个原型中的一个方法当作构造函数，去初始化新建的对象呢？例如，我们定义这样一个原型对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var Person &#x3D; &#x2F;&#x2F;定义一个对象来作为原型类  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Create: function(name, age) &#x2F;&#x2F;这个当构造函数  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name;  </span><br><span class=\"line\">this.age &#x3D; age;  </span><br><span class=\"line\">&#125;,  </span><br><span class=\"line\">SayHello: function() &#x2F;&#x2F;定义方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name);  </span><br><span class=\"line\">&#125;,  </span><br><span class=\"line\">HowOld: function() &#x2F;&#x2F;定义方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(this.name + ” is ” + this.age + ” years old.”);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>这个JSON形式的写法多么象一个C#的类啊！既有构造函数，又有各种方法。如果可以用某种形式来创建对象，并将对象的内置的原型设置为上面这个“类”对象，不就相当于创建该类的对象了吗？</p>\n<p>但遗憾的是，我们几乎不能访问到对象内置的原型属性！尽管有些浏览器可以访问到对象的内置原型，但这样做的话就只能限定了用户必须使用那种浏览器。这也几乎不可行。</p>\n<p>那么，我们可不可以通过一个函数对象来做媒介，利用该函数对象的prototype属性来中转这个原型，并用new操作符传递给新建的对象呢？</p>\n<p>其实，象这样的代码就可以实现这一目标：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function anyfunc()&#123;&#125;; &#x2F;&#x2F;定义一个函数躯壳  </span><br><span class=\"line\">anyfunc.prototype &#x3D; Person; &#x2F;&#x2F;将原型对象放到中转站prototype  </span><br><span class=\"line\">var BillGates &#x3D; new anyfunc(); &#x2F;&#x2F;新建对象的内置原型将是我们期望的原型对象</span><br></pre></td></tr></table></figure><br>不过，这个anyfunc函数只是一个躯壳，在使用过这个躯壳之后它就成了多余的东西了，而且这和直接使用构造函数来创建对象也没啥不同，有点不爽。</p>\n<p>可是，如果我们将这些代码写成一个通用函数，而那个函数躯壳也就成了函数内的函数，这个内部函数不就可以在外层函数退出作用域后自动消亡吗？而且，我们可以将原型对象作为通用函数的参数，让通用函数返回创建的对象。我们需要的就是下面这个形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function New(aClass, aParams) &#x2F;&#x2F;通用创建函数  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">function new_() &#x2F;&#x2F;定义临时的中转函数壳   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">aClass.Create.apply(this, aParams); &#x2F;&#x2F;调用原型中定义的的构造函数，中转构造逻辑及构造参数  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">new_.prototype &#x3D; aClass; &#x2F;&#x2F;准备中转原型对象  </span><br><span class=\"line\">return new new_(); &#x2F;&#x2F;返回建立最终建立的对象  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var Person &#x3D; &#x2F;&#x2F;定义的类  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Create: function(name, age)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name;  </span><br><span class=\"line\">this.age &#x3D; age;  </span><br><span class=\"line\">&#125;,  </span><br><span class=\"line\">SayHello: function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name);  </span><br><span class=\"line\">&#125;,  </span><br><span class=\"line\">HowOld: function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(this.name + ” is ” + this.age + ” years old.”);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; New(Person, [”Bill Gates”, 53]); &#x2F;&#x2F;调用通用函数创建对象，并以数组形式传递构造参数  </span><br><span class=\"line\">BillGates.SayHello();  </span><br><span class=\"line\">BillGates.HowOld();  </span><br><span class=\"line\"></span><br><span class=\"line\">alert(BillGates.constructor &#x3D;&#x3D; Object); &#x2F;&#x2F;输出：true</span><br></pre></td></tr></table></figure><br>这里的通用函数New()就是一个“语法甘露”！这个语法甘露不但中转了原型对象，还中转了构造函数逻辑及构造参数。</p>\n<p>有趣的是，每次创建完对象退出New函数作用域时，临时的new<em>函数对象会被自动释放。由于new</em>的prototype属性被设置为新的原型对象，其原来的原型对象和new_之间就已解开了引用链，临时函数及其原来的原型对象都会被正确回收了。上面代码的最后一句证明，新创建的对象的 constructor属性返回的是Object函数。其实新建的对象自己及其原型里没有constructor属性，那返回的只是最顶层原型对象的构造函数，即Object。</p>\n<p>有了New这个语法甘露，类的定义就很像C#那些静态对象语言的形式了，这样的代码显得多么文静而优雅啊！</p>\n<p>当然，这个代码仅仅展示了“语法甘露”的概念。我们还需要多一些的语法甘露，才能实现用简洁而优雅的代码书写类层次及其继承关系。好了，我们再来看一个更丰富的示例吧：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;语法甘露：  </span><br><span class=\"line\">var object &#x3D; &#x2F;&#x2F;定义小写的object基本类，用于实现最基础的方法等  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">isA: function(aType) &#x2F;&#x2F;一个判断类与类之间以及对象与类之间关系的基础方法  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">var self &#x3D; this;  </span><br><span class=\"line\">while(self)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">if (self &#x3D;&#x3D; aType)  </span><br><span class=\"line\">return true;  </span><br><span class=\"line\">self &#x3D; self.Type;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">return false;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">function Class(aBaseClass, aClassDefine) &#x2F;&#x2F;创建类的函数，用于声明类及继承关系  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">function class_() &#x2F;&#x2F;创建类的临时函数壳  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.Type &#x3D; aBaseClass; &#x2F;&#x2F;我们给每一个类约定一个Type属性，引用其继承的类  </span><br><span class=\"line\">for(var member in aClassDefine)  </span><br><span class=\"line\">this[member] &#x3D; aClassDefine[member]; &#x2F;&#x2F;复制类的全部定义到当前创建的类  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">class_.prototype &#x3D; aBaseClass;  </span><br><span class=\"line\">return new class_();  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">function New(aClass, aParams) &#x2F;&#x2F;创建对象的函数，用于任意类的对象创建  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">function new_() &#x2F;&#x2F;创建对象的临时函数壳  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.Type &#x3D; aClass; &#x2F;&#x2F;我们也给每一个对象约定一个Type属性，据此可以访问到对象所属的类  </span><br><span class=\"line\">if (aClass.Create)  </span><br><span class=\"line\">aClass.Create.apply(this, aParams); &#x2F;&#x2F;我们约定所有类的构造函数都叫Create，这和DELPHI比较相似  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">new_.prototype &#x3D; aClass;  </span><br><span class=\"line\">return new new_();  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;语法甘露的应用效果：  </span><br><span class=\"line\">var Person &#x3D; Class(object, &#x2F;&#x2F;派生至object基本类  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Create: function(name, age)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">this.name &#x3D; name;  </span><br><span class=\"line\">this.age &#x3D; age;  </span><br><span class=\"line\">&#125;,  </span><br><span class=\"line\">SayHello: function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(”Hello, I’m ” + this.name + “, ” + this.age + ” years old.”);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"></span><br><span class=\"line\">var Employee &#x3D; Class(Person, &#x2F;&#x2F;派生至Person类，是不是和一般对象语言很相似？  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Create: function(name, age, salary)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">Person.Create.call(this, name, age); &#x2F;&#x2F;调用基类的构造函数  </span><br><span class=\"line\">this.salary &#x3D; salary;  </span><br><span class=\"line\">&#125;,  </span><br><span class=\"line\">ShowMeTheMoney: function()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">alert(this.name + ” $” + this.salary);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"></span><br><span class=\"line\">var BillGates &#x3D; New(Person, [”Bill Gates”, 53]);  </span><br><span class=\"line\">var SteveJobs &#x3D; New(Employee, [”Steve Jobs”, 53, 1234]);  </span><br><span class=\"line\">BillGates.SayHello();  </span><br><span class=\"line\">SteveJobs.SayHello();  </span><br><span class=\"line\">SteveJobs.ShowMeTheMoney();  </span><br><span class=\"line\"></span><br><span class=\"line\">var LittleBill &#x3D; New(BillGates.Type, [”Little Bill”, 6]); &#x2F;&#x2F;根据BillGate的类型创建LittleBill  </span><br><span class=\"line\">LittleBill.SayHello();  </span><br><span class=\"line\"></span><br><span class=\"line\">alert(BillGates.isA(Person)); &#x2F;&#x2F;true  </span><br><span class=\"line\">alert(BillGates.isA(Employee)); &#x2F;&#x2F;false  </span><br><span class=\"line\">alert(SteveJobs.isA(Person)); &#x2F;&#x2F;true  </span><br><span class=\"line\">alert(Person.isA(Employee)); &#x2F;&#x2F;false  </span><br><span class=\"line\">alert(Employee.isA(Person)); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><br>“语法甘露”不用太多，只要那么一点点，就能改观整个代码的易读性和流畅性，从而让代码显得更优雅。有了这些语法甘露，JavaScript就很像一般对象语言了，写起代码了感觉也就爽多了！  </p>\n<p>令人高兴的是，受这些甘露滋养的JavaScript程序效率会更高。因为其原型对象里既没有了毫无用处的那些对象级的成员，而且还不存在 constructor属性体，少了与构造函数间的牵连，但依旧保持了方法的共享性。这让JavaScript在追溯原型链和搜索属性及方法时，少费许多工夫啊。</p>\n<p>我们就把这种形式称为“甘露模型”吧！其实，这种“甘露模型”的原型用法才是符合prototype概念的本意，才是的JavaScript原型的真谛！</p>\n<p>想必微软那些设计AJAX架构的工程师看到这个甘露模型时，肯定后悔没有早点把AJAX部门从美国搬到咱中国的观音庙来，错过了观音菩萨的点化。当然，我们也只能是在代码的示例中，把Bill Gates当作对象玩玩，真要让他放弃上帝转而皈依我佛肯定是不容易的，机缘未到啊！如果哪天你在微软新出的AJAX类库中看到这种甘露模型，那才是真正的缘分！</p>\n","categories":["javascript"],"tags":["note","javascript"]},{"title":"《投资中最重要的事》书摘","url":"/2019/10/30/read/the-most-important-thing/","content":"<p>真正的高手，都有自己的一整套知识体系，这一整套体系就如同长在他们大脑中的一棵不断生长的树，或者是一张随时可以变得更大更复杂的网，等新知识进来，就知道该把它放到什么位置上，这套体系被很多人称为“心智模式”。本文来聊聊读书笔记的重要性以及《投资中最重要的事》书中所有的亮点。<br><a id=\"more\"></a></p>\n<p>知识体系，可以让你灵活快速地运用已有的知识来应对复杂多变的外部问题。在学习和阅读的过程中形成知识体系的最有效的方法，就是记笔记；这也是很多牛人读书的一个共同特点。曾国藩的读书方法中，其中有一条就是“不动笔，不看书。”钱钟书家里基本不藏书，再好的书也是看完就随手送人。但他读书几乎必做笔记，读书笔记永远保留，随时拿出来用。他做笔记的时间，大概是读这本书的时间的一倍（现在有电子书和印象笔记，可以省很多时间）。</p>\n<p>达·芬奇的笔记本虽然杂乱无章，却是他精妙思想的来源；由于他想法太多，所以笔记根本来不及整理，有人说如果他整理了，整个世界的科技可以进步三十年。这里所说的读书笔记，并不是我们上学时原原本本抄写老师在黑板上写的那种，也不是网上很多人用“思维导图”做的那种读书笔记，这些都没有什么用处。真正好的笔记不仅仅是对客观事实的记录，更是对自己思想的记录。</p>\n<p>什么是好的读书笔记。人的大脑机能就像计算机的内存一样，容量小而且是稀缺资源，只能用来做最重要的工作——思考；而笔记就好像计算机的硬盘，负责存储和记忆，需要的时候不用翻书，直接拿来用就可以了。对于这些牛人来说，笔记就是他们大脑的延伸，所以，一份好的读书笔记，要做到尽可能取代原书的地步，至少应包括以下4个方面的内容：</p>\n<ul>\n<li><p>清晰地表现每一章的逻辑脉络。笔记最好和书中的结构保持一致，按章节记录，并保留书中的标题。看完一章后，用自己的语言记录下这一部分所讲的主要内容，重要的是一定要表现出作者的思路和逻辑脉络。很多人看书只会记住一些结论性的东西，如果只是把这些结论单拿出来看，而忽略上下文的关联，每个人都可能有不同的解读，以至于曲解作者本来的用意，造成只见树木，不见森林的结果。就像人们经常在引用《论语》中“父母在，不远游”的句子时，往往不知道后面还有一句“游必有方”。要让一本书由厚变薄，要把具体的景色抽象为地图，只有当你跳出书中的具体内容，以居高临下的姿态俯瞰全书，才能把握它的整体结构和脉络。</p>\n</li>\n<li><p>带走书中的所有亮点。在kindle上看书的时候，上面会显示其他读过这本书的人所做过的标记，我发现一个规律，大多数人都是像小学生划重点句子一样只在文章的第一句或最后一句做标记。高手们从来不是这种读法，除了很明显的重要内容之外，他们还会拿走书中的所有“亮点”，比如一个能让人醍醐灌顶的小故事，令人拍案叫绝的句式，一语警醒梦中人的箴言典故等等。分析脉络的时候要忽略细节，分析完脉络要把细节中所有能启发思维的“亮点”全部带走。</p>\n</li>\n<li><p>要记录下自己的想法和灵感。藏书人认为让书干净最重要，所以他们只买书不看书，初级读者喜欢在书中划线，而高水平的读者会在书中写满了批注。据说人们一般都不爱把书借给毛泽东看，因为他看过之后，别人就没法看了，书的字里行间密密麻麻全都是他的批注。</p>\n</li>\n</ul>\n<p>一本好书总是能不断激发你的灵感，可以是来自你对书中内容的理解，也可以是你自己独特的看法和心得，这些想法不见得现在就能用上，但都非常宝贵，所以你最好马上记下来，否则很快就会忘记。等若干年之后回过头来再看，对这些灵感的记录可能比原书更有价值。</p>\n<ul>\n<li>找出并记录下这本书和你以前读过的其他书籍或文章的联系。没有任何知识是可以脱离其他知识而独立存在的，新知识往往也是建立在已有知识的基础之上，当你读书读到一定程度，你会发现同一个内容会在很多不同的著作和文章里出现，彼此之间有关联，只是叙述的观点和角度有所不同。</li>\n</ul>\n<p>我送给大家读书的三个心法：</p>\n<ul>\n<li><p>一本书最好能读两遍。第一遍以最自然的状态去读，体验作者的精妙思想，享受读书的乐趣；在读第二遍的时候开始记笔记，读一章记一次笔记，笔记写完，这本书就可以送人了。第一遍是为了陷进去，第二遍是为了跳出来。</p>\n</li>\n<li><p>要想有收获，先要有态度。也许你觉得这样读书会非常累，一点都不享受。累与不累取决于你读书的目的是什么，如果你只是为了娱乐或者修身养性，随便怎么读都行；可要想学知识，还真得拿出点严谨的学术态度，毕竟学习是一件很正经的事儿。</p>\n</li>\n<li><p>以我为主，而不是以书为主。世界上值得反复阅读的书不超过一百本，大部分的书只要把有用的东西挑出来就可以扔了。那些能让书籍为我所用的人，才是真正的精神贵族。</p>\n</li>\n</ul>\n<p>阅读这个习惯，我已经维持了十多年，而且今后也会一直维持下去。从初中开始就特别喜欢阅读，但那时候看的都是一些课外书，诸如历史故事，小说之类的书，真正接触投资书籍是在大学，每读一本书，我都要拿出大量的时间做笔记。因此，到目前为止我积累了数以百万字的读书笔记，每一本书做完笔记之后我都会将这本书送人或者束之高阁。因为以后我不需要再看原书了，只需要看读书笔记就完全足够了。以下是我读《投资最重要的事》所做的读书笔记：</p>\n<p>一本巴菲特读了两遍的书：</p>\n<ul>\n<li><p>巴菲特本人投资水平极高，他推荐的投资书籍极少，怎么会如此推荐霍华德.马克斯的这本书呢？</p>\n<ul>\n<li><p>一是英雄所见略同，两个人都是正宗的价值投资者，都非常信奉格雷厄姆提出的价值投资基本原则。霍华德.马克斯几乎每一章都会引用巴菲特的话，可见他和巴菲特的投资思想是多么相同。</p>\n</li>\n<li><p>二是英雄各有所长，巴菲特擅长把非常复杂的投资哲理用非常简单易懂的话说出来：霍华德.马克斯则擅长给自己的投资经验把价值投资基本原则的实践应用解释得非常务实，并结合最新得经济情况和市场情况提出自己得独到见解。</p>\n</li>\n</ul>\n</li>\n<li><p>霍华德.马克斯这本书得中心思想非常明确：如何取得超越市场平均水平得投资业绩？</p>\n</li>\n<li><p>投资艺术有一个特点不为大众所知。门外汉只需稍微努力与能力，便可以取得令人尊敬（即使并不可观）的结果。但是如果想在这个容易获取的标准上更进一步，则需要更多的实践和智慧。</p>\n</li>\n<li><p>如何才能战胜市场：“第一要正确思考，第二要独立思考。”</p>\n</li>\n<li><p>巴菲特提出，投资需要一个稳妥的思考框架作为决策的基础，并且有能力控制自己的情绪，使其不会对这种思考框架造成侵蚀。格雷厄姆的书能够准确和清晰地提供这种思考框架，但对情绪地约束是你自己必须做到的。</p>\n</li>\n<li><p>投资是一门科学，更是一门艺术，而投资艺术和其他艺术一样，要想卓越出众，既要多用脑，又要多用心：一是如何用脑来进行与众不同的第二层的思考和决策，想法比一般人更深一层；二是如何用心来坚持与众不同的第二层的思考和行动，行动上比一般人做得更高一层。</p>\n</li>\n<li><p>这本书得核心为一句话：逆向思考并逆向投资；这是巴菲特重复的他一生最基本的投资原则：在别人恐惧时贪婪，在别人贪婪时恐惧；巴菲特建议最好的投资学习方式是模仿大师。</p>\n</li>\n<li><p>巴菲特建议投资初学者最好的学习方法是模仿大师：“我一直认为，对于刚开始起步的投资人来说，应该寻找已经被证明长期成功有效的投资方法”，然后依葫芦画瓢照着做就行了。令人吃惊的是，这样做的人实在少之又少。“</p>\n</li>\n<li><p>巴菲特在认识格雷厄姆之前的投资业绩一般，从1951年起我的投资业绩开始明显改善，但这并非由于我改变饮食习惯或者开始运动，我唯一增加的新的营养成分是格雷厄姆的投资理念。原因很简单：在大师门下学习几个小时的效果，远远胜过我自己过去10年里自以为是的天真思考。</p>\n</li>\n<li><p>简化投资不是我的目标，事实上，我最想表达的是投资有多么复杂。试图简化投资的人带给受众的是极大的损害。</p>\n</li>\n<li><p>我花在讨论风险以及如何限制风险上的时间，比花在讨论如何实现投资回报上的时间还要长，在我看来，风险是投资最有趣，最有挑战性的一个重要方面。</p>\n</li>\n<li><p>理念源自持之以恒的警醒。你必须要知道世界上正在发生什么，也必须要知道这些事件将导致什么结果。只有这样，你才能在类似的情况再次出现时吸取教训，大多数投资者做不到这一点----它比什么都重要--因此他们注定将屡次遭受经济繁荣与萧条周期之害。</p>\n</li>\n</ul>\n<h2 id=\"第一章：学习第二层思维\"><a href=\"#第一章：学习第二层思维\" class=\"headerlink\" title=\"第一章：学习第二层思维\"></a>第一章：学习第二层思维</h2><ol>\n<li><p>当前需要记住的最重要的事情之一是，经济不是一门精密科学，它甚至有可能完全不在科学范畴。在科学的含义中，可控试验是可以开展的，既往往结果是可以被放心复制的，因果关系是可靠存在的。投资上行得通吗？</p>\n</li>\n<li><p>无论在本书中还是在其他任何地方，暗示投资可以被程序化永远不是我的目标。事实上我最想强调的事情之一是，直觉的、适应性的投资方法比固定的、机械化的投资方法更为重要。</p>\n</li>\n<li><p>成功投资的定义：比市场及其他投资者做得更好。</p>\n</li>\n<li><p>在某些竞争中，先人一步意味着更多得教育、在健身房或图书馆花更多得时间、更好得营养、更多得汗水、更好的耐力或更好的设备。但是在投资中这些东西并不重要，投资需要的是更加敏锐的思维，我们称之为第二层次思维。</p>\n</li>\n<li><p>什么是第二层次思维？</p>\n<ul>\n<li><p>第一层思维说：”这是一家好公司，让我们买进股票吧。“第二层次思维说：”这是一家好公司，但是人人都认为它是一家好公司，因此它不是一家好公司。股票的估价和定价都过高，让我们卖出股票吧。“</p>\n</li>\n<li><p>第一层思维说：”会出现增长低迷、通货膨胀加重的前景。让我们抛掉股票吧。“第二层次思维说：”前景糟糕透顶，但是所有人都在恐慌中抛售股票。买进！“</p>\n</li>\n<li><p>第一层次思维说：”我认为这家公司的利润会下跌，卖出。“第二层次思维说：”我认为这家公司利润下跌得会比人们预期得少，会有意想不到得惊喜拉升股票；买进。“</p>\n</li>\n</ul>\n</li>\n<li><p>显然第一层和第二层思维之间得工作量差异是巨大的，能够进行第二层思维的人数远少于能够第一层思维的人数。</p>\n</li>\n<li><p>为了取得优异的投资结果，你必须对价值持有非常规性的并且必须是正确的看法。这并不容易。</p>\n</li>\n<li><p>以低于价值的价格买进具有非凡的吸引力。那么如何在有效市场中寻找便宜货呢？你必须拿出卓越的分析力、洞察力或远见。不过由于其特殊性，很少有人具备这样的能力。</p>\n</li>\n</ol>\n<h2 id=\"第二章：理解市场有效性及局限性\"><a href=\"#第二章：理解市场有效性及局限性\" class=\"headerlink\" title=\"第二章：理解市场有效性及局限性\"></a>第二章：理解市场有效性及局限性</h2><ol>\n<li><p>理论和实践在理论上没有什么不同，但在实践中却有。</p>\n</li>\n<li><p>芝加哥学派：这一理论包括在投资领域中逐渐成为重要原理的概念：风险厌恶、波动性、风险调整收益、系统与非系统风险、A系数系数、随机漫步假设以及有效市场假说。</p>\n</li>\n<li><p>有效市场假说指出：</p>\n<ul>\n<li><p>市场中有许多参与者，他们分享大致相等的信息渠道。他们聪明、客观、有高度积极性并辛勤工作。他们的分析模型广为人知并被广泛采用。</p>\n</li>\n<li><p>由于参与者的共同努力，信息完全并且迅速地在资产地市场价格上反映出来。参与者买入价格过低资产，并卖出价格过高地资产，因此资产地绝对价格以及彼此之间地相对价格是公平的。</p>\n</li>\n<li><p>因此市场价格代表了对资产内在价值的准确估计，任何参与者都不能连续识别市场的错误并从中连续套利。</p>\n</li>\n<li><p>因此资产是以相对于其他资产来说“公平”的、提供预期风险调整收益的价格出售的。风险更高的资产必须提供更好的收益来吸引购买者。市场会根据情况设定价格，但它不会提供“免费的午餐”，即没有与新增风险无关的（以及非补偿性的）新增收益。</p>\n</li>\n</ul>\n</li>\n<li><p>首先，一两年的好业绩证明不了任何事情；单从偶然性来说，就几乎可以产生任何结果。其次，统计学家认为，如果没有足够年份的数据，任何东西都无法被证明具有统计学意义；</p>\n</li>\n<li><p>一个人与另一个人的收益差异，完全归因于风险差异。事实上，如果你是有效市场假说的信徒，同时又拥有像我这样较好的投资记录，那么答案可能会是“更高的投资收益是由隐性风险所致”（深层含义是“你还没有积累足够年份的数据”）。</p>\n</li>\n<li><p>纽约市场上，数百万人在相似信息的基础上作着相似的分析，股票被错误定价的概率以及人们发现这些错误定价的概率如何呢？答案是：概率不大，也不可靠，但这确实第二层次思维的真谛。</p>\n</li>\n<li><p>第二层次思维者知道，为了取得优异的业绩，他们必须具备信息优势或分析优势，或二者兼具。</p>\n</li>\n<li><p>在有效市场假说中，就会发现其中有一点特别脆弱：客观性。人类不是冰冷的计算器。相反，大多数人都会受贪婪、恐惧、妒忌及其他破坏客观性、导致重大失误的情绪驱动。</p>\n</li>\n<li><p>一个存在着错误以及错误定价的市场，能够被具有非凡洞察力的战胜。因此无效性的存在创造了取得良好业绩的可能性，是取得良好业绩的必要条件。</p>\n</li>\n<li><p>错误估价并从中获利的可能性是存在的。无效市场提供的是原料（错误定价），而有些人赢，有些人输，取决于他们所掌握的技术的不同。如果价格可能出现严重错误，那就意味着有发现便宜货或价格过高的股票的可能。</p>\n</li>\n<li><p>任何时候都会有许多好的便宜货被埋没在其他投资者不能或不愿去发现的东西里。让别人相信市场是永远无法战胜的吧！让那些不愿意冒险的人弃权，为愿意冒险的人创造机会吧！</p>\n</li>\n</ol>\n<h2 id=\"第三章：准确估计价值\"><a href=\"#第三章：准确估计价值\" class=\"headerlink\" title=\"第三章：准确估计价值\"></a>第三章：准确估计价值</h2><ol>\n<li><p>投资若想取得切实成功，对内在价值的准确估计是根本出发点。没有它，投资者任何取得持续投资成功的希望都仅仅是希望。</p>\n</li>\n<li><p>最古老也最简单的投资原则是<strong>“低卖，高卖。”</strong>看起来再明显不过了：但这一原则的真实含义是什么？同样显而易见--就是字面上的意思。</p>\n</li>\n<li><p>以低于内在价值的价格买进，以更高的价格卖出。当然，在此之前，你最好对内在价值是什么有一个明确的认识。对我来说，对价值的准确估计是根本出发点。</p>\n</li>\n<li><p>为简化起见，所有投资公司证券的方法均可被划分为两种基本类型：基于公司特性即“基本面”分析的，以及基于证券自身价格行为研究的。换言之，投资者有两种基本选择：判断证券的内在价值并在价格偏离内在价值时买进或卖出证券，或者将决策完全建立在对未来价格走势预期的基础之上。</p>\n</li>\n<li><p>技术分析衰落的部分原因是随机漫步假说的出现，随机漫步假说认为，既往股价走势对于预测未来股价没有任何帮助。</p>\n</li>\n<li><p>换言之，价格变动是一个随机过程，与掷硬币相仿。众所周知，在掷硬币的时候，即使已经连续10次掷出正面朝上，下一次正面朝上的概率仍然是50%。依此类推，随机漫步假说认为，过去10天内股价的连续上涨并不能告诉你明天的股价会怎样。</p>\n</li>\n<li><p>动量投资可能会让你在持续上涨的牛市中分一杯羹，但我看到它存在许多缺陷，其中之一基于经济学家赫伯特.斯坦的那句苦涩的名言：“无法永久持续的东西必将终结。”</p>\n</li>\n<li><p>据观察，如果以10美元买进、11美元卖出，下个星期以24美元买进25美元卖出，再下个星期以39元买进、40美元卖出，日间交易者就认为自己是成功的。如果你看不到其中的缺陷---股价上涨了30美元，交易者却只赚到了3美元。</p>\n</li>\n<li><p>价值投资的目标是得出证券当前的内在价值，并在价格低于当前价值时买进，成长型投资者的目标则是寻找未来将迅速增值的证券。</p>\n</li>\n<li><p>价值投资强调的是有形因素，如重资产和现金流。某些流派的价值投资专注于硬资产，即在公司股票的总市值低于公司的流动资产（如现金、应收账款和存货）并超出总负债时买进。在这种情况下，从理论上讲你可以买进所有股票，将流动资产变现并清偿债务，以得到公司所有权及若干现金。</p>\n</li>\n<li><p>价值投资追求的是低价。价值投资者通常会考察收益、现金流、股利、硬资产及企业价值等财务指标，并强调在此基础上低价买进。</p>\n</li>\n<li><p>成长型投资介于枯燥乏味的价值投资和冲动刺激的动量投资之间。其目标是识别具有光明前景的企业。从定义上来看，它侧重于企业的潜力，而不是企业的当前属性。</p>\n</li>\n<li><p>两者之间的差异如下：</p>\n<ol>\n<li><p>价值投资者相信当前价值高于当前价格，从而买进股票（即使它们的内在价值显示未来的增长有限）。</p>\n</li>\n<li><p>成长型投资者相信未来价值的迅速增长足以导致价格大幅上涨，从而买进股票（即使它们的当前价值低于当前价格）。</p>\n</li>\n</ol>\n</li>\n<li><p>因此在我看来，真正的选择似乎不在价值和成长之间，而在当前价值和未来价值之间。</p>\n</li>\n<li><p>确定企业的当前价值是需要考虑企业未来的，继而必须考虑可能的宏观经济环境、竞争环境与技术进步。</p>\n</li>\n<li><p>可以这样说：成长型投资关心未来，而价值投资强调当前，但不可避免地要面对未来。</p>\n</li>\n<li><p>总而言之，如果判断正确，那么成长型投资的上涨潜力更富戏剧性，而价值投资的上涨潜力更有持续性。我选择的是价值投资法，在这本书里，持续性比戏剧性更重要。</p>\n</li>\n<li><p>如果你已经选定价值投资法投资，并且已经计算出证券或资产的内在价值，接下来还有一件重要的事：坚定地持有。因为在投资领域里，正确并不等于正确性能够被立即证实。</p>\n</li>\n<li><p>对于投资者来说，持续正确很难。而永远在正确地时间做正确的事是不可能的。</p>\n</li>\n<li><p>当你认为低估而买进时，往往会发现自己买进的时机是在持续下跌的中途，很快你就会看到损失。正如一句是最伟大的投资谚语告诉我们的，“过于超前与犯错是很难区分的。”</p>\n</li>\n<li><p>微观经济学入门课程中学过，需求曲线是向右下倾斜的；随着价格的上涨，需求数量下降。换言之，价格较高时，需求量较少，价格较低时，需求量较大。这就是商品打折商店的销量更大的原因。</p>\n</li>\n<li><p>需求曲线在大多数情况下都起作用，但在投资领域里似乎远非如此。在投资领域里，当自己持有的证券价格上涨时，许多人会更加喜爱它们，因为他们的决策得到了验证；而当证券价格下跌时，他们开始怀疑自己的决策是否正确，对它的喜爱也随之而减少。</p>\n</li>\n<li><p>这使得持有并继续以更低的价格买进股票（投资者称之为“向下摊平”）变得相当困难，特别是跌幅比较大的时候。直到最后所有人都产生了疑问：“也许是我错了吧？”也许市场才是对的？“随后，当人们开始想”股票跌得太厉害了，我最好在它的价格趋于零之前脱身“的时候，危险性达到了顶峰。这是一种导致股票见底的思维。并且会引发抛售狂潮。</p>\n</li>\n<li><p>不懂利润、股利、价值或企业管理的投资者完全不具备在正确的时间做正确的事情的决断。周围人都炒股赚钱的时候，他们不可能懂得：股票价格已经过高，因此要抵制进场的诱惑。市场自由落体的时候，他们也不可能有坚定地持有股票或以极低地价格买进股票地自信。</p>\n</li>\n<li><p>当价值投资者买进定价过低的资产、不停地向下摊平并且分析正确时候，就能获得最大收益。因此在一个下跌的市场中获利有两个基本要素：你必须了解内在价值；同时你必须足够自信，坚定地持股并不断买进，即使价格已经跌倒似乎在暗示你做错了的时候。还有第三个基本要素：你必须是正确的。</p>\n</li>\n</ol>\n<h2 id=\"第四章：价格与价值的关系\"><a href=\"#第四章：价格与价值的关系\" class=\"headerlink\" title=\"第四章：价格与价值的关系\"></a>第四章：价格与价值的关系</h2><ol>\n<li><p>假设你认识到价值投资的有效性，并且能够估计出股票或资产的内在价值；这并不算完。为了知道需要采取怎样的行动，你必须考察相对资产价值的资产价格。建立基本面---价值---价格之间的健康关系是成功投资的核心。</p>\n</li>\n<li><p>好的买进就是成功卖出的一半，如果你买的足够便宜，你是不需要考虑卖出技巧的。</p>\n</li>\n<li><p>如果你对内在价值的估计是正确的，那么随着时间的推移，资产价格将会与资产价值趋于一致。</p>\n</li>\n<li><p>确定价值的关键是熟练的财务分析，而理解价格、价值关系及其前景的关键，则主要依赖对其他投资者思维的洞察。投资者心理几乎可以导致证券在短期内出现任何定价，而无论其基本面如何。</p>\n</li>\n<li><p>最安全、获利潜力最大的投资，是在没人喜欢的时候买进。假以时日，一旦证券受到欢迎，那么它的价格只可能向一个方向变化：上涨。</p>\n</li>\n<li><p>从买进证券的那一天起你就必须了解，基本面价值只是决定证券价格的因素之一，你还要设法让心理和技术为你所用。</p>\n</li>\n<li><p>在泡沫时期，对市场势头的迷恋取代了价值和公平价格的观念，贪婪抵消了所有本应占据主导地位的智慧。</p>\n</li>\n</ol>\n<h2 id=\"第五章：理解风险\"><a href=\"#第五章：理解风险\" class=\"headerlink\" title=\"第五章：理解风险\"></a>第五章：理解风险</h2><ol>\n<li><p>投资只关乎一件事：因对未来，没有人能够确切地预知未来，所以风险是不可避免地。投资中如果你能够找到足够多地上涨因素，那么你可能已经在朝着正确地方向前进。但是，如果不能正确地应对风险，那么你的成功是不可能长久的。</p>\n</li>\n<li><p>为了吸引资本，风险更高的投资必须提供更好的收益前景、更高的承诺收益或预期收益，但绝不表示这些更高的预期收益必须实现。</p>\n</li>\n<li><p>更高的投资风险导致更加不确定的结果。也就是说，收益的概率分布更广。当定价公平时，风险较高的投资意味着：更高的预期收益、获得较低收益的可能、在某些情况下、损失的可能。</p>\n</li>\n<li><p>风险明确的定义为波动性（或易变性、偏差）。这些词当中没有一个能够表达出”危险“的必然含义。（危险、冒险、危害、极大危险）</p>\n</li>\n<li><p>永久性损失的概率是我、橡树资本管理公司以及我所认识的每一位实际投资者所担心的风险。</p>\n</li>\n<li><p>导致风险的原因：</p>\n<ol>\n<li><p>基本面变弱未必导致损失风险。</p>\n</li>\n<li><p>风险可能在宏观环境并未走弱时出现。自负、对风险的无知和放任以及一点点发展的不利结合到一起，便足以带来灾难。灾难有可能发生在任何没有花费时间和精力理解自己投资组合基本过程的人身上。</p>\n</li>\n<li><p>损失风险主要归因于心理过于积极，以及由此导致的价格过高。投资者倾向于将动人的题材和时髦的概念与高潜在收益联系在一起。</p>\n</li>\n<li><p>理论认为，高收益与高风险相关，因为前者为补偿后者而存在。但是务实的价值投资者的感觉恰恰相反：他们相信，在以低于价值买进证券的时候，高收益、低风险是可以同时实现的。同样，价格过高则意味着低收益、高风险。</p>\n</li>\n</ol>\n</li>\n<li><p>不同投资于其发生损失的风险之间的关系很不确定、很容易发生变动，因此也无从引入有效的数学计算公式。</p>\n</li>\n<li><p>多数风险都具有主观性、隐蔽性和不可量化性。</p>\n</li>\n<li><p>投资风险很大程度上事先观察不到的---除了那些有非凡洞察力的人，甚至在投资退出之后也一样。正因如此我们见到过的许多金融大灾难都没能被成功的预测，人们也没能很好的管理风险。原因有几个：</p>\n<ol>\n<li><p>风险只存在于未来，而未来会怎样是不可能确定的。</p>\n</li>\n<li><p>承担风险与否的决策建立在常态再现的期望之上。</p>\n</li>\n<li><p>预测倾向于围绕历史常态聚集，人们通常会预测未来与过去相似，而对潜在的变化估计不足。</p>\n</li>\n<li><p>我们常听说”最坏情况“预测，但是结果往往显示预测的程度还不够坏。</p>\n</li>\n<li><p>人们高估了自己判断风险的能力，以及对未曾见过的投资机制的理解能力。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第六章：识别风险\"><a href=\"#第六章：识别风险\" class=\"headerlink\" title=\"第六章：识别风险\"></a>第六章：识别风险</h2><ol>\n<li><p>杰出投资者需要创造收益和控制风险并重，而识别风险是控制风险的绝对前提。</p>\n</li>\n<li><p>识别风险往往从投资者意识到掉以轻心、盲目乐观并因此对某项资产出价过高时开始。换句话说，高风险主要伴随高价格出现。在高价时不知规避反而蜂拥而上都是风险的主要来源。</p>\n</li>\n<li><p>价值投资者认为高风险和低预期收益不过是同一硬币的两面，二者都主要源自高价格。</p>\n</li>\n<li><p>普遍相信没有风险本身就是最大的风险，因为只有当投资者适当规避风险时，预期收益中才会包含风险溢价。</p>\n</li>\n<li><p>因此，产生风险的首要因素是认为风险很低甚至已经被完全消除的意识。这一认识推高了价格，导致了低预期收益下的冒险行为。</p>\n</li>\n<li><p>认为风险已经消失的看法是最危险的风险源头之一，也是促成泡沫的主要因素。在市场的钟摆达到最高点时，认为风险很低以及投资一定能获利的信念令人群激动不已，以致他们丧失了对损失应有的警惕、担忧及恐惧，只对错失机会的风险耿耿于怀。</p>\n</li>\n<li><p>随着对不同资产（1、3、5、10期债券、房地产、股市等），不同时间，不同风险的利率回报，会导致投资者心理对风险规避情绪的下降，这一“富集”过程最终导致市盈率高企、信用利差收窄、投资者行为散漫、杠杆滥用以及对各种类型投资工具的强烈需求。这些结果在推高价格、减少预期收益的同时，还创造了一个高风险环境。</p>\n</li>\n<li><p>只有当潮水退去的时候，你才会发现谁在裸泳。盲目乐观的人请注意：永远涨潮是不可能的。</p>\n</li>\n</ol>\n<h2 id=\"第七章：控制风险\"><a href=\"#第七章：控制风险\" class=\"headerlink\" title=\"第七章：控制风险\"></a>第七章：控制风险</h2><ol>\n<li><p>杰出投资者之所以杰出，是因为他们拥有与创造收益的能力同样杰出的风险控制能力。</p>\n</li>\n<li><p>杰出投资者是那些承担着与其赚到的收益不相称的低风险的人。他们或以低风险赚到中等收益，或以中等风险赚到高收益。</p>\n</li>\n<li><p>无论风险控制取得怎样的成绩，在繁荣时期是永远也表现不出来的，因为风险是隐蔽的，是不可见的。风险------发生损失的可能性-----是观察不到的，能观察到的是损失，而损失通常只在风险与负面事件相碰撞时才会发生。</p>\n</li>\n<li><p>没有出现不利环境不代表不需要风险控制，即使结果显示当时可以不进行风险控制。</p>\n</li>\n<li><p>为了保证投资组合撑过困难期，一般来说必须有良好的风险控制。</p>\n</li>\n<li><p>风险控制在繁荣期是观察不到的，但依然是必不可少的，因为由盛转衰是轻而易举的。</p>\n</li>\n<li><p>好建筑师能够避免建筑缺陷，而差建筑师会引入建筑缺陷。在没有地震的时候，你无法辨别其中的差异。</p>\n</li>\n<li><p>同样，优秀的投资者获得的收益可能不比别人高，但在实现同等收益的前提下承担了较低风险。当然，在市场平稳或上涨时，我们无从得知投资组合的风险有多大。这就是巴菲特所观察到的，除非潮水退去，否则我们无从分辨游泳者谁穿着衣服，谁又在裸泳。</p>\n</li>\n<li><p>承担风险而不自知，可能会铸成大错，但这正是人们在买进风靡一时、备受推崇、绝不可能出问题的证券时不断在重复的事。</p>\n</li>\n<li><p>贯穿长期投资成功之路的，是风险控制而不是冒进。在整个投资生涯中，大多数投资者取得的结果将更多的取决于致败的数量及程度，而不是致胜投资的数量及程度。良好的风险控制是优秀投资者的标志。</p>\n</li>\n</ol>\n<h2 id=\"第八章：关注周期\"><a href=\"#第八章：关注周期\" class=\"headerlink\" title=\"第八章：关注周期\"></a>第八章：关注周期</h2><ol>\n<li><p>我认为，牢记万物皆有周期是至关重要的，我敢肯定的东西不多，但以下这些话千真万确，周期永远胜在最后，任何东西都不可能朝同一个方向永远发展下去，树木不会长到天上，很少有东西归零。坚持以今天的事件推测未来是对投资者健康最大的危害。</p>\n</li>\n<li><p>我们永远不知道未来会发生什么，但是我们可以为可能性作好准备，减少它们所带来的痛苦。</p>\n</li>\n<li><p>多数事物都是周期性的。当别人忘记这个规律时，某些最大的盈亏机会就会到来。</p>\n</li>\n<li><p>昨天的一切市场利好对今天的市场都没好处，周期的极端性主要源自人类的情绪与弱点、主观与矛盾。</p>\n</li>\n<li><p>繁荣导致扩大借款，扩大借款导致轻率借款，轻率借款导致巨大损失，巨大损失导致借款人停止借款，停止借款结束繁荣，如此循环往复。。。。</p>\n</li>\n</ol>\n<h2 id=\"第九章：钟摆意识\"><a href=\"#第九章：钟摆意识\" class=\"headerlink\" title=\"第九章：钟摆意识\"></a>第九章：钟摆意识</h2><ol>\n<li><p>当形势良好，价格高企时，投资者迫不及待地买进，把所有谨慎忘在脑后，随后，当四周一片混乱，资产廉价待箍时，他们又完全丧失了承担风险地意愿，迫不及待地卖出，永远如此。</p>\n</li>\n<li><p>投资的主要风险归结为两个：亏损的风险和错失机会的风险。大幅消除其中任何一个都是有可能的，但二者是不可能被同时消除的。理想状态下，投资者会使两者达到平衡。但当钟摆摆动到最高点时，一种风险或另一种风险一次又一次地占据上风。</p>\n</li>\n<li><p>牛市有三个阶段：</p>\n<ol>\n<li><p>第一阶段，少数有远见地人开始相信一切会更好。</p>\n</li>\n<li><p>第二阶段，大多数投资者意识到进步的确已发生。</p>\n</li>\n<li><p>第三阶段，人人断言一切永远会更好。</p>\n</li>\n</ol>\n</li>\n<li><p>熊市地三个阶段：</p>\n<ol>\n<li><p>少数善于思考的投资者意识到，尽管形势一片大好，但不可能永远称心如意。</p>\n</li>\n<li><p>大多数投资者意识到势态的恶化。</p>\n</li>\n<li><p>人人相信形势只会更遭。</p>\n</li>\n</ol>\n</li>\n<li><p>我们能够肯定的事情之一是，极端市场行为会发生逆转。相信钟摆将朝着一个方向永远摆动-----或永远停留在端点的人，最终将损失惨重；了解钟摆行为的人则将收益无穷。</p>\n</li>\n</ol>\n<h2 id=\"第十章：抵御消极影响\"><a href=\"#第十章：抵御消极影响\" class=\"headerlink\" title=\"第十章：抵御消极影响\"></a>第十章：抵御消极影响</h2><ol>\n<li><p>得到更多的渴望、担心错过的恐惧、与他人比较的倾向、群体的影响以及对胜利的期望----这些因素几乎是普遍存在的。因此，它们对大多数投资者和市场都有着深远的影响，结果就是错误----频繁的、普遍的、不断重复发生的错误。</p>\n</li>\n<li><p>无效性----错误定价、错误认知以及他人犯下的过错------为优异表现创造了机会。</p>\n</li>\n<li><p>投资错误不是来自信息因素或分析因素，而是来自心理因素。投资心理包括许多独立因素，这些因素往往会导致错误决策。它们大多归属“人性”之列。</p>\n</li>\n<li><p>危险产生于渴望变成贪婪的时候。对于贪婪，其定义为“对财富或利润过度的或无节制的、通常应受谴责的占有欲”。</p>\n</li>\n<li><p>贪婪是一股极其强大的力量。它强大到可以压倒常识、风险规避、谨慎、逻辑、对过去教训的痛苦记忆、决心、恐惧以及其他所有可能令投资者远离困境的要素。反之，贪婪时常驱使投资者加入逐利的人群，并最终付出代价。</p>\n</li>\n<li><p>自欺欺人是最简单的，因为人总是相信他所希望的。</p>\n</li>\n<li><p>投资者往往在贪婪的驱使下，轻易地摒弃或忽略了以往地教训。</p>\n</li>\n<li><p>从众而不坚持己见地心理倾向，同样会造成投资错误。</p>\n</li>\n<li><p>嫉妒，无论贪婪的负面力量有多大，它还有激励人们积极进取的一面，与之相比，与别人相比较的负面影响更胜一筹。这就是我们所谓的人的天性里危害最大的一个方面。</p>\n</li>\n<li><p>随着定价过高的股票走势更好，或者定价过低的股票持续下跌，正确做法变得更加简单：卖掉前者，买进后者。但是人们不这样做。</p>\n</li>\n<li><p>得到更多的渴望、担心错过的恐惧、与他人比较的倾向、群体的影响以及对胜利的期望----这些因素几乎是普遍存在的。因此，它们对大多数投资者和市场都有着深远的影响。结果就是错误----频繁的、普遍的、不断重复发生的错误。</p>\n</li>\n<li><p>是什么令投资者放弃了常识？是我们一直在这里谈论的某些情感：贪婪、恐惧、自欺、自负，让我们回顾一下当时的情况，看一看心理在其中是如何起作用的。</p>\n</li>\n<li><p>投资者在泡沫中往往置常识而不顾，他们忽略了很多事实：并不是所有的公司都会成功，股市会有漫长的震荡过程，提供免费服务难以盈利，以高市售率（没有利润，所以不能用市盈率）定价的亏损公司的股票有着巨大的风险。</p>\n</li>\n<li><p>在牛市中没有买进的最坏结果不过是你看起来有些落后并且要付出机会成本。但在2008年大崩溃时没有卖出的后果是无尽的损失，世界末日仿佛真的有可能降临。</p>\n</li>\n<li><p>相信我，在别人都在买进、专家态度乐观、上涨理由充分、价格不断飙升、风险最高的人不断获得巨额收益的鼎盛期，抵制买进是很难的（卖出更难）。相反，在股市跌入谷底、持股或买进似乎会带来全盘损失的时候，抵制卖出也是很难的（买进更难）。</p>\n</li>\n<li><p>简单的解决方案是不存在的：没有告诉你市场已经摆向非理性极端的公式，没有保证你永远做出正确决策的完美工具，也没有保护你不受消极情绪影响的魔法药丸。正像查理.芒格说的：“没那么简单。”</p>\n</li>\n<li><p>那么如何提高自己的胜算呢？以下是橡树资本管理公司行之有效的方法：</p>\n<ol>\n<li><p>对内在价值有坚定的认识。</p>\n</li>\n<li><p>当价格偏离价值时，坚持做该做的事。</p>\n</li>\n<li><p>足够了解以往的周期-----先从阅读与经验丰富的投资者交谈开始，之后通过经验积累----从而了解市场过度膨胀或过度萎缩最终得到的是惩罚而不是奖励。</p>\n</li>\n<li><p>透彻理解市场对极端市场投资过程的潜在影响。</p>\n</li>\n<li><p>一定要记住，当事情看起来“好到不像真的”时，它们通常不是真的。</p>\n</li>\n<li><p>当市场错误股价的程度越来越深（始终如此）以致自己貌似错误的时候，愿意承受这样的结果。</p>\n</li>\n<li><p>与志趣相投的朋友或同事相互聊天。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第十一章：逆向投资\"><a href=\"#第十一章：逆向投资\" class=\"headerlink\" title=\"第十一章：逆向投资\"></a>第十一章：逆向投资</h2><ol>\n<li><p>在别人沮丧地抛售时买进，在别人兴奋地买进时抛售需要最大地勇气，但它能带来最大地收益。</p>\n</li>\n<li><p>我只能用一个词来描述大多数投资者-----趋势跟踪者，而杰出投资者恰恰相反。</p>\n</li>\n<li><p>某种程度上来说，趋势、群体共识是阻碍成功地因素，雷同地投资组合是我们要避开的。由于市场的钟摆式摆动或市场的周期性，所以取得最终胜利的关键在于逆向投资。</p>\n</li>\n<li><p>群体错误的逻辑性是明确的，甚至是几乎可以测算的：</p>\n<ol>\n<li><p>市场会发生剧烈的摆动，从牛市到熊市，从股价过高到股价过低。</p>\n</li>\n<li><p>市场走势受群体（人群或大多数人）行为的驱动。牛市出现于更多的人想成为买家而不是卖家，或买家比卖家更为活跃的时候。随着人们从卖家转向买家，或买家活跃度的进一步提高、卖家活跃度的进一步降低，市场开始上涨（买家不占到主导地位，市场就不会上涨）。</p>\n</li>\n<li><p>市场极端代表着拐点，出现于牛市或熊市达到巅峰时。比方说，当最后一个希望成为买家的人成为买家的时候，市场就会到顶。既然到顶时所有买家都已经加入到看涨群体中来，那么牛市就不会进一步上涨，市场也已高到了它能够达到的极限。此时买进或持有都很危险。</p>\n</li>\n<li><p>因为再也没有看涨的人，市场停止了上涨。如果次日有一个人从买家转变成卖家，那么市场就会下跌。</p>\n</li>\n<li><p>因此，在达到由群体的信念所创造出来的市场极端时，大多数人都是错的。</p>\n</li>\n<li><p>因此，投资成功的关键在于逆势而行：不从众。那些意识到他人错误的人可以通过逆向投资而获利丰厚。</p>\n</li>\n</ol>\n</li>\n<li><p>作为逆向投资者，我们的任务就是尽可能谨慎熟练地接住下落地刀子。这也是内在价值的概念如此重要的原因。如果我们对价值的认识能够让我们在别人都在卖出的时候买进----并且如果我们的观点事后被证明是正确的-------那么这就是以最低风险获取最高回报的途径。</p>\n</li>\n</ol>\n<h2 id=\"第十二章：寻找便宜货\"><a href=\"#第十二章：寻找便宜货\" class=\"headerlink\" title=\"第十二章：寻找便宜货\"></a>第十二章：寻找便宜货</h2><ol>\n<li><p>在大多数人不愿做的事情中，通常能够发掘出最佳机会。</p>\n</li>\n<li><p>精心构建投资组合的过程，包括卖出不那么好的投资从而留出空间买进最好的投资，不碰最差的投资。</p>\n</li>\n<li><p>这个过程包括：</p>\n<ol>\n<li><p>潜在投资的清单。</p>\n</li>\n<li><p>对它们的内在价值的估计</p>\n</li>\n<li><p>对其价格相对于价值的感知。</p>\n</li>\n<li><p>对每种投资涉及到的风险及其对在建投资组合的影响的了解。</p>\n</li>\n</ol>\n</li>\n<li><p>为了找到便宜货，我们必须了解为什么资产会受到冷落。它不一定是可观分析的结果。事实上，多数便宜货的形成过程与分析无关，重要的是考虑它背后的心理因素，以及它的驱动因素：受欢迎程度的变化。</p>\n</li>\n<li><p>那么造成价格相对于价值较低的原因是什么？</p>\n<ol>\n<li><p>与热门题材资产不同，潜在的便宜货通常会显示出一些客观不足。资产类别可能存在缺陷，公司在业内可能较为落后，资产负债可能被过度杠杆化。</p>\n</li>\n<li><p>便宜货往往产生于投资者不能保持客观的态度对待资产，没有透过表象全面了解资产，或未能克服某些不以价值为基础的传统、偏见或束缚的时候。</p>\n</li>\n<li><p>与市场宠儿不同，“孤儿资产”常被忽略或鄙视。</p>\n</li>\n<li><p>它不断下跌的价格通常令第一层思维者发问：“谁想要它呢？”</p>\n</li>\n<li><p>结果，便宜货往往成为极不受欢迎的资产。资本远离或出逃，没有人想得出持有它的理由。</p>\n</li>\n</ol>\n</li>\n<li><p>考虑到投资者的行为方式，任何在某一时间点被认为是最差的资产，都很有可能成为最廉价的资产。便宜不需要与高品质有任何关系。事实上，令人望而却步的低质量证券的价格往往更低。</p>\n</li>\n</ol>\n<h2 id=\"第十三章：耐心等待机会\"><a href=\"#第十三章：耐心等待机会\" class=\"headerlink\" title=\"第十三章：耐心等待机会\"></a>第十三章：耐心等待机会</h2><ol>\n<li><p>市场不是有求必应的机器，它不会仅仅因为你需要就提供高额收益。</p>\n</li>\n<li><p>与全球金融危机相关的繁荣--衰退周期，为我们提供了在2006年、2007年高价卖出，2008年低价买入的机遇。从许多方面讲，这是一个千载难逢的机会。</p>\n</li>\n<li><p>并不是总有伟大的机会等着我们，有时候我们可以通过敏锐的洞察和相对消极的行动讲成果最大化。耐心等待机会------等待便宜货------往往是最好的策略。</p>\n</li>\n<li><p>等待投资机会到来而不是追逐投资机会，你会做得更好。</p>\n</li>\n<li><p>识别市场环境并做出相应的行动决策是成功投资必不可少的。其他可能的行为包括：在没有认清市场情况下采取行动，在无视市场状况的情况下采取行动，相信我们可以在某种程度上改变市场。这些都是不可取的。结合我们所处的环境适当地投资才是明智之举。事实上，除此之外其他任何做法都是行不通的。</p>\n</li>\n<li><p>投资最大的优点之一是，只有真正作出失败的投资时才会遭受损失。不作失败的投资就没有损失，只有回报。即使会有错失制胜机会的不良后果，也是可以容忍的。</p>\n</li>\n<li><p>投资失败比失去一个获利机会更值得重视。因此，我们的客户都有将风险控制放在全盘获利之前的心理准备。</p>\n</li>\n<li><p>在危机中关键要做到远离强制卖出的力量，并把自己定位为买家。为达到这一标准，投资者需要做到以下几点：坚信价值，少用或不用杠杆，有长期资本和顽强的意志力。在逆向投资态度和强大资产负债表支撑下，耐心地等待机会，便能在灾难中收获惊人地收益。</p>\n</li>\n</ol>\n<h2 id=\"第十五章：正确认识自身\"><a href=\"#第十五章：正确认识自身\" class=\"headerlink\" title=\"第十五章：正确认识自身\"></a>第十五章：正确认识自身</h2><ol>\n<li><p>我们或许永远不知道要去往何处，但最好明白我们身在何处。</p>\n</li>\n<li><p>第一种认识：我们应该否认周期的不可预测性，加倍努力地预测未来，将新增资源投入战斗，根据我们的结果进行投资。</p>\n</li>\n<li><p>第二种认识：承认未来不可预测性，忽略市场周期。我们不再费力预测周期，而是尽力作好投资并长期持有。</p>\n</li>\n<li><p>第三种认识：在我看来是最为正确的答案：何不试着弄清我们处在周期的哪个阶段，以及这一阶段对我们的行动产生怎样的影响？</p>\n</li>\n<li><p>我们或许永远不会知道要去往何处，但最好明白我们身在何处。也就是说，即使我们不能预测周期性波动的时间和幅度，力争弄清我们处于周期的哪个阶段并采取相应的行动也是很重要的。</p>\n</li>\n<li><p>既然无法认识，但一些做法更为合适：</p>\n<ol>\n<li><p>当市场已经到达极端的时候，保持警惕；</p>\n</li>\n<li><p>相应地调整我们的行为；</p>\n</li>\n<li><p>最重要的是，拒绝向导致无数投资者在市场顶部或底部犯下致命错误的群体行为看齐。</p>\n</li>\n</ol>\n</li>\n<li><p>了解未来很困难，但是了解现在没有那么难。我们需要做的是”测量市场温度。“保持警觉和敏锐，我们就能够判断出其他人的行为，并据此判断我们采取的行动。</p>\n</li>\n<li><p>市场环境测试，当大部分选择左侧时，要保护好自己的钱包：</p>\n</li>\n<li><p>市场在周期性运动，有涨有跌。钟摆在不断摆动，极少停留在弧线的中点。这是危险还是机遇？投资者该如何应对？我的回答很简单：努力了解我们身边所发生的事情，并以此指导我们的行动。</p>\n</li>\n</ol>\n<h2 id=\"第十六章：重视运气\"><a href=\"#第十六章：重视运气\" class=\"headerlink\" title=\"第十六章：重视运气\"></a>第十六章：重视运气</h2><ol>\n<li><p>投资领域并不是一个未来可以预见、特定行为总能产生特定结果的有秩序有逻辑的地方。事实上，投资很大程度上受运气支配。有些人喜欢把它叫做”偶然性“或”随机性“，这些词听起来的确比”运气“更加高深。但归根结底它们都是同一件事：我们作为投资者所取得的成功深受偶然因素的影响。</p>\n</li>\n<li><p>在成功的时候，运气看起来像技能，巧合看起来像因果。“幸运的傻瓜”看起来像专业的投资者。当然，即使知道随机性的影响，区分幸运的傻瓜和专业的投资者也并不容易，但是我们必须努力的区分。</p>\n</li>\n<li><p>好的决策本应是有逻辑、有智慧、有见地的人在条件出现之时、结果出现之前做出的。</p>\n</li>\n<li><p>长期来看，好的决策一定会带来投资收益。然而在短期内，当好的决策无法带来投资收益的时候，我们必须忍耐。</p>\n</li>\n<li><p>与世界不确定的认识相伴而行的其他表现为：适度尊重风险，知道未来不能预知，明白未来是概率分布的并相应地进行投资，坚持防御性投资，强调避免错误的重要性。在我看来，这就是有关聪明投资者的一切。</p>\n</li>\n</ol>\n<h2 id=\"第十七章：多元化投资\"><a href=\"#第十七章：多元化投资\" class=\"headerlink\" title=\"第十七章：多元化投资\"></a>第十七章：多元化投资</h2><ol>\n<li><p>有老投资者，有大胆的投资者，但没有大胆的老投资者。</p>\n</li>\n<li><p>赚钱和避损，你更在乎哪个？你不可能将精力同时放在获取收益和避免损失上。每一个投资者都必须在这两个目标中做出选择，通常要在两者之间进行合理的平衡。</p>\n</li>\n<li><p>在主流股票市场中主动得分对投资者未必有好处。相反，投资者应该尽量避免输球。我认为这是一个十分引人入胜的投资观点。</p>\n</li>\n<li><p>即使经验丰富的投资者都可能打出失误球，击球过于主动更容易输掉比赛。因此，防守-----重点在于避免错误-----是每一场伟大投资游戏的重要组成部分。</p>\n</li>\n<li><p>投资中的进攻和防守是什么？进攻很好定义，它指的是为追求高额收益而采用积极策略并承担较高风险。但什么是防守呢？防御型投资者关注的不是做对，而是避免做错。</p>\n</li>\n<li><p>防御性投资有两大要素。</p>\n<ol>\n<li><p>排除投资组合中的致败因素，最好的实现方法是：广泛尽职调查、提高入选标准、要求低价和高错误边际，不要轻易下注在没有把握的持续繁荣、乐观预测和发展上。</p>\n</li>\n<li><p>避开衰退期，特别要避免暴露在崩溃危机下。除了前面提到的要排除投资组合中的致败投资外，防守还需要投资组合多元化、限制总风险承担并以整体安全为重。</p>\n</li>\n</ol>\n</li>\n<li><p>你借钱给一个人，这个人收入不错、工作稳定；或者没有工作，有存款也可以，再或者这个人信用很好，这就是安全边际。如果这个人是人渣，你会借给他吗？</p>\n</li>\n<li><p>设法通过积极进取策略将收益最大化，或者通过错误边际来建立保护。你不能两方面同时做到极致。你会选择进攻、防守还是兼顾（如果兼顾，二者之间的比例如何？）</p>\n</li>\n<li><p>在获取高额收益和避免损失这两种投资方法中，我认为后者更为可靠。</p>\n</li>\n<li><p>最好的投资者具备以下特征：敬畏投资、要求物有所值和高错误边际，之所不知，知所不能。</p>\n</li>\n</ol>\n<h2 id=\"第十八章：避免错误\"><a href=\"#第十八章：避免错误\" class=\"headerlink\" title=\"第十八章：避免错误\"></a>第十八章：避免错误</h2><ol>\n<li><p>投资者几乎无须做对什么事，他只需能够避免犯重大错误。</p>\n</li>\n<li><p>设法避免损失比争取伟大的成功更加重要。投资组合风险过高时，向下的波动会令你失去信心或低价抛售。投资组合风险过低时，会令你在牛市中表现不佳，但从未有人曾经因此而失败，这并不是最悲惨的命运。</p>\n</li>\n<li><p>错误的主要原因是分析/思维性的，或心理/情感性的。前者很简单：我们收集的信息太少或不准确，或分析错了。</p>\n</li>\n<li><p>贪婪和恐惧，资源终止怀疑和怀疑，自负和嫉妒，通过风险承担追求高额收益，高估自己的预测能力的倾向。这些因素助长了繁荣和崩溃的发生，而大多数投资者都参与其中，采取着完全错误的行动。</p>\n</li>\n<li><p>投资完全就是应对未来。为了投资，我们必须持有对未来的看法。一般来说，除了假定它会与过去十分相似之外，我们几乎别无选择。很少有人会说：“过去50年的美股平均市盈率是15，我预测在未来几年它会变成10（或20）。”</p>\n</li>\n<li><p>因此大多数投资者是根据既往----尤其是近期发生的事------推断未来。</p>\n</li>\n<li><p>想象无能首先是没有预测到未来可能发生的极端事件，其次是没有理解极端事件发生后的连锁后果。</p>\n</li>\n<li><p>在牛市中，怀疑不足使得这种错误心理因素事情经常发生，因为投资者相信：</p>\n<ol>\n<li><p>某些新发展会改变世界。</p>\n</li>\n<li><p>已成过去陈规的模式将不再存在。</p>\n</li>\n<li><p>规则已经改变。</p>\n</li>\n<li><p>传统价值不再适用（包括股票市盈率、债券收益率或房地产资本化率）。</p>\n</li>\n</ol>\n</li>\n<li><p>全球危机提供了一个绝好的学习机会，2007年，它涉及到许多严重错误和教训。到处都是错误：在危机前的日子里，投资者满不在乎甚至情绪高涨。人们相信风险已经被驱除，因此他们唯一要担心的是错过机会落后于人而不是亏损。</p>\n</li>\n<li><p>几乎没有人知道会出现怎样的后果，但可能会有即将失败的预感。尽管识别和避免具体错误并不容易，但这是一个很好的机会，令我们意识到有许多错误潜伏在暗处。进而持有防御性更强的仓位。做不到这点也是一个巨大的错误。</p>\n</li>\n<li><p>危机中充斥着潜在错误：首先屈服并认输，进而退缩并坐失良机。在没有损失的时候，人们往往将风险视为波动，并且相信自己能够容忍。如果真是这样，他们就会顺应价格下跌，在低点时作更多投资，继而享受复苏，在未来出人头地。</p>\n</li>\n<li><p>但是，如果容忍波动维持镇静的能力被高估了-----通常如此----那么在市场处于最低点时，错误往往就会显露出来。信心和决断的丧失，导致投资者在市场底部抛售，将下行趋势转变为永久损失，并且难以充分参与到随后的复苏中。</p>\n</li>\n<li><p>这样的错误是投资中最大的错误-----顺周期行为最不利的一面-----因为它是永久的，也因为它影响投资组合的很大一部分。</p>\n</li>\n<li><p>既然逆周期行为是避免近期危机全面影响的要素，那么顺周期行为就代表潜在的最大错误。在市场繁荣维持看涨仓位的投资者，为崩溃及随后的复苏准备得最不充分。</p>\n</li>\n<li><p>记住，除了作为（买进）和不作为（没有买进），还有错误并不明显的时候。当投资者心理平静、恐惧与贪婪平衡时，资产价格对于价值可能是公允的。在这种情况下可能不需要采取紧急行动，知道这一点也很重要。不需要取巧的时候，自作聪明就会带来潜在错误。</p>\n</li>\n</ol>\n<h2 id=\"第二十章：最重要的事\"><a href=\"#第二十章：最重要的事\" class=\"headerlink\" title=\"第二十章：最重要的事\"></a>第二十章：最重要的事</h2><ol>\n<li><p>成功的投资或成功的投资生涯的基础，是价值。你必须清楚地认识到你想买进的东西的价值。价值包括很多方面，并且有多种考察方法。简单来说，就是账面现金和有形资产价值，公司或资产产生现金流的能力，以及这些东西的增值潜力。</p>\n</li>\n<li><p>你必须以可靠的事实和分析为基础，建立并坚持自己的价值观。只有这样，你才能知道买进和卖出的时机。只有拥有良好的价值感，你才能培养在资产价格高涨并且人人认为会永远上涨的时候获利的纪律，或在危机时甚至价格日益下跌时持仓，并以低于平均价格买进的勇气。</p>\n</li>\n<li><p>价格和价值的关系是成功投资的关键。</p>\n</li>\n<li><p>优秀的投资者，他们的目标是买得好，而不是买好的。</p>\n</li>\n<li><p>最重要的一句投资格言：“智者始而愚者终。”抵制过度的能力是罕见的，但却是大多数成功投资者所具备的重要特质。</p>\n</li>\n<li><p>“定价过低”绝不等同于“很快上涨。”</p>\n</li>\n<li><p>第二局重要的格言：“过于超前与犯错没有区别。”在证明我们的正确性之前，我们需要足够的耐心与毅力长期坚持我们的立场。</p>\n</li>\n<li><p>风险控制和错误边际必须时刻在你的投资组合中提现出来。</p>\n</li>\n<li><p>我们无法预知宏观未来。很少有人对未来经济、利率、市场总量有超越群体共识的看法。因此，投资者的时间最好用在获取“可知”的知识优势上：行业、公司、证券的相关信息。</p>\n</li>\n<li><p>建立在坚定但不正确的预测基础上的投资，是潜在损失的根源。</p>\n</li>\n</ol>\n","categories":["read"],"tags":["note","investment"]},{"title":"浏览器的工作原理：新式网络浏览器幕后揭秘","url":"/2011/08/05/frontend/note-browser-operational-principle/","content":"<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaHRtbDVyb2Nrcy5jb20vemgvdHV0b3JpYWxzL2ludGVybmFscy9ob3dicm93c2Vyc3dvcmsv\">source page address<i class=\"fa fa-external-link-alt\"></i></span><br><a id=\"more\"></a></p>\n<h2 id=\"我们要讨论的浏览器\"><a href=\"#我们要讨论的浏览器\" class=\"headerlink\" title=\"我们要讨论的浏览器\"></a>我们要讨论的浏览器</h2><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 StatCounter 浏览器统计数据，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。</p>\n<h2 id=\"浏览器的主要功能\"><a href=\"#浏览器的主要功能\" class=\"headerlink\" title=\"浏览器的主要功能\"></a>浏览器的主要功能</h2><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p>\n<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</p>\n<p>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p>\n<p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p>\n<ul>\n<li>用来输入 URI 的地址栏</li>\n<li>前进和后退按钮</li>\n<li>书签设置选项</li>\n<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>\n<li>用于返回主页的主页按钮</li>\n</ul>\n<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p>\n<h2 id=\"浏览器的高层结构\"><a href=\"#浏览器的高层结构\" class=\"headerlink\" title=\"浏览器的高层结构\"></a>浏览器的高层结构</h2><p>浏览器的主要组件为 (1.1)：</p>\n<ul>\n<li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li>\n<li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>\n<li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li>\n<li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>\n</ul>\n<p><img data-src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png\" alt=\"图：浏览器的主要组件\"></p>\n<p><strong>图：浏览器的主要组件。</strong></p>\n<p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>\n<h2 id=\"呈现引擎\"><a href=\"#呈现引擎\" class=\"headerlink\" title=\"呈现引擎\"></a>呈现引擎</h2><p>呈现引擎的作用嘛...当然就是“呈现”了，也就是在浏览器的屏幕上显示请求的内容。</p>\n<p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p>\n<h3 id=\"呈现引擎-1\"><a href=\"#呈现引擎-1\" class=\"headerlink\" title=\"呈现引擎\"></a>呈现引擎</h3><p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>\n<p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 webkit.org。</p>\n<h4 id=\"主流程\"><a href=\"#主流程\" class=\"headerlink\" title=\"主流程\"></a>主流程</h4><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>\n<p>然后进行如下所示的基本流程：</p>\n<p><img data-src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png\" alt=\"呈现引擎的基本流程\"></p>\n<p><strong>图：呈现引擎的基本流程。</strong></p>\n<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：<strong>呈现树</strong>。</p>\n<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>\n<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n<h5 id=\"主流程示例\"><a href=\"#主流程示例\" class=\"headerlink\" title=\"主流程示例\"></a>主流程示例</h5><p><img data-src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png\" alt=\"\"></p>\n<p><strong>图：WebKit 主流程</strong></p>\n<p><img data-src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image008.jpg\" alt=\"\"></p>\n<p><strong>图：Mozilla 的 Gecko 呈现引擎主流程 (3.6)</strong></p>\n<p>从图 3 和图 4 可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>\n<p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p>\n<h5 id=\"解析-综述\"><a href=\"#解析-综述\" class=\"headerlink\" title=\"解析 - 综述\"></a>解析 - 综述</h5><p>解析是呈现引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。</p>\n<p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。</p>\n<p>示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的树：</p>\n<p><img data-src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image009.png\" alt=\"\"></p>\n<p><strong>图：数学表达式树节点</strong></p>\n<h5 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h5><p>解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。</p>\n<p>解析器和词法分析器的组合<br>解析的过程可以分成两个子过程：词法分析和语法分析。</p>\n<p>词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。</p>\n<p>语法分析是应用语言的语法规则的过程。</p>\n<p>解析器通常将解析工作分给以下两个组件来处理：词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。</p>\n<p><img data-src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image011.png\" alt=\"\"></p>\n<p><strong>图：从源文档到解析树</strong></p>\n<p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p>\n<p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p>\n<h5 id=\"翻译\"><a href=\"#翻译\" class=\"headerlink\" title=\"翻译\"></a>翻译</h5><p>很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p>\n<p><img data-src=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image013.png\" alt=\"\"></p>\n<p><strong>图：编译流程</strong></p>\n<h5 id=\"解析示例\"><a href=\"#解析示例\" class=\"headerlink\" title=\"解析示例\"></a>解析示例</h5><p>在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。</p>\n<p>词汇：我们用的语言可包含整数、加号和减号。</p>\n<p>语法：</p>\n<ul>\n<li>构成语言的语法单位是表达式、项和运算符。</li>\n<li>我们用的语言可以包含任意数量的表达式。</li>\n<li>表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。</li>\n<li>运算符是加号或减号。</li>\n<li>项是一个整数或一个表达式。</li>\n</ul>\n<p>让我们分析一下 2 + 3 - 1。<br>匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。</p>\n<p>词汇和语法的正式定义<br>词汇通常用正则表达式表示。</p>\n<p>例如，我们的示例语言可以定义如下：</p>\n<p>INTEGER :0|[1-9][0-9]*<br>PLUS : +<br>MINUS: -<br>正如您所看到的，这里用正则表达式给出了整数的定义。<br>语法通常使用一种称为 BNF 的格式来定义。我们的示例语言可以定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">expression :&#x3D;  term  operation  term</span><br><span class=\"line\">operation :&#x3D;  PLUS | MINUS</span><br><span class=\"line\">term :&#x3D; INTEGER | expression</span><br></pre></td></tr></table></figure>\n<p>之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅关于与上下文无关的语法的维基百科文章。</p>\n<h5 id=\"解析器类型\"><a href=\"#解析器类型\" class=\"headerlink\" title=\"解析器类型\"></a>解析器类型</h5><p>有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。</p>\n<p>让我们来看看这两种解析器会如何解析我们的示例：</p>\n<p>自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。</p>\n<p>自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>堆栈</th>\n<th>输入</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td></td>\n<td>2 + 3 - 1</td>\n</tr>\n<tr>\n<td>项</td>\n<td>+ 3 - 1</td>\n</tr>\n<tr>\n<td>项运算</td>\n<td>3 - 1</td>\n</tr>\n<tr>\n<td>表达式</td>\n<td>- 1</td>\n</tr>\n<tr>\n<td>表达式运算符</td>\n<td>1</td>\n</tr>\n<tr>\n<td>表达式</td>\n<td>---------</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。</p>\n<h5 id=\"自动生成解析器\"><a href=\"#自动生成解析器\" class=\"headerlink\" title=\"自动生成解析器\"></a>自动生成解析器</h5><p>有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。</p>\n<p>WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 Flex 以及用于创建解析器的 Bison（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。</p>\n<ul>\n<li><p>HTML 解析器<br>HTML 解析器的任务是将 HTML 标记解析成解析树。</p>\n</li>\n<li><p>HTML 语法定义<br>HTML 的词汇和语法在 W3C 组织创建的规范中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中。</p>\n</li>\n<li><p>非与上下文无关的语法<br>正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。</p>\n</li>\n</ul>\n<p>很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。</p>\n<p>有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。</p>\n<p>这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？</p>\n<p>区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。</p>\n<p>显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。</p>\n<h5 id=\"HTML-DTD\"><a href=\"#HTML-DTD\" class=\"headerlink\" title=\"HTML DTD\"></a>HTML DTD</h5><p>HTML 的定义采用了 DTD 格式。此格式可用于定义 SGML 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。</p>\n<p>DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：www.w3.org/TR/html4/strict.dtd</p>\n<h5 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h5><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是“Document”对象。</p>\n<p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;p&gt;</span><br><span class=\"line\">      Hello World</span><br><span class=\"line\">    &lt;&#x2F;p&gt;</span><br><span class=\"line\">    &lt;div&gt; &lt;img src&#x3D;&quot;example.png&quot;&#x2F;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>可翻译成如下的 DOM 树：</p>\n<p>图：示例标记的 DOM 树<br>和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 www.w3.org/DOM/DOMTR。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html。</p>\n<p>我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。</p>\n<h5 id=\"解析算法\"><a href=\"#解析算法\" class=\"headerlink\" title=\"解析算法\"></a>解析算法</h5><p>我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。</p>\n<p>原因在于：</p>\n<ul>\n<li>语言的宽容本质。</li>\n<li>浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li>\n<li>解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li>\n<li>由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。</li>\n</ul>\n<p>HTML5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。</p>\n<p>标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</p>\n<p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</p>\n<p>图：HTML 解析流程（摘自 HTML5 规范）<br>标记化算法<br>该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。</p>\n<p>基本示例 - 将下面的 HTML 代码标记化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    Hello world</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>初始状态是数据状态。遇到字符 &lt; 时，状态更改为“标记打开状态”。接收一个 a-z 字符会创建“起始标记”，状态更改为“标记名称状态”。这个状态会一直保持到接收 &gt; 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。</p>\n<p>遇到 &gt; 标记时，会发送当前的标记，状态改回“数据状态”。<body> 标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到“数据状态”。接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收 </body> 中的 &lt;。我们将为 Hello world 中的每个字符都发送一个字符标记。</p>\n<p>现在我们回到“标记打开状态”。接收下一个输入字符 / 时，会创建 end tag token 并改为“标记名称状态”。我们会再次保持这个状态，直到接收 &gt;。然后将发送新的标记，并回到“数据状态”。&lt;/html&gt; 输入也会进行同样的处理。</p>\n<p>图：对示例输入进行标记化</p>\n<h5 id=\"树构建算法\"><a href=\"#树构建算法\" class=\"headerlink\" title=\"树构建算法\"></a>树构建算法</h5><p>在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。</p>\n<p>让我们来看看示例输入的树构建过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    Hello world</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是“initial mode”。接收 HTML 标记后转为“before html”模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。</p>\n<p>然后状态将改为“before head”。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。</p>\n<p>现在我们进入了“in head”模式，然后转入“after head”模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为“in body”。</p>\n<p>现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。</p>\n<p>接收 body 结束标记会触发“after body”模式。现在我们将接收 HTML 结束标记，然后进入“after after body”模式。接收到文件结束标记后，解析过程就此结束。</p>\n<p>图：示例 HTML 的树构建</p>\n<h5 id=\"解析结束后的操作\"><a href=\"#解析结束后的操作\" class=\"headerlink\" title=\"解析结束后的操作\"></a>解析结束后的操作</h5><p>在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。</p>\n<p>您可以在 HTML5 规范中查看标记化和树构建的完整算法</p>\n<h5 id=\"浏览器的容错机制\"><a href=\"#浏览器的容错机制\" class=\"headerlink\" title=\"浏览器的容错机制\"></a>浏览器的容错机制</h5><p>您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。</p>\n<p>以下面的 HTML 代码为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;mytag&gt;</span><br><span class=\"line\">  &lt;&#x2F;mytag&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">  &lt;p&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">    Really lousy HTML</span><br><span class=\"line\">  &lt;&#x2F;p&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。</p>\n<p>不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。</p>\n<p>HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。</p>\n<p>解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。</p>\n<p>遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。</p>\n<p>我们至少要能够处理以下错误情况：</p>\n<p>明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。<br>我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。<br>向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。<br>如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。<br>让我们看一些 WebKit 容错的示例：</p>\n<p>使用了 <code>&lt;/br&gt;</code> 而不是 <code>&lt;br&gt;</code><br>有些网站使用了 <code>&lt;/br&gt;</code> 而不是 <code>&lt;br&gt;</code>。为了与 IE 和 Firefox 兼容，WebKit 将其与 <code>&lt;br&gt;</code> 做同样的处理。<br>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class=\"line\">     reportError(MalformedBRError);</span><br><span class=\"line\">     t-&gt;beginTag &#x3D; true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>请注意，错误处理是在内部进行的，用户并不会看到这个过程。</p>\n<h5 id=\"离散表格\"><a href=\"#离散表格\" class=\"headerlink\" title=\"离散表格\"></a>离散表格</h5><p>离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。<br>比如以下的示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">    &lt;table&gt;</span><br><span class=\"line\">        &lt;tr&gt;&lt;td&gt;inner table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">    &lt;&#x2F;table&gt;</span><br><span class=\"line\">    &lt;tr&gt;&lt;td&gt;outer table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>\n<p>WebKit 会将其层次结构更改为两个同级表格：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">    &lt;tr&gt;&lt;td&gt;outer table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;table&gt;</span><br><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">    &lt;tr&gt;&lt;td&gt;inner table&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><br>代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (m_inStrayTableContent &amp;&amp; localName &#x3D;&#x3D; tableTag)</span><br><span class=\"line\">        popBlock(tableTag);</span><br></pre></td></tr></table></figure></p>\n<p>WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。<br>嵌套的表单元素<br>如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。<br>代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (!m_currentFormElement) &#123;</span><br><span class=\"line\">        m_currentFormElement &#x3D; new HTMLFormElement(formTag,    m_document);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"过于复杂的标记层次结构\"><a href=\"#过于复杂的标记层次结构\" class=\"headerlink\" title=\"过于复杂的标记层次结构\"></a>过于复杂的标记层次结构</h5><p>代码的注释已经说得很清楚了。<br>示例网站 <code>www.liceo.edu.mx</code> 嵌套了约 1500 个标记，全都来自一堆 <code>&lt;b&gt;</code> 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">unsigned i &#x3D; 0;</span><br><span class=\"line\">for (HTMLStackElem* curr &#x3D; m_blockStack;</span><br><span class=\"line\">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName &#x3D;&#x3D; tagName;</span><br><span class=\"line\">     curr &#x3D; curr-&gt;next, i++) &#123; &#125;</span><br><span class=\"line\">return i !&#x3D; cMaxRedundantTagDepth;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"放错位置的-html-或者-body-结束标记\"><a href=\"#放错位置的-html-或者-body-结束标记\" class=\"headerlink\" title=\"放错位置的 html 或者 body 结束标记\"></a>放错位置的 html 或者 body 结束标记</h5><p>同样，代码的注释已经说得很清楚了。</p>\n<p>支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (t-&gt;tagName &#x3D;&#x3D; htmlTag || t-&gt;tagName &#x3D;&#x3D; bodyTag )</span><br><span class=\"line\">        return;</span><br></pre></td></tr></table></figure><br>所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。</p>\n<h3 id=\"CSS-解析\"><a href=\"#CSS-解析\" class=\"headerlink\" title=\"CSS 解析\"></a>CSS 解析</h3><p>还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，CSS 规范定义了 CSS 的词法和语法。</p>\n<p>让我们来看一些示例：<br>词法语法（词汇）是针对各个标记用正则表达式定义的：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>reg</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>comment</td>\n<td>\\/*<sup><a href=\"#fn_*\" id=\"reffn_*\">*</a></sup><em>\\</em>+(<sup><a href=\"#fn_/*\" id=\"reffn_/*\">/*</a></sup><sup><a href=\"#fn_*\" id=\"reffn_*\">*</a></sup><em>\\</em>+)*\\/</td>\n</tr>\n<tr>\n<td>num</td>\n<td>[0-9]+&#124;[0-9]*&quot;.&quot;[0-9]+</td>\n</tr>\n<tr>\n<td>nonascii</td>\n<td>[\\200-\\377]</td>\n</tr>\n<tr>\n<td>nmstart</td>\n<td>[_a-z]&#124;{nonascii}&#124;{escape}</td>\n</tr>\n<tr>\n<td>nmchar</td>\n<td>[_a-z0-9-]&#124;{nonascii}&#124;{escape}</td>\n</tr>\n<tr>\n<td>name</td>\n<td>{nmchar}+</td>\n</tr>\n<tr>\n<td>ident</td>\n<td>{nmstart}{nmchar}*</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过“#”来引用）。</p>\n<p>语法是采用 BNF 格式描述的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ruleset</span><br><span class=\"line\">  : selector [ &#39;,&#39; S* selector ]*</span><br><span class=\"line\">    &#39;&#123;&#39; S* declaration [ &#39;;&#39; S* declaration ]* &#39;&#125;&#39; S*</span><br><span class=\"line\">  ;</span><br><span class=\"line\">selector</span><br><span class=\"line\">  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?</span><br><span class=\"line\">  ;</span><br><span class=\"line\">simple_selector</span><br><span class=\"line\">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class=\"line\">  | [ HASH | class | attrib | pseudo ]+</span><br><span class=\"line\">  ;</span><br><span class=\"line\">class</span><br><span class=\"line\">  : &#39;.&#39; IDENT</span><br><span class=\"line\">  ;</span><br><span class=\"line\">element_name</span><br><span class=\"line\">  : IDENT | &#39;*&#39;</span><br><span class=\"line\">  ;</span><br><span class=\"line\">attrib</span><br><span class=\"line\">  : &#39;[&#39; S* IDENT S* [ [ &#39;&#x3D;&#39; | INCLUDES | DASHMATCH ] S*</span><br><span class=\"line\">    [ IDENT | STRING ] S* ] &#39;]&#39;</span><br><span class=\"line\">  ;</span><br><span class=\"line\">pseudo</span><br><span class=\"line\">  : &#39;:&#39; [ IDENT | FUNCTION S* [IDENT S*] &#39;)&#39; ]</span><br><span class=\"line\">  ; 解释：这是一个规则集的结构：</span><br><span class=\"line\">div.error , a.error &#123;</span><br><span class=\"line\">  color:red;</span><br><span class=\"line\">  font-weight:bold;</span><br><span class=\"line\">&#125; div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：</span><br><span class=\"line\">ruleset</span><br><span class=\"line\">  : selector [ &#39;,&#39; S* selector ]*</span><br><span class=\"line\">    &#39;&#123;&#39; S* declaration [ &#39;;&#39; S* declaration ]* &#39;&#125;&#39; S*</span><br><span class=\"line\">  ;</span><br></pre></td></tr></table></figure>\n<p>这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。<br>WebKit CSS 解析器<br>WebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p>\n<p>图：解析 CSS</p>\n<h5 id=\"处理脚本和样式表的顺序\"><a href=\"#处理脚本和样式表的顺序\" class=\"headerlink\" title=\"处理脚本和样式表的顺序\"></a>处理脚本和样式表的顺序</h5><h5 id=\"脚本\"><a href=\"#脚本\" class=\"headerlink\" title=\"脚本\"></a>脚本</h5><p>网络的模型是同步的。网页作者希望解析器遇到 <script> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>\n<h5 id=\"预解析\"><a href=\"#预解析\" class=\"headerlink\" title=\"预解析\"></a>预解析</h5><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>\n<h5 id=\"样式表\"><a href=\"#样式表\" class=\"headerlink\" title=\"样式表\"></a>样式表</h5><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>\n<h5 id=\"呈现树构建\"><a href=\"#呈现树构建\" class=\"headerlink\" title=\"呈现树构建\"></a>呈现树构建</h5><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p>\n<p>Firefox 将呈现树中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。<br>呈现器知道如何布局并将自身及其子元素绘制出来。<br>WebKits RenderObject 类是所有呈现器的基类，其定义如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">class RenderObject&#123;</span><br><span class=\"line\">  virtual void layout();</span><br><span class=\"line\">  virtual void paint(PaintInfo);</span><br><span class=\"line\">  virtual void rect repaintRect();</span><br><span class=\"line\">  Node* node;  &#x2F;&#x2F;the DOM node</span><br><span class=\"line\">  RenderStyle* style;  &#x2F;&#x2F; the computed style</span><br><span class=\"line\">  RenderLayer* containgLayer; &#x2F;&#x2F;the containing z-index layer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。<br>框的类型会受到与节点相关的“display”样式属性的影响（请参阅样式计算章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Document* doc &#x3D; node-&gt;document();</span><br><span class=\"line\">    RenderArena* arena &#x3D; doc-&gt;renderArena();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    RenderObject* o &#x3D; 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    switch (style-&gt;display()) &#123;</span><br><span class=\"line\">        case NONE:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case INLINE:</span><br><span class=\"line\">            o &#x3D; new (arena) RenderInline(node);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case BLOCK:</span><br><span class=\"line\">            o &#x3D; new (arena) RenderBlock(node);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case INLINE_BLOCK:</span><br><span class=\"line\">            o &#x3D; new (arena) RenderBlock(node);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case LIST_ITEM:</span><br><span class=\"line\">            o &#x3D; new (arena) RenderListItem(node);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。<br>在 WebKit 中，如果一个元素需要创建特殊的呈现器，就会替换 createRenderer 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。</p>\n<h5 id=\"呈现树和-DOM-树的关系\"><a href=\"#呈现树和-DOM-树的关系\" class=\"headerlink\" title=\"呈现树和 DOM 树的关系\"></a>呈现树和 DOM 树的关系</h5><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。<br>有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。<br>另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p>\n<p>有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。</p>\n<p>图：呈现树及其对应的 DOM 树 (3.1)。初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。<br>构建呈现树的流程<br>在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。</p>\n<p>在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。</p>\n<p>处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。</p>\n<p>请参阅关于处理模型的 CSS2 规范。</p>\n<h5 id=\"样式计算\"><a href=\"#样式计算\" class=\"headerlink\" title=\"样式计算\"></a>样式计算</h5><p>构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p>\n<p>样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。</p>\n<p>样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。</p>\n<p>样式计算存在以下难点：</p>\n<p>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。<br>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</p>\n<p>例如下面这个组合选择器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">div div div div&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这意味着规则适用于作为 3 个 div 元素的子代的 <div>。如果您要检查规则是否适用于某个指定的 <div> 元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。<br>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。<br>让我们来看看浏览器是如何处理这些问题的：</p>\n<h5 id=\"共享样式数据\"><a href=\"#共享样式数据\" class=\"headerlink\" title=\"共享样式数据\"></a>共享样式数据</h5><p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p>\n<p>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）</p>\n<ul>\n<li>任何元素都没有 ID</li>\n<li>标记名称应匹配</li>\n<li>类属性应匹配</li>\n<li>映射属性的集合必须是完全相同的</li>\n<li>链接状态必须匹配</li>\n<li>焦点状态必须匹配</li>\n</ul>\n<p>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配<br>元素中不能有任何 inline 样式属性<br>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</p>\n<h5 id=\"Firefox-规则树\"><a href=\"#Firefox-规则树\" class=\"headerlink\" title=\"Firefox 规则树\"></a>Firefox 规则树</h5><p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p>\n<p>图：Firefox 样式上下文树 (2.2)<br>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。</p>\n<p>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p>\n<p>这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：</p>\n<p>假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。<br>让我们看看规则树如何帮助我们减少工作。</p>\n<h5 id=\"结构划分\"><a href=\"#结构划分\" class=\"headerlink\" title=\"结构划分\"></a>结构划分</h5><p>样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。</p>\n<p>规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。</p>\n<h5 id=\"使用规则树计算样式上下文\"><a href=\"#使用规则树计算样式上下文\" class=\"headerlink\" title=\"使用规则树计算样式上下文\"></a>使用规则树计算样式上下文</h5><p>在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。<br>如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。</p>\n<p>如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在上下文树中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。</p>\n<p>如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。</p>\n<p>如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享整个样式上下文。</p>\n<p>让我们来看一个例子，假设我们有如下 HTML 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;err&quot; id&#x3D;&quot;div1&quot;&gt;</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        this is a &lt;span class&#x3D;&quot;big&quot;&gt; big error &lt;&#x2F;span&gt;</span><br><span class=\"line\">        this is also a</span><br><span class=\"line\">        &lt;span class&#x3D;&quot;big&quot;&gt; very  big  error&lt;&#x2F;span&gt; error</span><br><span class=\"line\">      &lt;&#x2F;p&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;err&quot; id&#x3D;&quot;div2&quot;&gt;another error&lt;&#x2F;div&gt;</span><br><span class=\"line\">  &lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n<p>还有如下规则：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">div &#123;margin:5px;color:black&#125;</span><br><span class=\"line\">.err &#123;color:red&#125;</span><br><span class=\"line\">.big &#123;margin-top:3px&#125;</span><br><span class=\"line\">div span &#123;margin-bottom:4px&#125;</span><br><span class=\"line\">#div1 &#123;color:blue&#125;</span><br><span class=\"line\">#div2 &#123;color:green&#125;</span><br></pre></td></tr></table></figure></p>\n<p>为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。<br>形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：</p>\n<p>图：规则树</p>\n<p>上下文树如下图所示（节点名 : 指向的规则节点）：</p>\n<p>图：上下文树<br>假设我们解析 HTML 时遇到了第二个 <div> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。<br>经过规则匹配，我们发现该 <div> 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。<br>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。</p>\n<p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p>\n<p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。</p>\n<p>第二个 <span> 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</p>\n<p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。<br>例如，如果我们在某个段落中添加 font 规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</span><br></pre></td></tr></table></figure>\n<p>那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。<br>在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。<br>因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 1 和问题 3。Firefox 规则树还有助于按照正确的顺序应用属性。</p>\n<p>对规则进行处理以简化匹配<br>样式规则有一些来源：</p>\n<p>外部样式表或样式元素中的 CSS 规则<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &#123;color:blue&#125;</span><br></pre></td></tr></table></figure><br>inline 样式属性及类似内容<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p style&#x3D;&quot;color:blue&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><br>HTML 可视化属性（映射到相关的样式规则）<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p bgcolor&#x3D;&quot;blue&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><br>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p>\n<p>我们之前在第 2 个问题中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。</p>\n<p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。<br>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (4.1)。</p>\n<p>我们以如下的样式规则为例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">p.error &#123;color:red&#125;</span><br><span class=\"line\">#messageDiv &#123;height:50px&#125;</span><br><span class=\"line\">div &#123;margin:5px&#125;</span><br></pre></td></tr></table></figure>\n<p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。<br>对于下面的 HTML 代码段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p class&#x3D;&quot;error&quot;&gt;an error occurred &lt;&#x2F;p&gt;</span><br><span class=\"line\">&lt;div id&#x3D;&quot;messageDiv&quot;&gt;this is a message&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<p>我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。<br>例如，如果 div 的对应规则如下：</p>\n<p>table div {margin:5px} 这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。<br>WebKit 和 Firefox 都进行了这一处理。</p>\n<p>以正确的层叠顺序应用规则<br>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p>\n<p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p>\n<p>样式表层叠顺序<br>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p>\n<ul>\n<li>浏览器声明</li>\n<li>用户普通声明</li>\n<li>作者普通声明</li>\n<li>作者重要声明</li>\n<li>用户重要声明</li>\n</ul>\n<p>浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据特异性进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。</p>\n<h4 id=\"特异性\"><a href=\"#特异性\" class=\"headerlink\" title=\"特异性\"></a>特异性</h4><p>选择器的特异性由 CSS2 规范定义如下：</p>\n<ul>\n<li>如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)</li>\n<li>记为选择器中 ID 属性的个数 (= b)</li>\n<li>记为选择器中其他属性和伪类的个数 (= c)</li>\n<li>记为选择器中元素名称和伪元素的个数 (= d)</li>\n<li>将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。</li>\n<li>您使用的进制取决于上述类别中的最高计数。</li>\n</ul>\n<p>例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p ...（在选择器中出现了 17 个标记，这样的可能性极低）。</p>\n<p>一些示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">*             &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 0,0,0,0 *&#x2F;</span><br><span class=\"line\">li            &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;1 -&gt; specificity &#x3D; 0,0,0,1 *&#x2F;</span><br><span class=\"line\">li:first-line &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;2 -&gt; specificity &#x3D; 0,0,0,2 *&#x2F;</span><br><span class=\"line\">ul li         &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;2 -&gt; specificity &#x3D; 0,0,0,2 *&#x2F;</span><br><span class=\"line\">ul ol+li      &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;0 d&#x3D;3 -&gt; specificity &#x3D; 0,0,0,3 *&#x2F;</span><br><span class=\"line\">h1 + *[rel&#x3D;up]&#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;1 d&#x3D;1 -&gt; specificity &#x3D; 0,0,1,1 *&#x2F;</span><br><span class=\"line\">ul ol li.red  &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;1 d&#x3D;3 -&gt; specificity &#x3D; 0,0,1,3 *&#x2F;</span><br><span class=\"line\">li.red.level  &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;0 c&#x3D;2 d&#x3D;1 -&gt; specificity &#x3D; 0,0,2,1 *&#x2F;</span><br><span class=\"line\">#x34y         &#123;&#125;  &#x2F;* a&#x3D;0 b&#x3D;1 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 0,1,0,0 *&#x2F;</span><br><span class=\"line\">style&#x3D;&quot;&quot;          &#x2F;* a&#x3D;1 b&#x3D;0 c&#x3D;0 d&#x3D;0 -&gt; specificity &#x3D; 1,0,0,0 *&#x2F;</span><br></pre></td></tr></table></figure>\n<h5 id=\"规则排序\"><a href=\"#规则排序\" class=\"headerlink\" title=\"规则排序\"></a>规则排序</h5><p>找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换“&gt;”运算符来实现排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int spec1 &#x3D; r1.selector()-&gt;specificity();</span><br><span class=\"line\">    int spec2 &#x3D; r2.selector()-&gt;specificity();</span><br><span class=\"line\">    return (spec1 &#x3D;&#x3D; spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"渐进式处理\"><a href=\"#渐进式处理\" class=\"headerlink\" title=\"渐进式处理\"></a>渐进式处理</h5><p>WebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。</p>\n<h5 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h5><p>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p>\n<p>HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (3.5)。</p>\n<p>坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。</p>\n<p>布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</p>\n<p>根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。<br>所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。</p>\n<h5 id=\"Dirty-位系统\"><a href=\"#Dirty-位系统\" class=\"headerlink\" title=\"Dirty 位系统\"></a>Dirty 位系统</h5><p>为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。</p>\n<p>有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。</p>\n<h5 id=\"全局布局和增量布局\"><a href=\"#全局布局和增量布局\" class=\"headerlink\" title=\"全局布局和增量布局\"></a>全局布局和增量布局</h5><p>全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：</p>\n<p>影响所有呈现器的全局样式更改，例如字体大小更改。<br>屏幕大小调整。<br>布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。<br>当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。</p>\n<p>图：增量布局 - 只有 dirty 呈现器及其子代进行布局 (3.6)。</p>\n<h5 id=\"异步布局和同步布局\"><a href=\"#异步布局和同步布局\" class=\"headerlink\" title=\"异步布局和同步布局\"></a>异步布局和同步布局</h5><p>增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。<br>请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。<br>全局布局往往是同步触发的。<br>有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。</p>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><p>如果布局是由“大小调整”或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。<br>在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。<br>布局处理<br>布局通常具有以下模式：</p>\n<p>父呈现器确定自己的宽度。<br>父呈现器依次处理子呈现器，并且：<br>放置子呈现器（设置 x,y 坐标）。<br>如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。<br>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。<br>将其 dirty 位设置为 false。<br>Firefox 使用“state”对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。<br>Firefox 布局的输出为“metrics”对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。</p>\n<h5 id=\"宽度计算\"><a href=\"#宽度计算\" class=\"headerlink\" title=\"宽度计算\"></a>宽度计算</h5><p>呈现器宽度是根据容器块的宽度、呈现器样式中的“width”属性以及边距和边框计算得出的。<br>例如以下 div 的宽度：</p>\n<p><code>&lt;div style=&quot;width:30%&quot;/&gt;</code> 将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：<br>容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：</p>\n<h5 id=\"clientWidth-paddingLeft-paddingRight\"><a href=\"#clientWidth-paddingLeft-paddingRight\" class=\"headerlink\" title=\"clientWidth() - paddingLeft() - paddingRight()\"></a>clientWidth() - paddingLeft() - paddingRight()</h5><p>clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。<br>元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。<br>然后加上水平方向的边框和补白。<br>现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。<br>如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。<br>这些值会缓存起来，以用于需要布局而宽度不变的情况。</p>\n<h5 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h5><p>如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。</p>\n<h5 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h5><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p>\n<h5 id=\"全局绘制和增量绘制\"><a href=\"#全局绘制和增量绘制\" class=\"headerlink\" title=\"全局绘制和增量绘制\"></a>全局绘制和增量绘制</h5><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。<br>绘制顺序<br>CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p>\n<ul>\n<li>背景颜色</li>\n<li>背景图片</li>\n<li>边框</li>\n<li>子代</li>\n<li>轮廓</li>\n</ul>\n<h5 id=\"Firefox-显示列表\"><a href=\"#Firefox-显示列表\" class=\"headerlink\" title=\"Firefox 显示列表\"></a>Firefox 显示列表</h5><p>Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。<br>Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。</p>\n<h5 id=\"WebKit-矩形存储\"><a href=\"#WebKit-矩形存储\" class=\"headerlink\" title=\"WebKit 矩形存储\"></a>WebKit 矩形存储</h5><p>在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。</p>\n<h5 id=\"动态变化\"><a href=\"#动态变化\" class=\"headerlink\" title=\"动态变化\"></a>动态变化</h5><p>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</p>\n<h5 id=\"呈现引擎的线程\"><a href=\"#呈现引擎的线程\" class=\"headerlink\" title=\"呈现引擎的线程\"></a>呈现引擎的线程</h5><p>呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。<br>网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。</p>\n<h5 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h5><p>浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">while (!mExiting)</span><br><span class=\"line\">    NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"CSS2-可视化模型\"><a href=\"#CSS2-可视化模型\" class=\"headerlink\" title=\"CSS2 可视化模型\"></a>CSS2 可视化模型</h4><h5 id=\"画布\"><a href=\"#画布\" class=\"headerlink\" title=\"画布\"></a>画布</h5><p>根据 CSS2 规范，“画布”这一术语是指“用来呈现格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。</p>\n<p>根据 www.w3.org/TR/CSS2/zindex.html，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。</p>\n<h5 id=\"CSS-框模型\"><a href=\"#CSS-框模型\" class=\"headerlink\" title=\"CSS 框模型\"></a>CSS 框模型</h5><p>CSS 框模型描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。<br>每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。</p>\n<p>图：CSS2 框模型<br>每一个节点都会生成 0..n 个这样的框。<br>所有元素都有一个“display”属性，决定了它们所对应生成的框类型。示例：</p>\n<ul>\n<li>block  - generates a block box.</li>\n<li>inline - generates one or more inline boxes.</li>\n<li><p>none - no box is generated. 默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div”元素的 display 属性默认值是 block。<br>您可以在这里找到默认样式表示例：www.w3.org/TR/CSS2/sample.html</p>\n<h5 id=\"定位方案\"><a href=\"#定位方案\" class=\"headerlink\" title=\"定位方案\"></a>定位方案</h5><p>有三种定位方案：</p>\n</li>\n<li><p>普通：根据对象在文档中的位置进行定位，也就是说对象在呈现树中的位置和它在 DOM 树中的位置相似，并根据其框类型和尺寸进行布局。</p>\n</li>\n<li>浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。</li>\n<li>绝对：对象在呈现树中的位置和它在 DOM 树中的位置不同。</li>\n</ul>\n<p>定位方案是由“position”属性和“float”属性设置的。</p>\n<p>如果值是 static 和 relative，就是普通流<br>如果值是 absolute 和 fixed，就是绝对定位</p>\n<p>static 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。<br>框的布局方式是由以下因素决定的：</p>\n<p>框类型<br>框尺寸<br>定位方案<br>外部信息，例如图片大小和屏幕大小<br>框类型<br>block 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。</p>\n<p>图：block 框<br>inline 框：没有自己的 block，但是位于容器 block 内。</p>\n<p>图：inline 框<br>block 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。</p>\n<p>图：block 和 inline 格式<br>inline 框放置在行中或“行框”中。这些行至少和最高的框一样高，还可以更高，当框根据“底线”对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。</p>\n<p>图：行<br>定位<br>相对<br>相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。</p>\n<p>图：相对定位<br>浮动<br>浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 HTML 代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">  &lt;img style&#x3D;&quot;float:right&quot; src&#x3D;&quot;images&#x2F;image.gif&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;100&quot;&gt;</span><br><span class=\"line\">  Lorem ipsum dolor sit amet, consectetuer...</span><br><span class=\"line\">&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>\n<p>显示效果如下：</p>\n<p>图：浮动<br>绝对定位和固定定位<br>这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。</p>\n<p>图：固定定位</p>\n<p>请注意，即使在文档滚动时，固定框也不会移动。<br>分层展示<br>这是由 z-index CSS 属性指定的。它代表了框的第三个维度，也就是沿“z 轴”方向的位置。</p>\n<p>这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。<br>堆栈是按照 z-index 属性进行排序的。具有“z-index”属性的框形成了本地堆栈。视口具有外部堆栈。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class=\"line\">      div &#123;</span><br><span class=\"line\">        position: absolute;</span><br><span class=\"line\">        left: 2in;</span><br><span class=\"line\">        top: 2in;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p&gt;</span><br><span class=\"line\">    &lt;div</span><br><span class=\"line\">         style&#x3D;&quot;z-index: 3;background-color:red; width: 1in; height: 1in; &quot;&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div</span><br><span class=\"line\">         style&#x3D;&quot;z-index: 1;background-color:green;width: 2in; height: 2in;&quot;&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\"> &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>\n<p> 结果如下：</p>\n<p>图：固定定位<br>虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。</p>\n","categories":["FrontEnd","browser"],"tags":["note","FrontEnd","browser"]},{"title":"404","url":"//404.html","content":"<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">404</span><br><span class=\"line\">\tnot</span><br><span class=\"line\">\t\tfound</span><br><span class=\"line\">\t\t\t4444      4444    0000000000    4444      4444</span><br><span class=\"line\">\t\t\t4444      4444  00000000000000  4444      4444</span><br><span class=\"line\">\t\t\t4444      4444  0000      0000  4444      4444</span><br><span class=\"line\">\t\t\t44444444444444  0000      0000  44444444444444</span><br><span class=\"line\">\t\t\t 4444444444444  0000      0000   4444444444444</span><br><span class=\"line\">\t\t\t          4444  0000      0000            4444</span><br><span class=\"line\">\t\t\t          4444  0000      0000            4444</span><br><span class=\"line\">\t\t\t          4444  00000000000000            4444</span><br><span class=\"line\">\t\t\t          4444    0000000000              4444</span><br><span class=\"line\">\t\tnot</span><br><span class=\"line\">\tfound</span><br><span class=\"line\">404</span><br></pre></td></tr></table></figure>\n"},{"title":"About me","url":"/about/index.html","content":"<blockquote>\n<p>Action speak louder than words</p>\n<h4 id=\"Email-zhkf-hunter-icloud-com\"><a href=\"#Email-zhkf-hunter-icloud-com\" class=\"headerlink\" title=\"Email: zhkf.hunter@icloud.com\"></a>Email: zhkf.hunter@icloud.com</h4></blockquote>\n"},{"title":"categories","url":"/categories/index.html","content":""},{"title":"links","url":"/links/index.html","content":"<h2 id=\"前端工具箱\"><a href=\"#前端工具箱\" class=\"headerlink\" title=\"前端工具箱\"></a>前端工具箱</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZW9oeGouZ2l0Ym9va3MuaW8vZnJvbnQtZW5kLWRhdGFiYXNlL2NvbnRlbnQv\">前端工程师手册<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04v\">MDN Web 文档<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL2pzYmluLmNvbS8=\">JS Bin<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jYW5pdXNlLmNvbS8=\">Can I Use<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h4><p><span class=\"exturl\" data-url=\"aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8=\">ECMAScript 6 入门<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbi52dWVqcy5vcmcv\">Vue.js<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jc3M4OC5jb20vanFhcGktMS45Lw==\">jQuery API中文文档<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3plcHRvanNfYXBpLw==\">Zepto.js API 中文版<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL3VuZGVyc2NvcmUv\">Underscore.js<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jc3M4OC5jb20vZG9jL2JhY2tib25lLw==\">Backbone.js<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0NhaUppbnljL3Z1ZS1tdXNpYy13ZWJhcHA=\">vue-music-webapp<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdHlsdXMuYm9vdGNzcy5jb20v\">Stylus 中文文档<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vanEvc3R5bHVzLw==\">Stylus 中文版参考文档<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jc3M4OC5jb20vYm9vay9jc3MvcXVpY2tzZWFyY2guaHRt\">CSS参考手册<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jc3MtZG9vZGxlLmNvbS8=\">css-doodle<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"Front-end-news\"><a href=\"#Front-end-news\" class=\"headerlink\" title=\"Front end news\"></a>Front end news</h4><p><span class=\"exturl\" data-url=\"aHR0cDovLzJhbGl0eS5jb20v\">2ality<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"Others\"><a href=\"#Others\" class=\"headerlink\" title=\"Others\"></a>Others</h4><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc3BlZWQvZG9jcy9pbnNpZ2h0cy9ydWxlcz9obD16aC1DTg==\">PageSpeed Insights 规则<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25pZXdlaWRvbmcvZmV0b29s\">大前端工具集<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3dlYi5qb2Jib2xlLmNvbS84MTkxMi8=\">Chrome 控制台不完全指南<i class=\"fa fa-external-link-alt\"></i></span></p>\n"},{"title":"tags","url":"/tags/index.html","content":""}]
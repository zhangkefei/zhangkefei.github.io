<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="yandex-verification" content="3ac9ae36ddebb425">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangkefei.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"db.json"};
  </script>

  <meta name="description" content="编程世界里只存在两种基本元素，一个是数据，一个是代码。编程世界就是在数据和代码千丝万缕的纠缠中呈现出无限的生机和活力。">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript之禅">
<meta property="og:url" content="https://zhangkefei.github.io/2012/10/01/note/note-depth-analysis-of-javascript-data-structures/index.html">
<meta property="og:site_name" content="Themis">
<meta property="og:description" content="编程世界里只存在两种基本元素，一个是数据，一个是代码。编程世界就是在数据和代码千丝万缕的纠缠中呈现出无限的生机和活力。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2012-10-01T21:38:00.000Z">
<meta property="article:modified_time" content="2024-02-07T07:49:48.444Z">
<meta property="article:author" content="Themis">
<meta property="article:tag" content="note">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zhangkefei.github.io/2012/10/01/note/note-depth-analysis-of-javascript-data-structures/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Javascript之禅 | Themis</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Themis</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">92</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="book fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">42</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangkefei.github.io/2012/10/01/note/note-depth-analysis-of-javascript-data-structures/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Themis">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Themis">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Javascript之禅
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2012-10-01 21:38:00" itemprop="dateCreated datePublished" datetime="2012-10-01T21:38:00Z">2012-10-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index"><span itemprop="name">javascript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>编程世界里只存在两种基本元素，一个是数据，一个是代码。编程世界就是在数据和代码千丝万缕的纠缠中呈现出无限的生机和活力。<br><a id="more"></a></p>
<p>数据天生就是文静的，总想保持自己固有的本色；而代码却天生活泼，总想改变这个世界。</p>
<p>你看，数据代码间的关系与物质能量间的关系有着惊人的相似。数据也是有惯性的，如果没有代码来施加外力，她总保持自己原来的状态。而代码就象能量，他存在的唯一目的，就是要努力改变数据原来的状态。在代码改变数据的同时，也会因为数据的抗拒而反过来影响或改变代码原有的趋势。甚至在某些情况下，数据可以转变为代码，而代码却又有可能被转变为数据，或许还存在一个类似E=MC2形式的数码转换方程呢。然而，就是在数据和代码间这种即矛盾又统一的运转中，总能体现出计算机世界的规律，这些规律正是我们编写的程序逻辑。</p>
<p>不过，由于不同程序员有着不同的世界观，这些数据和代码看起来也就不尽相同。于是，不同世界观的程序员们运用各自的方法论，推动着编程世界的进化和发展。</p>
<p>众所周知，当今最流行的编程思想莫过于面向对象编程的思想。为什么面向对象的思想能迅速风靡编程世界呢？因为面向对象的思想首次把数据和代码结合成统一体，并以一个简单的对象概念呈现给编程者。这一下子就将原来那些杂乱的算法与子程序，以及纠缠不清的复杂数据结构，划分成清晰而有序的对象结构，从而理清了数据与代码在我们心中那团乱麻般的结。我们又可以有一个更清晰的思维，在另一个思想高度上去探索更加浩瀚的编程世界了。</p>
<h2 id="回归简单"><a href="#回归简单" class="headerlink" title="回归简单"></a>回归简单</h2><p>要理解JavaScript，你得首先放下对象和类的概念，回到数据和代码的本原。前面说过，编程世界只有数据和代码两种基本元素，而这两种元素又有着纠缠不清的关系。JavaScript就是把数据和代码都简化到最原始的程度。</p>
<p>JavaScript中的数据很简洁的。简单数据只有 undefined, null, boolean, number和string这五种，而复杂数据只有一种，即object。这就好比中国古典的朴素唯物思想，把世界最基本的元素归为金木水火土，其他复杂的物质都是由这五种基本元素组成。</p>
<p>JavaScript中的代码只体现为一种形式，就是function。</p>
<p>注意：以上单词都是小写的，不要和Number, String, Object, Function等JavaScript内置函数混淆了。要知道，JavaScript语言是区分大小写的呀!</p>
<p>任何一个JavaScript的标识、常量、变量和参数都只是unfined, null, bool, number, string, object 和 function类型中的一种，也就typeof返回值表明的类型。除此之外没有其他类型了。</p>
<p>先说说简单数据类型吧。</p>
<p>undefined: 代表一切未知的事物，啥都没有，无法想象，代码也就更无法去处理了。<br>注意：typeof(undefined) 返回也是 undefined。<br>可以将undefined赋值给任何变量或属性，但并不意味了清除了该变量，反而会因此多了一个属性。</p>
<p>null: 有那么一个概念，但没有东西。无中似有，有中还无。虽难以想象，但已经可以用代码来处理了。<br>注意：typeof(null)返回object，但null并非object，具有null值的变量也并非object。</p>
<p>boolean: 是就是，非就非，没有疑义。对就对，错就错，绝对明确。既能被代码处理，也可以控制代码的流程。</p>
<p>number: 线性的事物，大小和次序分明，多而不乱。便于代码进行批量处理，也控制代码的迭代和循环等。<br>注意：typeof(NaN)和typeof(Infinity)都返回number 。<br>NaN参与任何数值计算的结构都是NaN，而且 NaN != NaN 。<br>Infinity / Infinity = NaN 。</p>
<p>string: 面向人类的理性事物，而不是机器信号。人机信息沟通，代码据此理解人的意图等等，都靠它了。</p>
<p>简单类型都不是对象，JavaScript没有将对象化的能力赋予这些简单类型。直接被赋予简单类型常量值的标识符、变量和参数都不是一个对象。</p>
<p>所谓“对象化”，就是可以将数据和代码组织成复杂结构的能力。JavaScript中只有object类型和function类型提供了对象化的能力。</p>
<h4 id="没有类"><a href="#没有类" class="headerlink" title="没有类"></a>没有类</h4><p>object就是对象的类型。在JavaScript中不管多么复杂的数据和代码，都可以组织成object形式的对象。</p>
<p>但JavaScript却没有 “类”的概念！</p>
<p>对于许多面向对象的程序员来说，这恐怕是JavaScript中最难以理解的地方。是啊，几乎任何讲面向对象的书中，第一个要讲的就是“类”的概念，这可是面向对象的支柱。这突然没有了“类”，我们就象一下子没了精神支柱，感到六神无主。看来，要放下对象和类，达到“对象本无根，类型亦无形”的境界确实是件不容易的事情啊。</p>
<p>这样，我们先来看一段JavaScript程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var life &#x3D; &#123;&#125;;  </span><br><span class="line">for(life.age &#x3D; 1; life.age &lt;&#x3D; 3; life.age++)  </span><br><span class="line">&#123;  </span><br><span class="line">switch(life.age)  </span><br><span class="line">&#123;  </span><br><span class="line">case 1: life.body &#x3D; “卵细胞”;  </span><br><span class="line">life.say &#x3D; function()&#123;alert(this.age+this.body)&#125;;  </span><br><span class="line">break;  </span><br><span class="line">case 2: life.tail &#x3D; “尾巴”;  </span><br><span class="line">life.gill &#x3D; “腮”;  </span><br><span class="line">life.body &#x3D; “蝌蚪”;  </span><br><span class="line">life.say &#x3D; function()&#123;alert(this.age+this.body+”-”+this.tail+”,”+this.gill)&#125;;  </span><br><span class="line">break;  </span><br><span class="line">case 3: delete life.tail;  </span><br><span class="line">delete life.gill;  </span><br><span class="line">life.legs &#x3D; “四条腿”;  </span><br><span class="line">life.lung &#x3D; “肺”;  </span><br><span class="line">life.body &#x3D; “青蛙”;  </span><br><span class="line">life.say &#x3D; function()&#123;alert(this.age+this.body+”-”+this.legs+”,”+this.lung)&#125;;  </span><br><span class="line">break;  </span><br><span class="line">&#125;;  </span><br><span class="line">life.say();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这段JavaScript程序一开始产生了一个生命对象life，life诞生时只是一个光溜溜的对象，没有任何属性和方法。在第一次生命过程中，它有了一个身体属性body，并有了一个say方法，看起来是一个“卵细胞”。在第二次生命过程中，它又长出了“尾巴”和“腮”，有了tail和gill属性，显然它是一个“蝌蚪”。在第三次生命过程中，它的tail和gill属性消失了，但又长出了“四条腿”和“肺”，有了legs和lung属性，从而最终变成了“青蛙”。如果，你的想像力丰富的话，或许还能让它变成英俊的“王子”，娶个美丽的“公主”什么的。不过，在看完这段程序之后，请你思考一个问题：</p>
<p>我们一定需要类吗？</p>
<p>还记得儿时那个“小蝌蚪找妈妈”的童话吗？也许就在昨天晚，你的孩子刚好是在这个美丽的童话中进入梦乡的吧。可爱的小蝌蚪也就是在其自身类型不断演化过程中，逐渐变成了和妈妈一样的“类”，从而找到了自己的妈妈。这个童话故事中蕴含的编程哲理就是：对象的“类”是从无到有，又不断演化，最终又消失于无形之中的…</p>
<p>“类”，的确可以帮助我们理解复杂的现实世界，这纷乱的现实世界也的确需要进行分类。但如果我们的思想被“类”束缚住了，“类”也就变成了“累”。想象一下，如果一个生命对象开始的时就被规定了固定的“类”，那么它还能演化吗？蝌蚪还能变成青蛙吗？还可以给孩子们讲小蝌蚪找妈妈的故事吗？</p>
<p>所以，JavaScript中没有“类”，类已化于无形，与对象融为一体。正是由于放下了“类”这个概念，JavaScript的对象才有了其他编程语言所没有的活力。</p>
<p>如果，此时你的内心深处开始有所感悟，那么你已经逐渐开始理解JavaScript的禅机了。</p>
<h4 id="函数的魔力"><a href="#函数的魔力" class="headerlink" title="函数的魔力"></a>函数的魔力</h4><p>接下来，我们再讨论一下JavaScript函数的魔力吧。</p>
<p>JavaScript的代码就只有function一种形式，function就是函数的类型。也许其他编程语言还有procedure或 method等代码概念，但在JavaScript里只有function一种形式。当我们写下一个函数的时候，只不过是建立了一个function类型的实体而已。请看下面的程序：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myfunc()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”hello”);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">alert(typeof(myfunc));</span><br></pre></td></tr></table></figure><br>这个代码运行之后可以看到typeof(myfunc)返回的是function。以上的函数写法我们称之为“定义式”的，如果我们将其改写成下面的“变量式”的，就更容易理解了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myfunc &#x3D; function ()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”hello”);  </span><br><span class="line">&#125;;  </span><br><span class="line">alert(typeof(myfunc));</span><br></pre></td></tr></table></figure><br>这里明确定义了一个变量myfunc，它的初始值被赋予了一个function的实体。因此，typeof(myfunc)返回的也是function。其实，这两种函数的写法是等价的，除了一点细微差别，其内部实现完全相同。也就是说，我们写的这些JavaScript函数只是一个命了名的变量而已，其变量类型即为function，变量的值就是我们编写的函数代码体。</p>
<p>聪明的你或许立即会进一步的追问：既然函数只是变量，那么变量就可以被随意赋值并用到任意地方啰？</p>
<p>我们来看看下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myfunc &#x3D; function ()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”hello”);  </span><br><span class="line">&#125;;  </span><br><span class="line">myfunc(); &#x2F;&#x2F;第一次调用myfunc，输出hello  </span><br><span class="line">myfunc &#x3D; function ()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”yeah”);  </span><br><span class="line">&#125;;  </span><br><span class="line">myfunc(); &#x2F;&#x2F;第二次调用myfunc，将输出yeah</span><br></pre></td></tr></table></figure><br>这个程序运行的结果告诉我们：答案是肯定的！在第一次调用函数之后，函数变量又被赋予了新的函数代码体，使得第二次调用该函数时，出现了不同的输出。</p>
<p>好了，我们又来把上面的代码改成第一种定义式的函数形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myfunc ()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”hello”);  </span><br><span class="line">&#125;;  </span><br><span class="line">myfunc(); &#x2F;&#x2F;这里调用myfunc，输出yeah而不是hello  </span><br><span class="line"></span><br><span class="line">function myfunc ()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”yeah”);  </span><br><span class="line">&#125;;  </span><br><span class="line">myfunc(); &#x2F;&#x2F;这里调用myfunc，当然输出yeah</span><br></pre></td></tr></table></figure><br>按理说，两个签名完全相同的函数，在其他编程语言中应该是非法的。但在JavaScript中，这没错。不过，程序运行之后却发现一个奇怪的现象：两次调用都只是最后那个函数里输出的值！显然第一个函数没有起到任何作用。这又是为什么呢？</p>
<p>原来，JavaScript执行引擎并非一行一行地分析和执行程序，而是一段一段地分析执行的。而且，在同一段程序的分析执行中，定义式的函数语句会被提取出来优先执行。函数定义执行完之后，才会按顺序执行其他语句代码。也就是说，在第一次调用myfunc之前，第一个函数语句定义的代码逻辑，已被第二个函数定义语句覆盖了。所以，两次都调用都是执行最后一个函数逻辑了。</p>
<p>如果把这个JavaScript代码分成两段，例如将它们写在一个html中，并用<code>&lt;script/&gt;</code>标签将其分成这样的两块：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function myfunc ()</span><br><span class="line">&#123;</span><br><span class="line">alert(”hello”);</span><br><span class="line">&#125;;</span><br><span class="line">myfunc(); &#x2F;&#x2F;这里调用myfunc，输出hello</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myfunc ()</span><br><span class="line">&#123;</span><br><span class="line">alert(”yeah”);</span><br><span class="line">&#125;;</span><br><span class="line">myfunc(); &#x2F;&#x2F;这里调用myfunc，输出yeah</span><br><span class="line">&lt;&#x2F;script&gt;&#96;</span><br></pre></td></tr></table></figure><br>这时，输出才是各自按顺序来的，也证明了JavaScript的确是一段段地执行的。</p>
<p>一段代码中的定义式函数语句会优先执行，这似乎有点象静态语言的编译概念。所以，这一特征也被有些人称为：JavaScript的“预编译”。</p>
<p>大多数情况下，我们也没有必要去纠缠这些细节问题。只要你记住一点：JavaScript里的代码也是一种数据，同样可以被任意赋值和修改的，而它的值就是代码的逻辑。只是，与一般数据不同的是，函数是可以被调用执行的。</p>
<p>不过，如果JavaScript函数仅仅只有这点道行的话，这与C++的函数指针，DELPHI的方法指针，C#的委托相比，又有啥稀奇嘛！然而， JavaScript函数的神奇之处还体现在另外两个方面：一是函数function类型本身也具有对象化的能力，二是函数function与对象 object超然的结合能力。</p>
<h4 id="奇妙的对象"><a href="#奇妙的对象" class="headerlink" title="奇妙的对象"></a>奇妙的对象</h4><p>先来说说函数的对象化能力。</p>
<p>任何一个函数都可以为其动态地添加或去除属性，这些属性可以是简单类型，可以是对象，也可以是其他函数。也就是说，函数具有对象的全部特征，你完全可以把函数当对象来用。其实，函数就是对象，只不过比一般的对象多了一个括号“()”操作符，这个操作符用来执行函数的逻辑。即，函数本身还可以被调用，一般对象却不可以被调用，除此之外完全相同。请看下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Sing()  </span><br><span class="line">&#123;  </span><br><span class="line">with(arguments.callee)  </span><br><span class="line">alert(author + “：” + poem);  </span><br><span class="line">&#125;;  </span><br><span class="line">Sing.author &#x3D; “李白”;  </span><br><span class="line">Sing.poem &#x3D; “汉家秦地月，流影照明妃。一上玉关道，天涯去不归”;  </span><br><span class="line">Sing();  </span><br><span class="line">Sing.author &#x3D; “李战”;  </span><br><span class="line">Sing.poem &#x3D; “日出汉家天，月落阴山前。女儿琵琶怨，已唱三千年”;  </span><br><span class="line">Sing();</span><br></pre></td></tr></table></figure><br>在这段代码中，Sing函数被定义后，又给Sing函数动态地增加了author和poem属性。将author和poem属性设为不同的作者和诗句，在调用Sing()时就能显示出不同的结果。这个示例用一种诗情画意的方式，让我们理解了JavaScript函数就是对象的本质，也感受到了 JavaScript语言的优美。</p>
<p>好了，以上的讲述，我们应该算理解了function类型的东西都是和object类型一样的东西，这种东西被我们称为“对象”。我们的确可以这样去看待这些“对象”，因为它们既有“属性”也有“方法”嘛。但下面的代码又会让我们产生新的疑惑：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var anObject &#x3D; &#123;&#125;; &#x2F;&#x2F;一个对象  </span><br><span class="line">anObject.aProperty &#x3D; “Property of object”; &#x2F;&#x2F;对象的一个属性  </span><br><span class="line">anObject.aMethod &#x3D; function()&#123;alert(”Method of object”)&#125;; &#x2F;&#x2F;对象的一个方法  </span><br><span class="line">&#x2F;&#x2F;主要看下面：  </span><br><span class="line">alert(anObject[”aProperty”]); &#x2F;&#x2F;可以将对象当数组以属性名作为下标来访问属性  </span><br><span class="line">&#96;anObject[”aMethod”]()&#96;; &#x2F;&#x2F;可以将对象当数组以方法名作为下标来调用方法  </span><br><span class="line">for( var s in anObject) &#x2F;&#x2F;遍历对象的所有属性和方法进行迭代化处理  </span><br><span class="line">alert(s + ” is a ” + typeof(anObject[s]));  </span><br><span class="line">同样对于function类型的对象也是一样：  </span><br><span class="line">var aFunction &#x3D; function() &#123;&#125;; &#x2F;&#x2F;一个函数  </span><br><span class="line">aFunction.aProperty &#x3D; “Property of function”; &#x2F;&#x2F;函数的一个属性  </span><br><span class="line">aFunction.aMethod &#x3D; function()&#123;alert(”Method of function”)&#125;; &#x2F;&#x2F;函数的一个方法  </span><br><span class="line">&#x2F;&#x2F;主要看下面：</span><br><span class="line">alert(aFunction[”aProperty”]); &#x2F;&#x2F;可以将函数当数组以属性名作为下标来访问属性  </span><br><span class="line">&#96;aFunction[”aMethod”]()&#96;; &#x2F;&#x2F;可以将函数当数组以方法名作为下标来调用方法  </span><br><span class="line">for( var s in aFunction) &#x2F;&#x2F;遍历函数的所有属性和方法进行迭代化处理  </span><br><span class="line">alert(s + ” is a ” + typeof(aFunction[s]));</span><br></pre></td></tr></table></figure><br>是的，对象和函数可以象数组一样，用属性名或方法名作为下标来访问并处理。那么，它到底应该算是数组呢，还是算对象？</p>
<p>我们知道，数组应该算是线性数据结构，线性数据结构一般有一定的规律，适合进行统一的批量迭代操作等，有点像波。而对象是离散数据结构，适合描述分散的和个性化的东西，有点像粒子。因此，我们也可以这样问：JavaScript里的对象到底是波还是粒子？</p>
<p>如果存在对象量子论，那么答案一定是：波粒二象性！</p>
<p>因此，JavaScript里的函数和对象既有对象的特征也有数组的特征。这里的数组被称为“字典”，一种可以任意伸缩的名称值对儿的集合。其实， object和function的内部实现就是一个字典结构，但这种字典结构却通过严谨而精巧的语法表现出了丰富的外观。正如量子力学在一些地方用粒子来解释和处理问题，而在另一些地方却用波来解释和处理问题。你也可以在需要的时候，自由选择用对象还是数组来解释和处理问题。只要善于把握 JavaScript的这些奇妙特性，就可以编写出很多简洁而强大的代码来。</p>
<h4 id="放下对象"><a href="#放下对象" class="headerlink" title="放下对象"></a>放下对象</h4><p>我们再来看看function与object的超然结合吧。</p>
<p>在面向对象的编程世界里，数据与代码的有机结合就构成了对象的概念。自从有了对象，编程世界就被划分成两部分，一个是对象内的世界，一个是对象外的世界。对象天生具有自私的一面，外面的世界未经允许是不可访问对象内部的。对象也有大方的一面，它对外提供属性和方法，也为他人服务。不过，在这里我们要谈到一个有趣的问题，就是“对象的自我意识”。</p>
<p>什么？没听错吧？对象有自我意识？</p>
<p>可能对许多程序员来说，这的确是第一次听说。不过，请君看看C++、C#和Java的this，DELPHI的self，还有VB的me，或许你会恍然大悟！当然，也可能只是说句“不过如此”而已。</p>
<p>然而，就在对象将世界划分为内外两部分的同时，对象的“自我”也就随之产生。“自我意识”是生命的最基本特征！正是由于对象这种强大的生命力，才使得编程世界充满无限的生机和活力。</p>
<p>但对象的“自我意识”在带给我们快乐的同时也带来了痛苦和烦恼。我们给对象赋予了太多欲望，总希望它们能做更多的事情。然而，对象的自私使得它们互相争抢系统资源，对象的自负让对象变得复杂和臃肿，对象的自欺也往往带来挥之不去的错误和异常。我们为什么会有这么多的痛苦和烦恼呢？</p>
<p>为此，有一个人，在对象树下，整整想了九九八十一天，终于悟出了生命的痛苦来自于欲望，但究其欲望的根源是来自于自我意识。于是他放下了“自我”，在对象树下成了佛，从此他开始普度众生，传播真经。他的名字就叫释迦摩尼，而《JavaScript真经》正是他所传经书中的一本。</p>
<p>JavaScript中也有this，但这个this却与C++、C#或Java等语言的this不同。一般编程语言的this就是对象自己，而 JavaScript的this却并不一定！this可能是我，也可能是你，可能是他，反正是我中有你，你中有我，这就不能用原来的那个“自我”来理解 JavaScript这个this的含义了。为此，我们必须首先放下原来对象的那个“自我”。</p>
<p>我们来看下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WhoAmI() &#x2F;&#x2F;定义一个函数WhoAmI  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”I’m ” + this.name + ” of ” + typeof(this));  </span><br><span class="line">&#125;;  </span><br><span class="line">WhoAmI(); &#x2F;&#x2F;此时是this当前这段代码的全局对象，在浏览器中就是window对象，其name属性为空字符串。输出：I’m of object  </span><br><span class="line">var BillGates &#x3D; &#123;name: “Bill Gates”&#125;;  </span><br><span class="line">BillGates.WhoAmI &#x3D; WhoAmI; &#x2F;&#x2F;将函数WhoAmI作为BillGates的方法。  </span><br><span class="line">BillGates.WhoAmI(); &#x2F;&#x2F;此时的this是BillGates。输出：I’m Bill Gates of object  </span><br><span class="line">var SteveJobs &#x3D; &#123;name: “Steve Jobs”&#125;;  </span><br><span class="line">SteveJobs.WhoAmI &#x3D; WhoAmI; &#x2F;&#x2F;将函数WhoAmI作为SteveJobs的方法。  </span><br><span class="line">SteveJobs.WhoAmI(); &#x2F;&#x2F;此时的this是SteveJobs。输出：I’m Steve Jobs of object  </span><br><span class="line">WhoAmI.call(BillGates); &#x2F;&#x2F;直接将BillGates作为this，调用WhoAmI。输出：I’m Bill Gates of object  </span><br><span class="line">WhoAmI.call(SteveJobs); &#x2F;&#x2F;直接将SteveJobs作为this，调用WhoAmI。输出：I’m Steve Jobs of object  </span><br><span class="line">BillGates.WhoAmI.call(SteveJobs); &#x2F;&#x2F;将SteveJobs作为this，却调用BillGates的WhoAmI方法。输出：I’m Steve Jobs of object  </span><br><span class="line">SteveJobs.WhoAmI.call(BillGates); &#x2F;&#x2F;将BillGates作为this，却调用SteveJobs的WhoAmI方法。输出：I’m Bill Gates of object  </span><br><span class="line">WhoAmI.WhoAmI &#x3D; WhoAmI; &#x2F;&#x2F;将WhoAmI函数设置为自身的方法。  </span><br><span class="line">WhoAmI.name &#x3D; “WhoAmI”;  </span><br><span class="line">WhoAmI.WhoAmI(); &#x2F;&#x2F;此时的this是WhoAmI函数自己。输出：I’m WhoAmI of function  </span><br><span class="line">(&#123;name: “nobody”, WhoAmI: WhoAmI&#125;).WhoAmI(); &#x2F;&#x2F;临时创建一个匿名对象并设置属性后调用WhoAmI方法。输出：I’m nobody of object</span><br></pre></td></tr></table></figure><br>从上面的代码可以看出，同一个函数可以从不同的角度来调用，this并不一定是函数本身所属的对象。this只是在任意对象和function元素结合时的一个概念，是种结合比起一般对象语言的默认结合更加灵活，显得更加超然和洒脱。</p>
<p>在JavaScript函数中，你只能把this看成当前要服务的“这个”对象。this是一个特殊的内置参数，根据this参数，您可以访问到“这个” 对象的属性和方法，但却不能给this参数赋值。在一般对象语言中，方法体代码中的this可以省略的，成员默认都首先是“自己”的。但 JavaScript却不同，由于不存在“自我”，当访问“这个”对象时，this不可省略！</p>
<p>JavaScript提供了传递this参数的多种形式和手段，其中，象BillGates.WhoAmI()和SteveJobs.WhoAmI()这种形式，是传递this参数最正规的形式，此时的this就是函数所属的对象本身。而大多数情况下，我们也几乎很少去采用那些借花仙佛的调用形式。但只我们要明白JavaScript的这个“自我”与其他编程语言的“自我”是不同的，这是一个放下了的“自我”，这就是JavaScript特有的世界观。</p>
<h4 id="对象素描"><a href="#对象素描" class="headerlink" title="对象素描"></a>对象素描</h4><p>已经说了许多了许多话题了，但有一个很基本的问题我们忘了讨论，那就是：怎样建立对象？</p>
<p>在前面的示例中，我们已经涉及到了对象的建立了。我们使用了一种被称为JavaScript Object Notation(缩写JSON)的形式，翻译为中文就是“JavaScript对象表示法”。</p>
<p>JSON为创建对象提供了非常简单的方法。例如，<br>创建一个没有任何属性的对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>创建一个对象并设置属性及初始值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123;name: “Angel”, age: 18, married: false&#125;;</span><br></pre></td></tr></table></figure><br>创建一个对象并设置属性和方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var speaker &#x3D; &#123;text: “Hello World”, say: function()&#123;alert(this.text)&#125;&#125;;</span><br></pre></td></tr></table></figure><br>创建一个更复杂的对象，嵌套其他对象和对象数组等：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var company &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">name: “Microsoft”,</span><br><span class="line">product: “softwares”,</span><br><span class="line">chairman: &#123;name: “Bill Gates”, age: 53, Married: true&#125;,</span><br><span class="line">employees: [&#123;name: “Angel”, age: 26, Married: false&#125;, &#123;name: “Hanson”, age: 32, Marred: true&#125;],</span><br><span class="line">readme: function() &#123;document.write(this.name + ” product ” + this.product);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>JSON的形式就是用大括“{}”号包括起来的项目列表，每一个项目间并用逗号“,”分隔，而项目就是用冒号“:”分隔的属性名和属性值。这是典型的字典表示形式，也再次表明了 JavaScript里的对象就是字典结构。不管多么复杂的对象，都可以被一句JSON代码来创建并赋值。</p>
<p>其实，JSON就是JavaScript对象最好的序列化形式，它比XML更简洁也更省空间。对象可以作为一个JSON形式的字符串，在网络间自由传递和交换信息。而当需要将这个JSON字符串变成一个JavaScript对象时，只需要使用eval函数这个强大的数码转换引擎，就立即能得到一个 JavaScript内存对象。正是由于JSON的这种简单朴素的天生丽质，才使得她在AJAX舞台上成为璀璨夺目的明星。</p>
<p>JavaScript就是这样，把面向对象那些看似复杂的东西，用及其简洁的形式表达出来。卸下对象浮华的浓妆，还对象一个眉目清晰！</p>
<h4 id="构造对象"><a href="#构造对象" class="headerlink" title="构造对象"></a>构造对象</h4><p>好了，接下我们来讨论一下对象的另一种创建方法。</p>
<p>除JSON外，在JavaScript中我们可以使用new操作符结合一个函数的形式来创建对象。例如：<br>function MyFunc() {}; //定义一个空函数<br>var anObj = new MyFunc(); //使用new操作符，借助MyFun函数，就创建了一个对象</p>
<p>JavaScript的这种创建对象的方式可真有意思，如何去理解这种写法呢？</p>
<p>其实，可以把上面的代码改写成这种等价形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function MyFunc()&#123;&#125;;  </span><br><span class="line">var anObj &#x3D; &#123;&#125;; &#x2F;&#x2F;创建一个对象  </span><br><span class="line">MyFunc.call(anObj); &#x2F;&#x2F;将anObj对象作为this指针调用MyFunc函数</span><br></pre></td></tr></table></figure><br>我们就可以这样理解，JavaScript先用new操作符创建了一个对象，紧接着就将这个对象作为this参数调用了后面的函数。其实， JavaScript内部就是这么做的，而且任何函数都可以被这样调用！但从 “anObj = new MyFunc()” 这种形式，我们又看到一个熟悉的身影，C++和C#不就是这样创建对象的吗？原来，条条大路通灵山，殊途同归啊！</p>
<p>君看到此处也许会想，我们为什么不可以把这个MyFunc当作构造函数呢？恭喜你，答对了！JavaScript也是这么想的！请看下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name) &#x2F;&#x2F;带参数的构造函数  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name; &#x2F;&#x2F;将参数值赋给给this对象的属性  </span><br><span class="line">this.SayHello &#x3D; function() &#123;alert(”Hello, I’m ” + this.name);&#125;; &#x2F;&#x2F;给this对象定义一个SayHello方法。  </span><br><span class="line">&#125;;  </span><br><span class="line">function Employee(name, salary) &#x2F;&#x2F;子构造函数  </span><br><span class="line">&#123;  </span><br><span class="line">Person.call(this, name); &#x2F;&#x2F;将this传给父构造函数  </span><br><span class="line">this.salary &#x3D; salary; &#x2F;&#x2F;设置一个this的salary属性  </span><br><span class="line">this.ShowMeTheMoney &#x3D; function() &#123;alert(this.name + ” $” +   this.salary);&#125;; &#x2F;&#x2F;添加ShowMeTheMoney方法。  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;用Person构造函数创建BillGates对象  </span><br><span class="line">var SteveJobs &#x3D; new Employee(”Steve Jobs”, 1234); &#x2F;&#x2F;用Empolyee构造函数创建SteveJobs对象  </span><br><span class="line"></span><br><span class="line">BillGates.SayHello(); &#x2F;&#x2F;显示：I’m Bill Gates  </span><br><span class="line">SteveJobs.SayHello(); &#x2F;&#x2F;显示：I’m Steve Jobs  </span><br><span class="line">SteveJobs.ShowMeTheMoney(); &#x2F;&#x2F;显示：Steve Jobs $1234  </span><br><span class="line"></span><br><span class="line">alert(BillGates.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;显示：true  </span><br><span class="line">alert(SteveJobs.constructor &#x3D;&#x3D; Employee); &#x2F;&#x2F;显示：true  </span><br><span class="line">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：false</span><br></pre></td></tr></table></figure><br>这段代码表明，函数不但可以当作构造函数，而且还可以带参数，还可以为对象添加成员和方法。其中的第9行，Employee构造函数又将自己接收的 this作为参数调用Person构造函数，这就是相当于调用基类的构造函数。第21、22行还表明这样一个意思：BillGates是由Person构造的，而SteveJobs是由Employee构造的。对象内置的constructor属性还指明了构造对象所用的具体函数！</p>
<p>其实，如果你愿意把函数当作“类”的话，她就是“类”，因为她本来就有“类”的那些特征。难道不是吗？她生出的儿子各个都有相同的特征，而且构造函数也与类同名嘛！</p>
<p>但要注意的是，用构造函数操作this对象创建出来的每一个对象，不但具有各自的成员数据，而且还具有各自的方法数据。换句话说，方法的代码体(体现函数逻辑的数据)在每一个对象中都存在一个副本。尽管每一个代码副本的逻辑是相同的，但对象们确实是各自保存了一份代码体。上例中的最后一句说明了这一实事，这也解释了JavaScript中的函数就是对象的概念。</p>
<p>同一类的对象各自有一份方法代码显然是一种浪费。在传统的对象语言中，方法函数并不象JavaScript那样是个对象概念。即使也有象函数指针、方法指针或委托那样的变化形式，但其实质也是对同一份代码的引用。一般的对象语言很难遇到这种情况。</p>
<p>不过，JavaScript语言有大的灵活性。我们可以先定义一份唯一的方法函数体，并在构造this对象时使用这唯一的函数对象作为其方法，就能共享方法逻辑。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function SayHello() &#x2F;&#x2F;先定义一份SayHello函数代码  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">function Person(name) &#x2F;&#x2F;带参数的构造函数  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name; &#x2F;&#x2F;将参数值赋给给this对象的属性  </span><br><span class="line">this.SayHello &#x3D; SayHello; &#x2F;&#x2F;给this对象SayHello方法赋值为前面那份SayHello代码。</span><br><span class="line">&#125;;  </span><br><span class="line">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;创建BillGates对象  </span><br><span class="line">var SteveJobs &#x3D; new Person(”Steve Jobs”); &#x2F;&#x2F;创建SteveJobs对象  </span><br><span class="line">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：true</span><br></pre></td></tr></table></figure><br>其中，最后一行的输出结果表明两个对象确实共享了一个函数对象。虽然，这段程序达到了共享了一份方法代码的目的，但却不怎么优雅。因为，定义 SayHello方法时反映不出其与Person类的关系。“优雅”这个词用来形容代码，也不知道是谁先提出来的。不过，这个词反映了程序员已经从追求代码的正确、高效、可靠和易读等基础上，向着追求代码的美观感觉和艺术境界的层次发展，程序人生又多了些浪漫色彩。</p>
<p>显然，JavaScript早想到了这一问题，她的设计者们为此提供了一个有趣的prototype概念。</p>
<h4 id="初看原型"><a href="#初看原型" class="headerlink" title="初看原型"></a>初看原型</h4><p>prototype源自法语，软件界的标准翻译为“原型”，代表事物的初始形态，也含有模型和样板的意义。JavaScript中的prototype概念恰如其分地反映了这个词的内含，我们不能将其理解为C++的prototype那种预先声明的概念。</p>
<p>JavaScript的所有function类型的对象都有一个prototype属性。这个prototype属性本身又是一个object类型的对象，因此我们也可以给这个prototype对象添加任意的属性和方法。既然prototype是对象的“原型”，那么由该函数构造出来的对象应该都会具有这个“原型”的特性。事实上，在构造函数的prototype上定义的所有属性和方法，都是可以通过其构造的对象直接访问和调用的。也可以这么说， prototype提供了一群同类对象共享属性和方法的机制。</p>
<p>我们先来看看下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name; &#x2F;&#x2F;设置对象属性，每个对象各自一份属性数据  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;给Person函数的prototype添加SayHello方法。  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;创建BillGates对象  </span><br><span class="line">var SteveJobs &#x3D; new Person(”Steve Jobs”); &#x2F;&#x2F;创建SteveJobs对象</span><br><span class="line"></span><br><span class="line">BillGates.SayHello(); &#x2F;&#x2F;通过BillGates对象直接调用到SayHello方法  </span><br><span class="line">SteveJobs.SayHello(); &#x2F;&#x2F;通过SteveJobs对象直接调用到SayHello方法</span><br><span class="line"></span><br><span class="line">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;因为两个对象是共享prototype的SayHello，所以显示：true</span><br></pre></td></tr></table></figure><br>程序运行的结果表明，构造函数的prototype上定义的方法确实可以通过对象直接调用到，而且代码是共享的。显然，把方法设置到prototype的写法显得优雅多了，尽管调用形式没有变，但逻辑上却体现了方法与类的关系，相对前面的写法，更容易理解和组织代码。</p>
<p>那么，对于多层次类型的构造函数情况又如何呢？</p>
<p>我们再来看下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name) &#x2F;&#x2F;基类构造函数  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;给基类构造函数的prototype添加方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">function Employee(name, salary) &#x2F;&#x2F;子类构造函数  </span><br><span class="line">&#123;  </span><br><span class="line">Person.call(this, name); &#x2F;&#x2F;调用基类构造函数  </span><br><span class="line">this.salary &#x3D; salary;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">Employee.prototype &#x3D; new Person(); &#x2F;&#x2F;建一个基类的对象作为子类原型的原型，这里很有意思</span><br><span class="line"></span><br><span class="line">Employee.prototype.ShowMeTheMoney &#x3D; function() &#x2F;&#x2F;给子类添构造函数的prototype添加方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(this.name + ” $” + this.salary);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;创建基类Person的BillGates对象  </span><br><span class="line">var SteveJobs &#x3D; new Employee(”Steve Jobs”, 1234); &#x2F;&#x2F;创建子类Employee的SteveJobs对象</span><br><span class="line"></span><br><span class="line">BillGates.SayHello(); &#x2F;&#x2F;通过对象直接调用到prototype的方法    SteveJobs.SayHello(); &#x2F;&#x2F;通过子类对象直接调用基类prototype的方法，关注！  </span><br><span class="line">SteveJobs.ShowMeTheMoney(); &#x2F;&#x2F;通过子类对象直接调用子类prototype的方法  </span><br><span class="line"></span><br><span class="line">alert(BillGates.SayHello &#x3D;&#x3D; SteveJobs.SayHello); &#x2F;&#x2F;显示：true，表明prototype的方法是共享的</span><br></pre></td></tr></table></figure><br>这段代码的第17行，构造了一个基类的对象，并将其设为子类构造函数的prototype，这是很有意思的。这样做的目的就是为了第28行，通过子类对象也可以直接调用基类prototype的方法。为什么可以这样呢？</p>
<p>原来，在JavaScript中，prototype不但能让对象共享自己财富，而且prototype还有寻根问祖的天性，从而使得先辈们的遗产可以代代相传。当从一个对象那里读取属性或调用方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的prototype对象那里寻找；如果 prototype没有，又会去prototype自己关联的前辈prototype那里寻找，直到找到或追溯过程结束为止。</p>
<p>在JavaScript内部，对象的属性和方法追溯机制是通过所谓的prototype链来实现的。当用new操作符构造对象时，也会同时将构造函数的 prototype对象指派给新创建的对象，成为该对象内置的原型对象。对象内置的原型对象应该是对外不可见的，尽管有些浏览器(如Firefox)可以让我们访问这个内置原型对象，但并不建议这样做。内置的原型对象本身也是对象，也有自己关联的原型对象，这样就形成了所谓的原型链。</p>
<p>在原型链的最末端，就是Object构造函数prototype属性指向的那一个原型对象。这个原型对象是所有对象的最老祖先，这个老祖宗实现了诸如 toString等所有对象天生就该具有的方法。其他内置构造函数，如Function, Boolean, String, Date和RegExp等的prototype都是从这个老祖宗传承下来的，但他们各自又定义了自身的属性和方法，从而他们的子孙就表现出各自宗族的那些特征。</p>
<p>这不就是“继承”吗？是的，这就是“继承”，是JavaScript特有的“原型继承”。</p>
<p>“原型继承”是慈祥而又严厉的。原形对象将自己的属性和方法无私地贡献给孩子们使用，也并不强迫孩子们必须遵从，允许一些顽皮孩子按自己的兴趣和爱好独立行事。从这点上看，原型对象是一位慈祥的母亲。然而，任何一个孩子虽然可以我行我素，但却不能动原型对象既有的财产，因为那可能会影响到其他孩子的利益。从这一点上看，原型对象又象一位严厉的父亲。我们来看看下面的代码就可以理解这个意思了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">Person.prototype.company &#x3D; “Microsoft”; &#x2F;&#x2F;原型的属性  </span><br><span class="line">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;原型的方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name + ” of ” + this.company);  </span><br><span class="line">&#125;;  </span><br><span class="line">var BillGates &#x3D; new Person(”Bill Gates”);  </span><br><span class="line">BillGates.SayHello(); &#x2F;&#x2F;由于继承了原型的东西，规规矩矩输出：Hello, I’m Bill Gates</span><br><span class="line"></span><br><span class="line">var SteveJobs &#x3D; new Person(”Steve Jobs”);  </span><br><span class="line">SteveJobs.company &#x3D; “Apple”; &#x2F;&#x2F;设置自己的company属性，掩盖了原型的company属性  </span><br><span class="line">SteveJobs.SayHello &#x3D; function() &#x2F;&#x2F;实现了自己的SayHello方法，掩盖了原型的SayHello方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hi, ” + this.name + ” like ” + this.company + “, ha ha ha “);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">SteveJobs.SayHello(); &#x2F;&#x2F;都是自己覆盖的属性和方法，输出：Hi, Steve Jobs like Apple, ha ha ha  </span><br><span class="line"></span><br><span class="line">BillGates.SayHello(); &#x2F;&#x2F;SteveJobs的覆盖没有影响原型对象，BillGates还是按老样子输出</span><br></pre></td></tr></table></figure><br>对象可以掩盖原型对象的那些属性和方法，一个构造函数原型对象也可以掩盖上层构造函数原型对象既有的属性和方法。这种掩盖其实只是在对象自己身上创建了新的属性和方法，只不过这些属性和方法与原型对象的那些同名而已。JavaScript就是用这简单的掩盖机制实现了对象的“多态”性，与静态对象语言的虚函数和重载(override)概念不谋而合。</p>
<p>然而，比静态对象语言更神奇的是，我们可以随时给原型对象动态添加新的属性和方法，从而动态地扩展基类的功能特性。这在静态对象语言中是很难想象的。我们来看下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">Person.prototype.SayHello &#x3D; function() &#x2F;&#x2F;建立对象前定义的方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; new Person(”Bill Gates”); &#x2F;&#x2F;建立对象  </span><br><span class="line"></span><br><span class="line">BillGates.SayHello();</span><br><span class="line"></span><br><span class="line">Person.prototype.Retire &#x3D; function() &#x2F;&#x2F;建立对象后再动态扩展原型的方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Poor ” + this.name + “, bye bye!”);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">BillGates.Retire(); &#x2F;&#x2F;动态扩展的方法即可被先前建立的对象立即调用</span><br></pre></td></tr></table></figure><br>阿弥佗佛，原型继承竟然可以玩出有这样的法术！</p>
<h4 id="原型扩展"><a href="#原型扩展" class="headerlink" title="原型扩展"></a>原型扩展</h4><p>想必君的悟性极高，可能你会这样想：如果在JavaScript内置的那些如Object和Function等函数的prototype上添加些新的方法和属性，是不是就能扩展JavaScript的功能呢？</p>
<p>那么，恭喜你，你得到了！</p>
<p>在AJAX技术迅猛发展的今天，许多成功的AJAX项目的JavaScript运行库都大量扩展了内置函数的prototype功能。比如微软的 ASP.NET AJAX，就给这些内置函数及其prototype添加了大量的新特性，从而增强了JavaScript的功能。</p>
<p>我们来看一段摘自MicrosoftAjax.debug.js中的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.trim &#x3D; function String$trim() &#123;  </span><br><span class="line">if (arguments.length !&#x3D;&#x3D; 0) throw Error.parameterCount();  </span><br><span class="line">return this.replace(&#x2F;^\s+|\s+$&#x2F;g, ”);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这段代码就是给内置String函数的prototype扩展了一个trim方法，于是所有的String类对象都有了trim方法了。有了这个扩展，今后要去除字符串两段的空白，就不用再分别处理了，因为任何字符串都有了这个扩展功能，只要调用即可，真的很方便。</p>
<p>当然，几乎很少有人去给Object的prototype添加方法，因为那会影响到所有的对象，除非在你的架构中这种方法的确是所有对象都需要的。</p>
<p>前两年，微软在设计AJAX类库的初期，用了一种被称为“闭包”(closure)的技术来模拟“类”。其大致模型如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(firstName, lastName, age)  </span><br><span class="line">&#123;  </span><br><span class="line">&#x2F;&#x2F;私有变量：  </span><br><span class="line">var &#96;_firstName&#96; &#x3D; firstName;  </span><br><span class="line">var &#96;_lastName&#96; &#x3D; lastName;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;公共变量:  </span><br><span class="line">this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法：  </span><br><span class="line">this.getName &#x3D; function()  </span><br><span class="line">&#123;  </span><br><span class="line">return(firstName + ” ” + lastName);  </span><br><span class="line">&#125;;  </span><br><span class="line">this.SayHello &#x3D; function()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + firstName + ” ” + lastName);  </span><br><span class="line">&#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; new Person(”Bill”, “Gates”, 53);  </span><br><span class="line">var SteveJobs &#x3D; new Person(”Steve”, “Jobs”, 53);  </span><br><span class="line"></span><br><span class="line">BillGates.SayHello();  </span><br><span class="line">SteveJobs.SayHello();  </span><br><span class="line">alert(BillGates.getName() + ” ” + BillGates.age);  </span><br><span class="line">alert(BillGates.firstName); &#x2F;&#x2F;这里不能访问到私有变量</span><br></pre></td></tr></table></figure><br>很显然，这种模型的类描述特别象C#语言的描述形式，在一个构造函数里依次定义了私有成员、公共属性和可用的方法，显得非常优雅嘛。特别是“闭包”机制可以模拟对私有成员的保护机制，做得非常漂亮。</p>
<p>所谓的“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层外层函数体中的临时变量。这使得只要目标对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新的值，和上次那次调用的是各自独立的。的确很巧妙！</p>
<p>但是前面我们说过，给每一个对象设置一份方法是一种很大的浪费。还有，“闭包”这种间接保持变量值的机制，往往会给JavaSript的垃圾回收器制造难题。特别是遇到对象间复杂的循环引用时，垃圾回收的判断逻辑非常复杂。无独有偶，IE浏览器早期版本确实存在JavaSript垃圾回收方面的内存泄漏问题。再加上“闭包”模型在性能测试方面的表现不佳，微软最终放弃了“闭包”模型，而改用“原型”模型。正所谓“有得必有失”嘛。</p>
<p>原型模型需要一个构造函数来定义对象的成员，而方法却依附在该构造函数的原型上。大致写法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义构造函数  </span><br><span class="line">function Person(name)  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name; &#x2F;&#x2F;在构造函数中定义成员  </span><br><span class="line">&#125;;  </span><br><span class="line">&#x2F;&#x2F;方法定义到构造函数的prototype上  </span><br><span class="line">Person.prototype.SayHello &#x3D; function()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类构造函数  </span><br><span class="line">function Employee(name, salary)  </span><br><span class="line">&#123;  </span><br><span class="line">Person.call(this, name); &#x2F;&#x2F;调用上层构造函数  </span><br><span class="line">this.salary &#x3D; salary; &#x2F;&#x2F;扩展的成员  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类构造函数首先需要用上层构造函数来建立prototype对象，实现继承的概念  </span><br><span class="line">Employee.prototype &#x3D; new Person() &#x2F;&#x2F;只需要其prototype的方法，此对象的成员没有任何意义！</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子类方法也定义到构造函数之上  </span><br><span class="line">Employee.prototype.ShowMeTheMoney &#x3D; function()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(this.name + ” $” + this.salary);  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; new Person(”Bill Gates”);  </span><br><span class="line">BillGates.SayHello();  </span><br><span class="line"></span><br><span class="line">var SteveJobs &#x3D; new Employee(”Steve Jobs”, 1234);  </span><br><span class="line">SteveJobs.SayHello();  </span><br><span class="line">SteveJobs.ShowMeTheMoney();</span><br></pre></td></tr></table></figure><br>原型类模型虽然不能模拟真正的私有变量，而且也要分两部分来定义类，显得不怎么“优雅”。不过，对象间的方法是共享的，不会遇到垃圾回收问题，而且性能优于“闭包”模型。正所谓“有失必有得”嘛。</p>
<p>在原型模型中，为了实现类继承，必须首先将子类构造函数的prototype设置为一个父类的对象实例。创建这个父类对象实例的目的就是为了构成原型链，以起到共享上层原型方法作用。但创建这个实例对象时，上层构造函数也会给它设置对象成员，这些对象成员对于继承来说是没有意义的。虽然，我们也没有给构造函数传递参数，但确实创建了若干没有用的成员，尽管其值是undefined，这也是一种浪费啊。</p>
<p>唉！世界上没有完美的事情啊！</p>
<h4 id="原型真谛"><a href="#原型真谛" class="headerlink" title="原型真谛"></a>原型真谛</h4><p>正当我们感概万分时，天空中一道红光闪过，祥云中出现了观音菩萨。只见她手持玉净瓶，轻拂翠柳枝，洒下几滴甘露，顿时让JavaScript又添新的灵气。</p>
<p>观音洒下的甘露在JavaScript的世界里凝结成块，成为了一种称为“语法甘露”的东西。这种语法甘露可以让我们编写的代码看起来更象对象语言。</p>
<p>要想知道这“语法甘露”为何物，就请君侧耳细听。</p>
<p>在理解这些语法甘露之前，我们需要重新再回顾一下JavaScript构造对象的过程。</p>
<p>我们已经知道，用 var anObject = new aFunction() 形式创建对象的过程实际上可以分为三步：第一步是建立一个新对象；第二步将该对象内置的原型对象设置为构造函数prototype引用的那个原型对象；第三步就是将该对象作为this参数调用构造函数，完成成员设置等初始化工作。对象建立之后，对象上的任何访问和操作都只与对象自身及其原型链上的那串对象有关，与构造函数再扯不上关系了。换句话说，构造函数只是在创建对象时起到介绍原型对象和初始化对象两个作用。</p>
<p>那么，我们能否自己定义一个对象来当作原型，并在这个原型上描述类，然后将这个原型设置给新创建的对象，将其当作对象的类呢？我们又能否将这个原型中的一个方法当作构造函数，去初始化新建的对象呢？例如，我们定义这样一个原型对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person &#x3D; &#x2F;&#x2F;定义一个对象来作为原型类  </span><br><span class="line">&#123;  </span><br><span class="line">Create: function(name, age) &#x2F;&#x2F;这个当构造函数  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">this.age &#x3D; age;  </span><br><span class="line">&#125;,  </span><br><span class="line">SayHello: function() &#x2F;&#x2F;定义方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name);  </span><br><span class="line">&#125;,  </span><br><span class="line">HowOld: function() &#x2F;&#x2F;定义方法  </span><br><span class="line">&#123;  </span><br><span class="line">alert(this.name + ” is ” + this.age + ” years old.”);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个JSON形式的写法多么象一个C#的类啊！既有构造函数，又有各种方法。如果可以用某种形式来创建对象，并将对象的内置的原型设置为上面这个“类”对象，不就相当于创建该类的对象了吗？</p>
<p>但遗憾的是，我们几乎不能访问到对象内置的原型属性！尽管有些浏览器可以访问到对象的内置原型，但这样做的话就只能限定了用户必须使用那种浏览器。这也几乎不可行。</p>
<p>那么，我们可不可以通过一个函数对象来做媒介，利用该函数对象的prototype属性来中转这个原型，并用new操作符传递给新建的对象呢？</p>
<p>其实，象这样的代码就可以实现这一目标：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function anyfunc()&#123;&#125;; &#x2F;&#x2F;定义一个函数躯壳  </span><br><span class="line">anyfunc.prototype &#x3D; Person; &#x2F;&#x2F;将原型对象放到中转站prototype  </span><br><span class="line">var BillGates &#x3D; new anyfunc(); &#x2F;&#x2F;新建对象的内置原型将是我们期望的原型对象</span><br></pre></td></tr></table></figure><br>不过，这个anyfunc函数只是一个躯壳，在使用过这个躯壳之后它就成了多余的东西了，而且这和直接使用构造函数来创建对象也没啥不同，有点不爽。</p>
<p>可是，如果我们将这些代码写成一个通用函数，而那个函数躯壳也就成了函数内的函数，这个内部函数不就可以在外层函数退出作用域后自动消亡吗？而且，我们可以将原型对象作为通用函数的参数，让通用函数返回创建的对象。我们需要的就是下面这个形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function New(aClass, aParams) &#x2F;&#x2F;通用创建函数  </span><br><span class="line">&#123;  </span><br><span class="line">function new_() &#x2F;&#x2F;定义临时的中转函数壳   </span><br><span class="line">&#123;  </span><br><span class="line">aClass.Create.apply(this, aParams); &#x2F;&#x2F;调用原型中定义的的构造函数，中转构造逻辑及构造参数  </span><br><span class="line">&#125;;  </span><br><span class="line">new_.prototype &#x3D; aClass; &#x2F;&#x2F;准备中转原型对象  </span><br><span class="line">return new new_(); &#x2F;&#x2F;返回建立最终建立的对象  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Person &#x3D; &#x2F;&#x2F;定义的类  </span><br><span class="line">&#123;  </span><br><span class="line">Create: function(name, age)  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">this.age &#x3D; age;  </span><br><span class="line">&#125;,  </span><br><span class="line">SayHello: function()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name);  </span><br><span class="line">&#125;,  </span><br><span class="line">HowOld: function()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(this.name + ” is ” + this.age + ” years old.”);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; New(Person, [”Bill Gates”, 53]); &#x2F;&#x2F;调用通用函数创建对象，并以数组形式传递构造参数  </span><br><span class="line">BillGates.SayHello();  </span><br><span class="line">BillGates.HowOld();  </span><br><span class="line"></span><br><span class="line">alert(BillGates.constructor &#x3D;&#x3D; Object); &#x2F;&#x2F;输出：true</span><br></pre></td></tr></table></figure><br>这里的通用函数New()就是一个“语法甘露”！这个语法甘露不但中转了原型对象，还中转了构造函数逻辑及构造参数。</p>
<p>有趣的是，每次创建完对象退出New函数作用域时，临时的new<em>函数对象会被自动释放。由于new</em>的prototype属性被设置为新的原型对象，其原来的原型对象和new_之间就已解开了引用链，临时函数及其原来的原型对象都会被正确回收了。上面代码的最后一句证明，新创建的对象的 constructor属性返回的是Object函数。其实新建的对象自己及其原型里没有constructor属性，那返回的只是最顶层原型对象的构造函数，即Object。</p>
<p>有了New这个语法甘露，类的定义就很像C#那些静态对象语言的形式了，这样的代码显得多么文静而优雅啊！</p>
<p>当然，这个代码仅仅展示了“语法甘露”的概念。我们还需要多一些的语法甘露，才能实现用简洁而优雅的代码书写类层次及其继承关系。好了，我们再来看一个更丰富的示例吧：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;语法甘露：  </span><br><span class="line">var object &#x3D; &#x2F;&#x2F;定义小写的object基本类，用于实现最基础的方法等  </span><br><span class="line">&#123;  </span><br><span class="line">isA: function(aType) &#x2F;&#x2F;一个判断类与类之间以及对象与类之间关系的基础方法  </span><br><span class="line">&#123;  </span><br><span class="line">var self &#x3D; this;  </span><br><span class="line">while(self)  </span><br><span class="line">&#123;  </span><br><span class="line">if (self &#x3D;&#x3D; aType)  </span><br><span class="line">return true;  </span><br><span class="line">self &#x3D; self.Type;  </span><br><span class="line">&#125;;  </span><br><span class="line">return false;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">function Class(aBaseClass, aClassDefine) &#x2F;&#x2F;创建类的函数，用于声明类及继承关系  </span><br><span class="line">&#123;  </span><br><span class="line">function class_() &#x2F;&#x2F;创建类的临时函数壳  </span><br><span class="line">&#123;  </span><br><span class="line">this.Type &#x3D; aBaseClass; &#x2F;&#x2F;我们给每一个类约定一个Type属性，引用其继承的类  </span><br><span class="line">for(var member in aClassDefine)  </span><br><span class="line">this[member] &#x3D; aClassDefine[member]; &#x2F;&#x2F;复制类的全部定义到当前创建的类  </span><br><span class="line">&#125;;  </span><br><span class="line">class_.prototype &#x3D; aBaseClass;  </span><br><span class="line">return new class_();  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">function New(aClass, aParams) &#x2F;&#x2F;创建对象的函数，用于任意类的对象创建  </span><br><span class="line">&#123;  </span><br><span class="line">function new_() &#x2F;&#x2F;创建对象的临时函数壳  </span><br><span class="line">&#123;  </span><br><span class="line">this.Type &#x3D; aClass; &#x2F;&#x2F;我们也给每一个对象约定一个Type属性，据此可以访问到对象所属的类  </span><br><span class="line">if (aClass.Create)  </span><br><span class="line">aClass.Create.apply(this, aParams); &#x2F;&#x2F;我们约定所有类的构造函数都叫Create，这和DELPHI比较相似  </span><br><span class="line">&#125;;  </span><br><span class="line">new_.prototype &#x3D; aClass;  </span><br><span class="line">return new new_();  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法甘露的应用效果：  </span><br><span class="line">var Person &#x3D; Class(object, &#x2F;&#x2F;派生至object基本类  </span><br><span class="line">&#123;  </span><br><span class="line">Create: function(name, age)  </span><br><span class="line">&#123;  </span><br><span class="line">this.name &#x3D; name;  </span><br><span class="line">this.age &#x3D; age;  </span><br><span class="line">&#125;,  </span><br><span class="line">SayHello: function()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(”Hello, I’m ” + this.name + “, ” + this.age + ” years old.”);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">var Employee &#x3D; Class(Person, &#x2F;&#x2F;派生至Person类，是不是和一般对象语言很相似？  </span><br><span class="line">&#123;  </span><br><span class="line">Create: function(name, age, salary)  </span><br><span class="line">&#123;  </span><br><span class="line">Person.Create.call(this, name, age); &#x2F;&#x2F;调用基类的构造函数  </span><br><span class="line">this.salary &#x3D; salary;  </span><br><span class="line">&#125;,  </span><br><span class="line">ShowMeTheMoney: function()  </span><br><span class="line">&#123;  </span><br><span class="line">alert(this.name + ” $” + this.salary);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">var BillGates &#x3D; New(Person, [”Bill Gates”, 53]);  </span><br><span class="line">var SteveJobs &#x3D; New(Employee, [”Steve Jobs”, 53, 1234]);  </span><br><span class="line">BillGates.SayHello();  </span><br><span class="line">SteveJobs.SayHello();  </span><br><span class="line">SteveJobs.ShowMeTheMoney();  </span><br><span class="line"></span><br><span class="line">var LittleBill &#x3D; New(BillGates.Type, [”Little Bill”, 6]); &#x2F;&#x2F;根据BillGate的类型创建LittleBill  </span><br><span class="line">LittleBill.SayHello();  </span><br><span class="line"></span><br><span class="line">alert(BillGates.isA(Person)); &#x2F;&#x2F;true  </span><br><span class="line">alert(BillGates.isA(Employee)); &#x2F;&#x2F;false  </span><br><span class="line">alert(SteveJobs.isA(Person)); &#x2F;&#x2F;true  </span><br><span class="line">alert(Person.isA(Employee)); &#x2F;&#x2F;false  </span><br><span class="line">alert(Employee.isA(Person)); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><br>“语法甘露”不用太多，只要那么一点点，就能改观整个代码的易读性和流畅性，从而让代码显得更优雅。有了这些语法甘露，JavaScript就很像一般对象语言了，写起代码了感觉也就爽多了！  </p>
<p>令人高兴的是，受这些甘露滋养的JavaScript程序效率会更高。因为其原型对象里既没有了毫无用处的那些对象级的成员，而且还不存在 constructor属性体，少了与构造函数间的牵连，但依旧保持了方法的共享性。这让JavaScript在追溯原型链和搜索属性及方法时，少费许多工夫啊。</p>
<p>我们就把这种形式称为“甘露模型”吧！其实，这种“甘露模型”的原型用法才是符合prototype概念的本意，才是的JavaScript原型的真谛！</p>
<p>想必微软那些设计AJAX架构的工程师看到这个甘露模型时，肯定后悔没有早点把AJAX部门从美国搬到咱中国的观音庙来，错过了观音菩萨的点化。当然，我们也只能是在代码的示例中，把Bill Gates当作对象玩玩，真要让他放弃上帝转而皈依我佛肯定是不容易的，机缘未到啊！如果哪天你在微软新出的AJAX类库中看到这种甘露模型，那才是真正的缘分！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/note/" rel="tag"># note</a>
              <a href="/tags/javascript/" rel="tag"># javascript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2012/08/18/thinking/note-money-making-logic/" rel="prev" title="弄不懂真正的“赚钱逻辑”，你永远都是社会最底层！">
      <i class="fa fa-chevron-left"></i> 弄不懂真正的“赚钱逻辑”，你永远都是社会最底层！
    </a></div>
      <div class="post-nav-item">
    <a href="/2013/08/09/linux/decompression-mode-in-linux/" rel="next" title="Linux下文件压缩命令">
      Linux下文件压缩命令 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#回归简单"><span class="nav-number">1.</span> <span class="nav-text">回归简单</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#没有类"><span class="nav-number">1.0.1.</span> <span class="nav-text">没有类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数的魔力"><span class="nav-number">1.0.2.</span> <span class="nav-text">函数的魔力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#奇妙的对象"><span class="nav-number">1.0.3.</span> <span class="nav-text">奇妙的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#放下对象"><span class="nav-number">1.0.4.</span> <span class="nav-text">放下对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象素描"><span class="nav-number">1.0.5.</span> <span class="nav-text">对象素描</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造对象"><span class="nav-number">1.0.6.</span> <span class="nav-text">构造对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初看原型"><span class="nav-number">1.0.7.</span> <span class="nav-text">初看原型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型扩展"><span class="nav-number">1.0.8.</span> <span class="nav-text">原型扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型真谛"><span class="nav-number">1.0.9.</span> <span class="nav-text">原型真谛</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Themis</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW5na2VmZWk=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangkefei"><i class="github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnpoa2YuaHVudGVyQGljbG91ZC5jb20=" title="E-Mail → mailto:zhkf.hunter@icloud.com"><i class="envelope fa-fw"></i></span>
      </span>
  </div>


<div class="cc-license motion-element" itemprop="sponsor">
</div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2010 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NexT</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly9taXN0LnRoZW1lLW5leHQub3Jn">NexT.Mist</span> 强力驱动
  </div><div class="footer-custom">
</div>


        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
